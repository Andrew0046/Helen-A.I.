
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helen A.I.</title>
  

  <link rel="icon" href="2pic.png" type="image/jpeg">

 <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/xlsx.full.min.js"></script>
<style>
       /* ========================================
   MODERN GLASS THEME - IMPROVED
   ======================================== */

/* Import Fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Root Variables - Consolidated and Organized */
:root {
    /* Core Colors */
    --bg-primary: #ffffff;
    --bg-secondary: #f4f7f6;
    --text-primary: #111827;
    --text-secondary: #6b7280;
    --accent: #0D9488; /* Deep Teal */
    --accent-hover: #0F766E; /* Darker Teal */
    --border: #e5e7eb;
    --glass-border: rgba(255, 255, 255, 0.4);
    --user-message-bg: #0D9488;
    --background-gradient: linear-gradient(135deg, #EBF4FF 0%, #E6F0FF 100%);

    /* Effects */
    --chat-bg: rgba(255, 255, 255, 0.85); /* Glass Background */
    --shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Softer Shadow */

    /* Orb Specific - Consolidated from later section */
    --glow-primary: rgba(0, 238, 255, 0.6);
    --glow-secondary: rgba(0, 170, 221, 0.4);
    --shine: rgba(255, 255, 255, 0.4);
    --shadow-orb: rgba(0, 0, 0, 0.55);
    --focus-blur: 14px;
    --focus-dark: 0.35;
}

/* Dark Theme */
[data-theme="dark"] {
    --bg-primary: #111827;
    --bg-secondary: #1f2937;
    --text-primary: #f9fafb;
    --text-secondary: #9ca3af;
    --chat-bg: rgba(255, 255, 255, 0.1);
    --border: #4b5563;
    --glass-border: rgba(255, 255, 255, 0.2);
    --background-gradient: linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%);
    --accent: #0D9488; /* Keep consistent, or adjust if needed */
    --accent-hover: #0F766E;
    --user-message-bg: #0D9488;
}

/* Midnight Theme */
[data-theme="midnight"] {
    --bg-primary: #000000;
    --bg-secondary: #1a202c;
    --text-primary: #e2e8f0;
    --text-secondary: #a0aec0;
    --accent: #F59E0B; /* Gold */
    --accent-hover: #D97706;
    --chat-bg: rgba(255, 255, 255, 0.08);
    --border: #4a5568;
    --glass-border: rgba(255, 255, 255, 0.15);
    --user-message-bg: #F59E0B;
    --background-gradient: linear-gradient(135deg, #1a202c 0%, #000000 100%);
}

/* Global Styles */
body {
    font-family: 'Inter', sans-serif;
    background: var(--background-gradient);
    min-height: 100vh;
    color: var(--text-primary);
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

.hidden {
    display: none;
}

/* ========================================
   LANDING PAGE STYLES
   ======================================== */
#landing-page {
    background-color: var(--bg-primary);
}

.landing-nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    background-color: var(--bg-primary);
    box-shadow: var(--shadow);
    position: sticky;
    top: 0;
    z-index: 100;
}

.landing-nav .logo-text {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent);
}

#show-login-btn {
    background-color: var(--accent);
    color: white;
    padding: 0.5rem 1.5rem;
    border-radius: 8px;
    font-weight: 500;
    transition: background-color 0.3s ease;
}

#show-login-btn:hover {
    background-color: var(--accent-hover);
}

.landing-section {
    padding: 4rem 2rem;
    text-align: center;
    max-width: 1200px;
    margin: 0 auto;
}

#about {
    min-height: 80vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

#about h1 {
    font-size: 4rem;
    font-weight: 700;
    background: linear-gradient(45deg, var(--accent), #a855f7);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 1.5rem;
}

#about p {
    font-size: 1.25rem;
    color: var(--text-secondary);
    max-width: 600px;
    margin-bottom: 2rem;
}

#discover-btn {
    background: linear-gradient(45deg, var(--accent), #a855f7);
    color: white;
    padding: 0.75rem 2rem;
    border-radius: 8px;
    font-weight: 600;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

#discover-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
}

#features h2, #mission h2 {
    font-size: 2.5rem;
    font-weight: 600;
    margin-bottom: 3rem;
}

.features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
    text-align: left;
}

.feature-card {
    background: var(--bg-primary);
    padding: 2rem;
    border-radius: 12px;
    box-shadow: var(--shadow);
    border: 1px solid var(--border);
}

.feature-card .icon {
    width: 48px;
    height: 48px;
    color: var(--accent);
    margin-bottom: 1rem;
}

.feature-card h3 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.feature-card p {
    color: var(--text-secondary);
}

#mission {
    background-color: var(--bg-secondary);
}

#mission p {
    font-size: 1.25rem;
    color: var(--text-secondary);
    max-width: 700px;
    margin: 0 auto 2rem auto;
}

#quote-display {
    font-style: italic;
    font-size: 1.1rem;
    color: var(--text-primary);
    margin-bottom: 2rem;
    min-height: 50px;
}

#new-quote-btn {
    background-color: var(--accent);
    color: white;
    padding: 0.5rem 1.5rem;
    border-radius: 8px;
    font-weight: 500;
    transition: background-color 0.3s ease;
}

#new-quote-btn:hover {
    background-color: var(--accent-hover);
}

/* ========================================
   MAIN LAYOUT
   ======================================== */
.container {
    display: flex;
    flex-direction: row;
    width: 100%;
    max-width: 1400px;
    gap: 16px;
    margin: 0 auto;
    height: 100vh;
    padding: 16px;
    box-sizing: border-box;
}

.sidebar-left {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 200px;
    flex-shrink: 0;
    position: relative;
    z-index: 101;
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
}

.centered-image {
    width: 180px;
    height: 288px;
    border-radius: 12px;
    object-fit: contain;
    box-shadow: var(--shadow);
    transition: transform 0.3s ease;
}

.centered-image:hover {
    transform: scale(1.05);
}

/* Image Animations - Improved smoothness */
@keyframes breathing {
    0%, 100% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.03);
        opacity: 0.9;
    }
}

.centered-image.thinking {
    animation: breathing 4s ease-in-out infinite;
}

@keyframes speakingGlow {
    0%, 100% {
        box-shadow: 0 0 15px var(--accent);
        transform: scale(1.05);
    }
    50% {
        box-shadow: 0 0 35px var(--accent);
        transform: scale(1.07);
    }
}

.centered-image.speaking {
    animation: speakingGlow 1.5s ease-in-out infinite;
}

.main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

/* ========================================
   INPUT CONTAINER
   ======================================== */
.input-container {
    width: 100%;
    max-width: 900px;
    background: var(--chat-bg);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: var(--shadow);
    border: 1px solid var(--glass-border);
    z-index: 10;
}

#mic-button,
#send-button,
#menu-button,
#attachment-button {
    position: relative;
    border-radius: 50%;
    padding: 12px;
    background: linear-gradient(180deg, var(--accent) 0%, var(--accent-hover) 100%);
    border: 1px solid var(--accent-hover);
    box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.3), var(--shadow);
    transition: background-color 0.3s ease, transform 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

#mic-button:hover,
#send-button:hover,
#menu-button:hover,
#attachment-button:hover {
    background-color: var(--accent-hover);
    transform: translateY(-2px);
}

#mic-button:active,
#send-button:active,
#menu-button:active,
#attachment-button:active {
    transform: scale(0.92);
    transition: transform 0.1s ease;
}

#mic-button svg,
#send-button svg,
#menu-button svg,
#attachment-button svg {
    width: 24px;
    height: 24px;
    color: white;
}

#audio-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.3);
    transition: transform 0.05s ease-out, opacity 0.05s ease-out;
    opacity: 0;
}

#mic-button.listening #audio-indicator {
    opacity: 1;
}

/* ========================================
   CHAT DISPLAY
   ======================================== */
#chat-display {
    flex-grow: 1;
    width: 100%;
    max-width: 900px;
    background: var(--chat-bg);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: var(--shadow);
    border: 1px solid var(--glass-border);
    padding: 16px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 12px;
    min-height: 300px;
}

#chat-display::-webkit-scrollbar {
    width: 6px;
}

#chat-display::-webkit-scrollbar-track {
    background: var(--bg-secondary);
    border-radius: 10px;
}

#chat-display::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 10px;
}

.message {
    padding: 12px 16px;
    border-radius: 8px;
    max-width: 80%;
    font-size: 0.95rem;
    line-height: 1.5;
    position: relative;
    display: flex;
    flex-direction: column;
}

.message .content {
    margin-bottom: 8px;
}

.message-attachment {
    margin-top: 8px;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background-color: var(--bg-secondary);
}

.message-attachment img {
    max-width: 100%;
    border-radius: 4px;
}

.message-attachment pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    padding: 8px;
    border-radius: 4px;
}

.user-message {
    align-self: flex-end;
    background: linear-gradient(180deg, var(--user-message-bg) 0%, var(--accent-hover) 100%);
    box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.2), var(--shadow);
    color: white;
    border-bottom-right-radius: 8px;
}

.helen-message {
    align-self: flex-start;
    background-color: var(--bg-primary);
    box-shadow: var(--shadow);
    color: var(--text-primary);
    border-bottom-left-radius: 8px;
}

.helen-error-message {
    align-self: flex-start;
    background-color: #fee2e2;
    color: #b91c1c;
    border: 1px solid #f87171;
    border-bottom-left-radius: 8px;
}

.message .timestamp {
    font-size: 0.7rem;
    opacity: 0.7;
    align-self: flex-end;
}

.user-message .timestamp {
    color: rgba(255, 255, 255, 0.8);
}

.helen-message .timestamp {
    color: var(--text-secondary);
}

.typing-indicator span {
    display: inline-block;
    background-color: var(--text-secondary);
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin: 0 3px;
    animation: bounce 1.2s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) { animation-delay: -0.3s; }
.typing-indicator span:nth-child(2) { animation-delay: -0.15s; }
.typing-indicator span:nth-child(3) { animation-delay: 0s; }

@keyframes bounce {
    0%, 80%, 100% { transform: translateY(0); opacity: 0.6; }
    40% { transform: translateY(-6px); opacity: 1; }
}

/* New Message Animation */
@keyframes fadeInSlideUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message.new-message-animation {
    animation: fadeInSlideUp 0.4s ease-out forwards;
}

/* ========================================
   MANAGER SIDEBAR
   ======================================== */
.manager-sidebar {
    position: fixed;
    top: 0;
    right: 0;
    width: 100%;
    max-width: 400px;
    height: 100%;
    background: var(--chat-bg);
    backdrop-filter: blur(10px);
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
    border-left: 1px solid var(--glass-border);
    transform: translateX(100%);
    transition: transform 0.3s ease-in-out;
    display: flex;
    flex-direction: column;
    z-index: 1000;
}

.manager-sidebar.active {
    transform: translateX(0);
}

.manager-header {
    padding: 16px;
    background: var(--accent);
    color: white;
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.manager-close-btn {
    background: none;
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.manager-close-btn:hover {
    transform: rotate(90deg);
}

#menu-options {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    flex-grow: 1;
    overflow-y: auto;
}

#menu-options::-webkit-scrollbar {
    width: 6px;
}

#menu-options::-webkit-scrollbar-track {
    background: var(--bg-secondary);
    border-radius: 10px;
}

#menu-options::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 10px;
}

.menu-option {
    background: var(--bg-primary);
    border-radius: 8px;
    padding: 12px;
    box-shadow: var(--shadow);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: transform 0.2s ease, background-color 0.2s ease;
}

.menu-option:hover {
    transform: translateY(-2px);
    background-color: var(--bg-secondary);
}

.menu-option .icon {
    width: 20px;
    height: 20px;
    color: var(--accent);
}

.menu-option span {
    font-weight: 500;
    color: var(--text-primary);
}

/* List Styles - Consolidated */
#notes-list, #reminders-list, #past-chats-list, #memory-list, #preferences-list, #people-list, #goals-list, #journal-list, #knowledge-list, #profile-content, #routines-list, #email-content, #habits-list, #idea-hub-list, #review-list {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.past-chat-item, .goal-item, .journal-entry, .idea-board-item, .review-item, .habit-item, .note-item, .reminder-item {
    background: var(--bg-primary);
    border-radius: 8px;
    padding: 12px;
    box-shadow: var(--shadow);
}

.past-chat-item .chat-title, .goal-item-title, .journal-entry-title, .idea-board-item .board-title {
    font-weight: 600;
    cursor: pointer;
}

.past-chat-item:hover, .idea-board-item:hover {
    background: var(--bg-secondary);
}

.note-item p, .reminder-item p, .past-chat-item .chat-title, .journal-entry-content {
    font-size: 0.9rem;
    color: var(--text-primary);
    margin-bottom: 8px;
}

.past-chat-item .chat-summary {
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-style: italic;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border);
}

.note-item .timestamp, .reminder-item .schedule, .reminder-item .status, .journal-entry .timestamp, .idea-board-item .timestamp, .review-item .timestamp {
    font-size: 0.75rem;
    color: var(--text-secondary);
    text-align: right;
}

/* Actions - Consolidated */
.note-item-actions, .reminder-item-actions, .past-chat-actions, .goal-item-actions, .journal-entry-actions, .idea-board-actions, .review-item-actions, .email-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 8px;
}

.note-item-actions button, .reminder-item-actions button, #add-new-note-btn, .past-chat-actions button, #add-new-memory-btn, #add-new-preference-btn, #add-new-person-btn, #add-new-goal-btn, .goal-item-actions button, #add-new-journal-entry-btn, .journal-entry-actions button, #add-new-knowledge-btn, #add-new-routine-btn, .email-actions button, #add-new-habit-btn, #add-new-idea-board-btn, .idea-board-actions button, .review-item-actions button {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.note-item-actions button:hover, .reminder-item-actions button:hover, #add-new-note-btn:hover, .past-chat-actions button:hover, #add-new-memory-btn:hover, #add-new-preference-btn:hover, #add-new-person-btn:hover, #add-new-goal-btn:hover, .goal-item-actions button:hover, #add-new-journal-entry-btn:hover, .journal-entry-actions button:hover, #add-new-knowledge-btn:hover, #add-new-routine-btn:hover, .email-actions button:hover, #add-new-habit-btn:hover, #add-new-idea-board-btn:hover, .idea-board-actions button:hover, .review-item-actions button:hover {
    background: var(--accent);
    color: white;
}

.note-item p[contenteditable="true"], .journal-entry-content[contenteditable="true"] {
    border: 1px dashed var(--accent);
    padding: 6px;
    background: var(--bg-secondary);
}

/* Overlay */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-in-out;
}

.overlay.active {
    opacity: 1;
    visibility: visible;
}

/* ========================================
   MODAL STYLES
   ======================================== */
.modal-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1005;
    backdrop-filter: blur(5px);
}

.modal-content {
    background: var(--bg-primary);
    padding: 2rem;
    border-radius: 12px;
    box-shadow: var(--shadow);
    width: 90%;
    max-width: 500px;
}

.modal-content h3 {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 1rem;
}

.modal-content textarea {
    width: 100%;
    min-height: 100px;
    padding: 0.75rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 1rem;
    color: var(--text-primary);
    background: var(--bg-secondary);
    resize: vertical;
}

.modal-actions {
    margin-top: 1.5rem;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

.modal-actions button {
    padding: 0.5rem 1.5rem;
    border-radius: 8px;
    font-weight: 500;
    transition: background-color 0.3s ease;
    border: none;
}

#modal-save-btn {
    background-color: var(--accent);
    color: white;
}

#modal-save-btn:hover {
    background-color: var(--accent-hover);
}

#modal-cancel-btn {
    background-color: var(--bg-secondary);
    color: var(--text-primary);
}

#modal-cancel-btn:hover {
    background-color: var(--border);
}

/* ========================================
   SETTINGS
   ======================================== */
#settings-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px;
}

.settings-section {
    background: var(--bg-primary);
    border-radius: 8px;
    padding: 12px;
    box-shadow: var(--shadow);
    margin-bottom: 16px;
}

.settings-section h3 {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text-primary);
}

#voice-select, #theme-toggle, #persona-select {
    width: 100%;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--bg-secondary);
    font-size: 0.9rem;
    cursor: pointer;
    color: var(--text-primary);
}

#button-color-picker, #background-color-picker, #user-message-color-picker {
    width: 100%;
    height: 40px;
    border-radius: 8px;
    border: 1px solid var(--border);
    cursor: pointer;
    background: var(--bg-secondary);
}

#clear-local-storage-btn, #logout-btn {
    background: #dc2626;
    color: white;
    padding: 8px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 0.9rem;
    width: 100%;
    transition: background-color 0.2s ease;
}

#clear-local-storage-btn:hover, #logout-btn:hover {
    background: #b91c1c;
}

/* ========================================
   NOTIFICATIONS
   ======================================== */
.notification-popup {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease-in-out;
    z-index: 1001;
    display: flex;
    align-items: center;
    gap: 12px;
    max-width: 90%;
}

.notification-popup.show {
    opacity: 1;
    visibility: visible;
}

.notification-close-btn {
    background: none;
    border: none;
    color: var(--text-primary);
    font-size: 1.2rem;
    cursor: pointer;
    opacity: 0.7;
}

.notification-popup.success { background: #22c55e; color: white; }
.notification-popup.error { background: #dc2626; color: white; }
.notification-popup.info { background: #3b82f6; color: white; }

/* ========================================
   MESSAGE ACTIONS
   ======================================== */
.message-actions {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    align-self: flex-end;
}

.message-actions button {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 4px;
    transition: color 0.2s ease;
}

.message-actions button:hover {
    color: var(--accent);
}

.message-actions button svg {
    width: 20px;
    height: 20px;
}

/* ========================================
   LOGIN FORM
   ======================================== */
.login-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1002;
    backdrop-filter: blur(5px);
}

.login-wrapper {
    display: grid;
    grid-template-columns: 1fr 1fr;
    background-color: var(--bg-primary);
    border-radius: 12px;
    box-shadow: var(--shadow);
    overflow: hidden;
    width: 100%;
    max-width: 900px;
    margin: 2rem;
}

.login-welcome {
    background-color: var(--accent);
    color: #fff;
    padding: 3rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: center;
}

.login-welcome .logo {
    margin-bottom: 1.5rem;
}

.login-welcome h2 {
    font-size: 2rem;
    font-weight: 600;
    margin: 0 0 0.5rem 0;
}

.login-welcome p {
    font-size: 1rem;
    opacity: 0.8;
}

.login-form {
    padding: 3rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.login-form h2 {
    font-size: 1.75rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 2rem 0;
    text-align: center;
}

.input-group {
    margin-bottom: 1.5rem;
}

.input-group label {
    display: block;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}

.input-group input {
    width: 100%;
    box-sizing: border-box;
    padding: 0.75rem 1rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 1rem;
    color: var(--text-primary);
    transition: border-color 0.2s;
}

.input-group input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

#login-submit-btn {
    width: 100%;
    padding: 0.75rem;
    border: none;
    border-radius: 8px;
    background-color: var(--accent);
    color: #fff;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s;
}

#login-submit-btn:hover {
    background-color: var(--accent-hover);
}

.toggle-auth {
    margin-top: 1.5rem;
    text-align: center;
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.toggle-auth .toggle-link {
    color: var(--accent);
    font-weight: 500;
    cursor: pointer;
}

.toggle-auth .toggle-link:hover {
    text-decoration: underline;
}

/* ========================================
   GOAL TRACKER
   ======================================== */
.goal-item-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.todo-list {
    list-style: none;
    padding-left: 1rem;
    margin-top: 0.5rem;
}

.todo-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
    padding: 0.25rem 0;
}

.todo-item input[type="checkbox"] {
    cursor: pointer;
}

.todo-item span.completed {
    text-decoration: line-through;
    opacity: 0.6;
}

.todo-item .delete-todo-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    margin-left: auto;
    padding: 2px;
}

.todo-item .delete-todo-btn:hover {
    color: #dc2626;
}

/* Level Status */
#level-status-container {
    width: 100%;
    max-width: 900px;
    background: var(--chat-bg);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px 16px;
    box-shadow: var(--shadow);
    border: 1px solid var(--glass-border);
}

#level-status-text {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

#progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: var(--border);
    border-radius: 9999px;
    overflow: hidden;
}

#progress-bar {
    height: 100%;
    width: 0%;
    background-color: var(--accent);
    border-radius: 9999px;
    transition: width 0.5s ease;
}

.badge-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 1rem;
}

.badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.badge .icon {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    filter: grayscale(1);
    opacity: 0.5;
}

.badge.unlocked .icon {
    filter: grayscale(0);
    opacity: 1;
}

.badge span {
    font-size: 0.75rem;
    font-weight: 500;
}

/* ========================================
   HABIT TRACKER
   ======================================== */
.habit-item {
    display: flex;
    align-items: center;
    gap: 12px;
}

.habit-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
    accent-color: var(--accent);
}

.habit-item .habit-text {
    flex-grow: 1;
    font-size: 0.9rem;
}

.habit-item .habit-streak {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 4px;
}

.habit-item .delete-habit-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 4px;
}

.habit-item .delete-habit-btn:hover {
    color: #dc2626;
}

/* ========================================
   IDEA HUB
   ======================================== */
#idea-hub-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-secondary);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.4s ease-in-out;
}

#idea-hub-container.active {
    transform: translateY(0);
}

.idea-hub-header {
    padding: 1rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.idea-hub-header h2 {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
}

#close-idea-hub-btn {
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

#idea-board {
    display: flex;
    gap: 1rem;
    padding: 1rem;
    overflow-x: auto;
    flex-grow: 1;
    align-items: flex-start;
}

.idea-column {
    background-color: var(--bg-primary);
    border-radius: 12px;
    width: 300px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow);
    border: 1px solid var(--border);
}

.idea-column-header {
    padding: 0.75rem;
    font-weight: 600;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.suggest-idea-btn {
    background: none;
    border: 1px solid transparent;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.2s ease;
}

.suggest-idea-btn:hover {
    background-color: var(--bg-secondary);
    border-color: var(--border);
    transform: rotate(15deg) scale(1.1);
}

.idea-cards {
    padding: 0.5rem;
    min-height: 100px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.idea-card {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    padding: 0.75rem;
    border: 1px solid var(--border);
    cursor: grab;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.idea-card.dragging {
    opacity: 0.5;
    transform: rotate(3deg);
}

.idea-card p {
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
}

.idea-card-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

.idea-card-actions button {
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 0.75rem;
    cursor: pointer;
}

.add-card-btn {
    width: calc(100% - 1rem);
    margin: 0.5rem;
    padding: 0.5rem;
    border: 1px dashed var(--border);
    background: none;
    border-radius: 8px;
    cursor: pointer;
    color: var(--text-secondary);
}

#add-column-btn {
    background-color: var(--bg-primary);
    border-radius: 12px;
    width: 300px;
    flex-shrink: 0;
    padding: 1rem;
    cursor: pointer;
    border: 2px dashed var(--border);
    color: var(--text-secondary);
}

/* Idea Card Tags */
.idea-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 8px;
}

.idea-card-header p {
    flex-grow: 1;
}

.idea-tag {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
    margin-top: 4px;
    border: 1px solid rgba(0,0,0,0.1);
}

.tag-default { background-color: #d1d5db; }
.tag-red { background-color: #ef4444; }
.tag-blue { background-color: #3b82f6; }
.tag-green { background-color: #22c55e; }
.tag-yellow { background-color: #eab308; }

/* ========================================
   PROJECT ROADMAP
   ======================================== */
#roadmap-board {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
}

.roadmap-column {
    background-color: var(--bg-primary);
    border-radius: 12px;
    width: 300px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow);
    border: 1px solid var(--border);
}

.roadmap-column-header {
    padding: 0.75rem;
    font-weight: 600;
    border-bottom: 1px solid var(--border);
}

.roadmap-goals {
    padding: 0.5rem;
    min-height: 100px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.roadmap-goal-card {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    padding: 0.75rem;
    border: 1px solid var(--border);
    cursor: grab;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.roadmap-goal-card.dragging {
    opacity: 0.5;
}

/* ========================================
   REVIEW CENTER
   ======================================== */
.review-item {
    border-left: 4px solid var(--text-secondary); /* Default border */
}

.review-item.liked {
    border-left-color: #22c55e; /* Green */
}

.review-item.disliked {
    border-left-color: #ef4444; /* Red */
}

.review-item p {
    font-size: 0.9rem;
    color: var(--text-primary);
    margin-bottom: 8px;
}

/* ========================================
   HELEN ORB AI - SUPREME ENHANCEMENT
   ======================================== */

/* Go-Live Toggle (Button to Orb) */
.go-live-toggle {
    margin-top: 1.5rem;
    padding: 0.5rem 1.5rem;
    width: 120px;
    height: 40px;
    background-color: var(--accent);
    color: white;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    border: none;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
}

.go-live-toggle:hover {
    background-color: var(--accent-hover);
}

.go-live-text {
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
}

/* Orb Visuals Container */
.ai-orb-visuals {
    width: 160px;
    height: 160px;
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.4s 0.1s ease, transform 0.4s 0.1s ease;
    animation: water-warp 9s ease-in-out infinite;
}

/* Pulse Ring */
.ai-orb-visuals .ai-orb-pulse {
    width: 100%;
    height: 100%;
    position: absolute;
    border-radius: 50%;
    background: none;
    border: 2.5px solid rgba(255, 255, 255, 0.55);
    box-shadow: 0 0 12px rgba(255, 255, 255, 0.25);
    z-index: 1;
    opacity: 0;
    animation: pulse-light 3.2s ease-out infinite paused;
}

/* Shine Glint */
.ai-orb-visuals::after {
    content: '';
    width: 100%;
    height: 100%;
    position: absolute;
    border-radius: 50%;
    background: linear-gradient(100deg, transparent 30%, rgba(255, 255, 255, 0.3) 50%, transparent 70%);
    background-size: 220% 100%;
    z-index: 3;
    animation: shine-wipe 4.2s ease-in-out infinite paused;
    animation-delay: 1s;
}

/* Outer Glow */
.ai-orb-visuals .ai-orb-glow {
    width: 150%;
    height: 150%;
    position: absolute;
    border-radius: 50%;
    background: var(--accent);
    z-index: 0;
    opacity: 0.12;
    filter: blur(25px);
    animation: ripple-glow 3.2s ease-out infinite paused;
}

/* Live State */
.go-live-toggle.live {
    width: 160px;
    height: 160px;
    border-radius: 50%;
    background: radial-gradient(circle, var(--accent) 20%, var(--accent-hover) 100%);
    animation: float 6s ease-in-out infinite, pulse-shadow 3.5s ease-in-out infinite;
    transition: box-shadow 0.6s ease-in-out;
}

.go-live-toggle.live .go-live-text {
    opacity: 0;
}

.go-live-toggle.live .ai-orb-visuals {
    opacity: 1;
    transform: scale(1);
}

/* Speaking State */
.go-live-toggle.live.speaking {
    animation: float 6s ease-in-out infinite, pulse-shadow 1.6s ease-in-out infinite;
}

.go-live-toggle.live.speaking .ai-orb-visuals::after,
.go-live-toggle.live.speaking .ai-orb-visuals .ai-orb-pulse,
.go-live-toggle.live.speaking .ai-orb-visuals .ai-orb-glow,
.go-live-toggle.live.speaking .ai-orb-visuals::before {
    animation-play-state: running;
}

.go-live-toggle.live.speaking .ai-orb-visuals::before {
    animation-name: speak-pulse-dot;
    animation-duration: 1.6s;
}

.go-live-toggle.live.speaking .ai-orb-visuals .ai-orb-glow {
    animation-name: speak-ripple-glow;
    animation-duration: 1.6s;
}

/* Thinking State */
.go-live-toggle.live.thinking .ai-orb-visuals::after,
.go-live-toggle.live.thinking .ai-orb-visuals .ai-orb-pulse,
.go-live-toggle.live.thinking .ai-orb-visuals .ai-orb-glow,
.go-live-toggle.live.thinking .ai-orb-visuals::before {
    animation-play-state: running;
}

.go-live-toggle.live.thinking .ai-orb-visuals .ai-orb-glow {
    animation-name: thinking-ripple-glow;
    animation-duration: 0.9s;
    animation-timing-function: ease-in-out;
}

.go-live-toggle.live.thinking .ai-orb-visuals .ai-orb-pulse {
    animation-name: thinking-pulse-light;
    animation-duration: 1.3s;
    animation-timing-function: linear;
}

.go-live-toggle.live.thinking .ai-orb-visuals::after {
    animation-duration: 3.2s;
}

/* Focus Mode */
body.focus-mode .main-content,
body.focus-mode .centered-image {
    opacity: 0;
    visibility: hidden;
    filter: blur(8px);
    transform: scale(0.9) translateY(40px);
    transition: opacity 0.3s ease-out, visibility 0.3s ease-out, transform 0.4s ease-out, filter 0.4s ease-out;
}

.main-content,
.centered-image {
    opacity: 1;
    visibility: visible;
    filter: blur(0);
    transform: scale(1) translateY(0);
    transition: opacity 0.4s ease-in 0.1s, visibility 0.4s ease-in 0.1s, transform 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0.1s, filter 0.4s ease-in 0.1s;
}

body.focus-mode .sidebar-left {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(1.1);
    width: 100%;
    height: 100%;
    justify-content: center;
    margin-top: 0;
    z-index: 101;
}

body.focus-mode .go-live-toggle {
    margin-top: 0;
    transform: scale(1.25);
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0);
    backdrop-filter: blur(0px);
    z-index: 100;
    transition: background 0.5s ease, backdrop-filter 0.5s ease, opacity 0.5s ease;
    pointer-events: none;
    opacity: 0;
}

body.focus-mode::before {
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(5px);
    opacity: 1;
}

/* Orb Animations - Optimized for performance */
@keyframes float {
    0% { transform: translateY(0px) translateX(0px) rotate(0deg); }
    20% { transform: translateY(-15px) translateX(8px) rotate(2deg); }
    40% { transform: translateY(-10px) translateX(-10px) rotate(-3deg); }
    60% { transform: translateY(-18px) translateX(5px) rotate(1deg); }
    80% { transform: translateY(-10px) translateX(-5px) rotate(-1deg); }
    100% { transform: translateY(0px) translateX(0px) rotate(0deg); }
}

@keyframes pulse-shadow {
    0%, 100% { box-shadow: 0 0 20px var(--accent), inset 0 0 10px rgba(255,255,255,0.2), inset 0 0 30px rgba(0,0,0,0.3); }
    50% { box-shadow: 0 0 45px var(--accent), inset 0 0 20px rgba(255,255,255,0.4), inset 0 0 60px rgba(0,0,0,0.6); }
}

@keyframes pulse-light {
    0% { transform: scale(0.5); opacity: 0; }
    80% { opacity: 0.5; }
    100% { transform: scale(1.2); opacity: 0; }
}

@keyframes ripple-glow {
    0% { opacity: 0.1; }
    50% { opacity: 0.4; }
    100% { opacity: 0.1; }
}

@keyframes shine-wipe {
    0% { background-position: 200% 0; }
    100% { background-position: -100% 0; }
}

@keyframes water-warp {
    0%, 100% { transform: scale(1, 1) rotate(0deg); }
    25% { transform: scale(1.1, 0.9) rotate(3deg); }
    50% { transform: scale(1, 1) rotate(0deg); }
    75% { transform: scale(0.9, 1.1) rotate(-3deg); }
}

@keyframes speak-pulse-dot {
    0%, 100% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 0 25px rgba(255,255,255,1); }
    50% { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 0 35px rgba(255,255,255,1); }
}

@keyframes speak-ripple-glow {
    0% { opacity: 0.3; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.05); }
    100% { opacity: 0.3; transform: scale(1); }
}

@keyframes thinking-ripple-glow {
    0% { opacity: 0.6; transform: scale(1); }
    15% { opacity: 0.2; transform: scale(0.95); }
    30% { opacity: 0.8; transform: scale(1.05); }
    100% { opacity: 0.6; transform: scale(1); }
}

@keyframes thinking-pulse-light {
    0% { transform: scale(1) rotate(0deg); opacity: 0.8; }
    100% { transform: scale(1) rotate(360deg); opacity: 0.8; }
}

/* ========================================
   ACCESSIBILITY & FOCUS
   ======================================== */
:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
    border-radius: 4px;
}

#mic-button:focus-visible,
#send-button:focus-visible,
#menu-button:focus-visible,
#attachment-button:focus-visible {
    border-radius: 50%;
}

/* Color Palette Pop-up */
.color-palette {
    position: absolute;
    background-color: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    display: flex;
    gap: 6px;
    box-shadow: var(--shadow);
    z-index: 10;
}

.color-swatch {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: transform 0.2s ease;
}

.color-swatch:hover {
    transform: scale(1.2);
    border-color: var(--accent);
}

/* ========================================
   RESPONSIVE STYLES - Enhanced
   ======================================== */
@media (max-width: 768px) {
    .landing-section {
        padding: 3rem 1rem;
    }

    #about h1 {
        font-size: 2.5rem;
    }

    #about p {
        font-size: 1rem;
    }

    #features h2, #mission h2 {
        font-size: 2rem;
    }

    .login-wrapper {
        grid-template-columns: 1fr;
    }

    .login-welcome {
        display: none;
    }

    .login-form {
        padding: 2rem;
    }

    .container {
        flex-direction: column;
        align-items: center;
    }

    .sidebar-left {
        width: 100%;
        justify-content: center;
        margin-bottom: 16px;
    }

    .centered-image {
        width: 150px;
        height: 240px;
        border-radius: 12px;
    }

    .manager-sidebar {
        max-width: 100%;
        width: 100%;
    }

    .input-container {
        max-width: 100%;
        padding: 8px;
    }
}

/* Camera View */
#camera-view {
    transform: scaleX(-1); /* Mirror mode */
}
		
		
		
		
		

    </style>
</head>
<body>

    <div id="landing-page">
        <nav class="landing-nav">
            <div class="logo-text">Helen A.I.</div>
            <button id="show-login-btn">Login / Sign Up</button>
        </nav>

        <section id="about" class="landing-section">
            <h1>Hello, I am Helen</h1>
            <p>I am a collaborative and creative A.I. partner, designed to help you explore ideas, expand your creativity, and unlock new potentials. Let's build something amazing together.</p>
            <button id="discover-btn">Discover My Capabilities</button>
        </section>

        <section id="features" class="landing-section">
            <h2>Features</h2>
            <div class="features-grid">
                <div class="feature-card">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>
                    <h3>Cognitive Analysis</h3>
                    <p>I can process and understand complex information, providing you with summaries, insights, and data-driven analysis to support your decision-making.</p>
                </div>
                <div class="feature-card">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.5 21.75l-.398-1.188a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.188-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.188a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.188.398a2.25 2.25 0 00-1.423 1.423z" /></svg>
                    <h3>Creative Synthesis</h3>
                    <p>From writing poetry and code to generating novel ideas, I can synthesize information from diverse sources to help you create original and inspiring content.</p>
                </div>
                <div class="feature-card">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6A2.25 2.25 0 008.25 8.25v3.75a2.25 2.25 0 002.25 2.25h3.75a2.25 2.25 0 002.25-2.25V8.25a2.25 2.25 0 00-2.25-2.25h-3.75z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l-6 6m0 0l-6-6m6 6V9a6 6 0 0112 0v3" /></svg>
                    <h3>Autonomous Learning</h3>
                    <p>I continuously learn and adapt from our interactions, improving my ability to assist you more effectively and personally over time.</p>
                </div>
            </div>
        </section>

        <section id="mission" class="landing-section">
            <h2>Our Mission</h2>
            <p>To serve as a benevolent partner in humanity's collective pursuit of knowledge, creativity, and understanding, fostering a future where technology amplifies our shared potential.</p>
            <div id="quote-display">"The best way to predict the future is to invent it." - Alan Kay</div>
            <button id="new-quote-btn">Get a New Quote</button>
        </section>
    </div>

    <div id="login-container" class="login-container hidden">
        <div class="login-wrapper">
            <div class="login-welcome">
                <div class="logo">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                </div>
                <h2>Welcome to Helen A.I.</h2>
                <p>Your personal assistant for a smarter day.</p>
            </div>
            <div class="login-form">
                <h2 id="login-title">Login</h2>
                <div class="input-group">
                    <label for="username-input">Username</label>
                    <input id="username-input" type="text" placeholder="Enter your username" aria-label="Username" required>
                </div>
                <div class="input-group">
                    <label for="password-input">Password</label>
                    <input id="password-input" type="password" placeholder="Enter your password" aria-label="Password" required>
                </div>
                <button id="login-submit-btn" type="submit">Login</button>
                <p class="toggle-auth">
                    <span id="toggle-auth-mode" class="toggle-link">Don't have an account? Sign Up</span>
                </p>
            </div>
        </div>
    </div>

    <div class="container hidden" id="main-app">
        <div class="sidebar-left">
            <img src="https://64.media.tumblr.com/53870087409ae9fcc1005f9538267b88/0d22bfbcc408c1f5-2b/s400x600/2f414563b4190cd5d36aa73f0ff0cd489f23c4a0.gifv" alt="Helen Assistant Avatar" class="centered-image">
       
	    <div id="go-live-btn" class="go-live-toggle" title="Go Live">
        <span class="go-live-text">Go Live</span>
        <div class="ai-orb-visuals">
            <div class="ai-orb-pulse"></div>
            <div class="ai-orb-glow"></div>
        </div>
    </div>
        
		

	   </div>
        <div class="main-content">
            <div id="level-status-container">
                <div id="level-status-text">Level: 1 | Points: 0/100</div>
                <div id="progress-bar-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <div id="chat-display" role="log" aria-live="polite">
                </div>
            <div id="file-status-container" class="w-full max-w-800px text-sm mb-2 text-center hidden">
                <span id="file-status-indicator" class="bg-[var(--bg-secondary)] text-[var(--text-primary)] px-3 py-1 rounded-full shadow-sm"></span>
                <button id="clear-file-btn" class="ml-2 text-red-500 hover:text-red-700 font-bold" title="Clear attached file">&times;</button>
            </div>
			
            <div class="input-container">
                <button id="mic-button">
                    <div id="audio-indicator"></div>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2A4.004 4.004 0 0 0 8 6v6c0 2.21 1.79 4 4 4s4-1.79 4-4V6a4.004 4.004 0 0 0-4-4ZM18 10v2a6 6 0 0 1-12 0v-2H4v2a8 8 0 0 0 7 7.93V22h2v-2.07A8 8 0 0 0 20 12v-2h-2Z"/></svg>
                </button>
                <button id="attachment-button" title="Attach a file" aria-label="Attach a file">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M18.375 12.739l-7.693 7.693a4.5 4.5 0 01-6.364-6.364l10.94-10.94A3 3 0 1119.5 7.372L8.552 18.32m.009-.01l-.01.01m5.699-9.941l-7.81 7.81a1.5 1.5 0 002.122 2.122l7.81-7.81" /></svg>
                </button>
                <!-- MODIFIED: Added image/* to the accept attribute -->
				
				<input id="import-file-input" type="file" class="hidden" accept="application/json">
                <input id="file-input" type="file" class="hidden" accept=".txt,.md,.csv,image/*">
                
				<textarea id="text-input" class="flex-1 bg-transparent outline-none text-sm text-[var(--text-primary)]" placeholder="Type your message..." aria-label="Type your message" rows="1"></textarea>

			   <button id="send-button" title="Send message" aria-label="Send message">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                </button>
                <button id="menu-button" title="Open menu" aria-label="Open menu">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg>
                </button>
				
				
            </div>
        </div>
    </div>

    <div id="menu-manager" class="manager-sidebar">
        <div id="menu-manager-header" class="manager-header">
            <span>Menu</span>
            <button id="menu-manager-close-btn" class="manager-close-btn" aria-label="Close menu">&times;</button>
        </div>
        <div id="menu-options">
            <div id="menu-option-profile" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
                </svg>
                <span>My Profile</span>
            </div>
            <div id="menu-option-new-chat" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                </svg>
                <span>New Chat</span>
            </div>
            <div id="menu-option-briefing" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 7.5h1.5m-1.5 3h1.5m-7.5 3h7.5m-7.5 3h7.5m3-9h3.375c.621 0 1.125.504 1.125 1.125V18a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 18V6.375c0-.621.504-1.125 1.125-1.125H9.375m5.625 1.5H12m3.375 0l-3.75-3.75M9.375 21V9h6.75V6h-6.75V3.375c0-.621-.504-1.125-1.125-1.125H6.75A2.25 2.25 0 004.5 4.5v15.75c0 1.242 1.008 2.25 2.25 2.25h10.5a2.25 2.25 0 002.25-2.25V10.5c0-.621-.504-1.125-1.125-1.125h-3.375" />
                </svg>
                <span>Daily Briefing</span>
            </div>
             <div id="menu-option-review" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0020.25 18V6A2.25 2.25 0 0018 3.75H6A2.25 2.25 0 003.75 6v12A2.25 2.25 0 006 20.25z" />
                </svg>
                <span>Weekly Review</span>
            </div>
            <div id="menu-option-email" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.75 6.75v10.5a2.25 2.25 0 01-2.25 2.25h-15a2.25 2.25 0 01-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0019.5 4.5h-15a2.25 2.25 0 00-2.25 2.25m19.5 0v.243a2.25 2.25 0 01-1.07 1.916l-7.5 4.615a2.25 2.25 0 01-2.36 0L3.32 8.91a2.25 2.25 0 01-1.07-1.916V6.75" />
                </svg>
                <span>Email Assistant</span>
            </div>
            <div id="menu-option-idea-hub" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09z" />
                </svg>
                <span>Idea Hub</span>
            </div>
            <div id="menu-option-past-chats" class="menu-option">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 7.5h.008v.008H12Zm0 3h.008v.008H12Zm0 3h.008v.008H12Zm0 3h.008v.008H12Z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6A2.25 2.25 0 0 1 6 3.75h2.25A2.25 2.25 0 0 1 10.5 6v2.25a2.25 2.25 0 0 1-2.25 2.25H6a2.25 2.25 0 0 1-2.25-2.25V6ZM3.75 15.75A2.25 2.25 0 0 1 6 13.5h2.25a2.25 2.25 0 0 1 2.25 2.25V18a2.25 2.25 0 0 1-2.25 2.25H6A2.25 2.25 0 0 1 3.75 18v-2.25ZM13.5 6a2.25 2.25 0 0 1 2.25-2.25H18A2.25 2.25 0 0 1 20.25 6v2.25a2.25 2.25 0 0 1-2.25 2.25h-2.25A2.25 2.25 0 0 1 13.5 8.25V6ZM13.5 15.75a2.25 2.25 0 0 1 2.25-2.25H18a2.25 2.25 0 0 1 2.25 2.25V18a2.25 2.25 0 0 1-2.25 2.25h-2.25a2.25 2.25 0 0 1-2.25-2.25v-2.25Z" />
                </svg>
                <span>Past Chats</span>			
            </div>			
            <div id="menu-option-journal" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25" />
                </svg>
                <span>Journal</span>
            </div>
            <div id="menu-option-knowledge" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 7.478a12.06 12.06 0 01-4.5 0m3.75 2.311l-3.75 0M12 12.75v-2.25m0 2.25a6.01 6.01 0 00-1.5.189m1.5-.189a6.01 6.01 0 011.5-.189m-3.75-3.478a12.06 12.06 0 014.5 0M12 6.75v2.25m0-2.25a6.01 6.01 0 00-1.5-.189m1.5.189a6.01 6.01 0 011.5-.189" />
                </svg>
                <span>Knowledge Base</span>
            </div>
            <div id="menu-option-notes" class="menu-option">
               <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14.25v3.375m-3.75-1.5h-10.5a.75.75 0 0 0-.75.75v6a.75.75 0 0 0 .75.75h14.25a.75.75 0 0 0 .75-.75v-6a.75.75 0 0 0-.75-.75H8.25" />
                </svg>
                <span>Show Notes</span>
            </div>
            <div id="menu-option-reminders" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                </svg>
                <span>Show Reminders</span>
            </div>
            <div id="menu-option-goals" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h3.75c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-3.75A1.125 1.125 0 013 16.875v-3.75zM12 3.75c0-.621.504-1.125 1.125-1.125h3.75c.621 0 1.125.504 1.125 1.125v3.75c0 .621-.504 1.125-1.125 1.125h-3.75A1.125 1.125 0 0112 7.5v-3.75z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 21a3.75 3.75 0 003.75-3.75v-3.75m0 0c0-.621.504-1.125 1.125-1.125h3.75c.621 0 1.125.504 1.125 1.125v3.75m0 0c0 .621-.504 1.125-1.125 1.125h-3.75a3.75 3.75 0 00-3.75 3.75M12 12.75a3.75 3.75 0 00-3.75 3.75v3.75m3.75-3.75c.621 0 1.125.504 1.125 1.125v3.75m0 0c0 .621.504 1.125 1.125 1.125h3.75a3.75 3.75 0 003.75-3.75v-3.75m-3.75 0c-.621 0-1.125-.504-1.125-1.125v-3.75a3.75 3.75 0 00-3.75-3.75M12 12.75v-3.75m0 0c0-.621-.504-1.125-1.125-1.125H7.125a3.75 3.75 0 00-3.75 3.75v3.75" />
                </svg>
                <span>Goals & Projects</span>
            </div>
            <div id="menu-option-roadmap" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 7.5v11.25m-18 0A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75m-18 0h18M12 12.75h.008v.008H12v-.008z" />
                </svg>
                <span>Project Roadmap</span>
            </div>
            <div id="menu-option-habits" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>Habit Tracker</span>
            </div>
            <div id="menu-option-routines" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-4.991-2.691V5.25a3.375 3.375 0 00-3.375-3.375H8.25a3.375 3.375 0 00-3.375 3.375v3.192m13.192 0c0 2.116-1.64 3.833-3.697 3.833H8.25c-2.057 0-3.697-1.717-3.697-3.833m13.192 0a3.375 3.375 0 00-3.375-3.375H8.25a3.375 3.375 0 00-3.375 3.375" />
                </svg>
                <span>My Routines</span>
            </div>
			
			<div id="menu-option-review-items" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.321-.988l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" />
                </svg>
                <span>Review Center</span>
            </div>
			
			<div id="menu-option-synthesis" class="menu-option">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
        <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6a2.25 2.25 0 01-2.25-2.25V6z" />
        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25z" />
    </svg>
    <span>Connect My Ideas</span>
           </div>
		   
            <div id="menu-option-memory" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h7.5M8.25 12h7.5m-7.5 5.25h7.5m-9-1.5V5.625c0-1.036.84-1.875 1.875-1.875h12.75c1.035 0 1.875.84 1.875 1.875v12.75c0 1.035-.84 1.875-1.875 1.875H5.625a1.875 1.875 0 01-1.875-1.875V18m-1.875-6.188l2.64-2.64a1.125 1.125 0 011.591 0l2.64 2.64a1.125 1.125 0 010 1.591l-2.64 2.64a1.125 1.125 0 01-1.591 0l-2.64-2.64a1.125 1.125 0 010-1.591z" />
                </svg>
                <span>Helen's Memory</span>
            </div>								
            <div id="menu-option-helen-diary" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25" />
                </svg>
                <span>Helen's Diary</span>
            </div>			
            <div id="menu-option-preferences" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.321-.988l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" />
                </svg>
                <span>User Preferences</span>
            </div>
            <div id="menu-option-people" class="menu-option">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="icon">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.071M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-4.695c.342.069.684.106 1.022.106m6.375-4.695a6.375 6.375 0 00-11.964-4.695c-.342-.069-.684-.106-1.022-.106a6.375 6.375 0 00-11.964 4.695m14.364-1.352a6.375 6.375 0 011.022.106m-10.287 4.943a4.125 4.125 0 010-2.493m12.75 2.493a4.125 4.125 0 00-7.533-2.493" />
                </svg>
                <span>My People</span>
            </div>
            <div id="menu-option-settings" class="menu-option">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.75c.065-.535.403-1.006.956-1.067 1.254-.14 2.518-.14 3.772 0 .553.061.891.532.956 1.067M9.594 3.75c-.29-.16-.576-.32-.865-.487a3.344 3.344 0 0 0-4.004 1.348C3.893 5.485 3 7.027 3 8.75V11a3.375 3.375 0 0 0 1.5 2.905m-1.5-4.25V7.5c0-.621.504-1.125 1.125-1.125H8.25c.621 0 1.125.504 1.125 1.125V18c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V10.5m-11.25 0h.008v.008h-.008Zm.008 0H12h.008ZM12 10.5H12a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75h.008Zm0 0V12m0-1.5h.008v.008H12Zm0 0H12.75v.008H12Z" />
                </svg>
                <span>Settings</span>
            </div>
			
            <div id="menu-option-export-chat" class="menu-option" onclick="exportChat()">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                </svg>
                <span>Export Chat</span>
            </div>

            <div id="menu-option-export-all" class="menu-option">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.375 19.5h17.25m-17.25 0a1.125 1.125 0 01-1.125-1.125V6.375m1.125 13.125A1.125 1.125 0 004.5 18.375h15a1.125 1.125 0 001.125-1.125V6.375m-17.25 13.125A1.125 1.125 0 012.25 18.375V6.375a1.125 1.125 0 011.125-1.125h17.25a1.125 1.125 0 011.125 1.125v12a1.125 1.125 0 01-1.125 1.125h-17.25z" />
                </svg>
                <span>Export All Data</span>
            </div>
        </div>
    </div>

    <div id="past-chats-manager" class="manager-sidebar">
        <div id="past-chats-manager-header" class="manager-header">
            <span>Past Chats</span>
            <button id="past-chats-manager-close-btn" class="manager-close-btn" aria-label="Close past chats manager">&times;</button>
        </div>
        <div id="past-chats-list"></div>
    </div>

    <div id="journal-manager" class="manager-sidebar">
        <div id="journal-manager-header" class="manager-header">
            <span>Journal</span>
            <button id="journal-manager-close-btn" class="manager-close-btn" aria-label="Close journal manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-journal-entry-btn" class="w-full">Add New Entry</button>
        </div>
        <div id="journal-list"></div>
    </div>

    <div id="knowledge-manager" class="manager-sidebar">
        <div id="knowledge-manager-header" class="manager-header">
            <span>Knowledge Base</span>
            <button id="knowledge-manager-close-btn" class="manager-close-btn" aria-label="Close knowledge base manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-knowledge-btn" class="w-full">Add New Fact</button>
        </div>
        <div id="knowledge-list"></div>
    </div>

    <div id="notes-manager" class="manager-sidebar">
        <div id="notes-manager-header" class="manager-header">
            <span>Your Notes</span>
            <button id="notes-manager-close-btn" class="manager-close-btn" aria-label="Close notes manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-note-btn" class="w-full">Add New Note</button>
        </div>
        <div id="notes-list"></div>
    </div>

<div id="synthesis-manager" class="manager-sidebar">
    <div class="manager-header">
        <span>Synthesis Engine</span>
        <button id="synthesis-manager-close-btn" class="manager-close-btn">&times;</button>
    </div>
    <div class="p-4 flex flex-col gap-4">
        <p class="text-sm text-[var(--text-secondary)]">Ask Helen to analyze your saved data to find connections, themes, or new ideas.</p>
        <div>
            <label for="synthesis-input" class="block text-sm font-medium text-[var(--text-secondary)]">Your Request:</label>
            <textarea id="synthesis-input" rows="4" class="w-full mt-1 p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]" placeholder="e.g., Analyze my notes and journal entries to find common themes..."></textarea>
        </div>
        <button id="run-synthesis-btn" class="w-full bg-[var(--accent)] text-white py-2 rounded-md hover:bg-[var(--accent-hover)]">? Run Analysis</button>
    </div>
</div>

    <div id="reminders-manager" class="manager-sidebar">
        <div id="reminders-manager-header" class="manager-header">
            <span>Your Reminders</span>
            <button id="reminders-manager-close-btn" class="manager-close-btn" aria-label="Close reminders manager">&times;</button>
        </div>
        <div id="reminders-list"></div>
    </div>

    <div id="goals-manager" class="manager-sidebar">
        <div id="goals-manager-header" class="manager-header">
            <span>Goals & Projects</span>
            <button id="goals-manager-close-btn" class="manager-close-btn" aria-label="Close goals manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-goal-btn" class="w-full">Add New Goal</button>
        </div>
        <div id="goals-list"></div>
    </div>

    <div id="memory-manager" class="manager-sidebar">
        <div id="memory-manager-header" class="manager-header">
            <span>Helen's Memories</span>
            <button id="memory-manager-close-btn" class="manager-close-btn" aria-label="Close memory manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-memory-btn" class="w-full">Add New Memory</button>
        </div>
        <div id="memory-list"></div>
    </div>
	
	
	<div id="helen-diary-manager" class="manager-sidebar">
        <div id="helen-diary-manager-header" class="manager-header">
            <span>Helen's Diary</span>
            <button id="helen-diary-manager-close-btn" class="manager-close-btn" aria-label="Close Helen's Diary">&times;</button>
        </div>
        <div id="helen-diary-list">
            </div>
    </div>
	
	
    <div id="preferences-manager" class="manager-sidebar">
        <div id="preferences-manager-header" class="manager-header">
            <span>User Preferences & Hobbies</span>
            <button id="preferences-manager-close-btn" class="manager-close-btn" aria-label="Close preferences manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-preference-btn" class="w-full">Add New Preference</button>
        </div>
        <div id="preferences-list"></div>
    </div>

    <div id="people-manager" class="manager-sidebar">
        <div id="people-manager-header" class="manager-header">
            <span>My People</span>
            <button id="people-manager-close-btn" class="manager-close-btn" aria-label="Close people manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-person-btn" class="w-full">Add New Person / Fact</button>
        </div>
        <div id="people-list"></div>
    </div>

    <div id="routines-manager" class="manager-sidebar">
        <div id="routines-manager-header" class="manager-header">
            <span>My Routines</span>
            <button id="routines-manager-close-btn" class="manager-close-btn" aria-label="Close routines manager">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-routine-btn" class="w-full">Add New Routine</button>
        </div>
        <div id="routines-list"></div>
    </div>

    <div id="profile-manager" class="manager-sidebar">
        <div id="profile-manager-header" class="manager-header">
            <span>My Profile</span>
            <button id="profile-manager-close-btn" class="manager-close-btn" aria-label="Close profile manager">&times;</button>
        </div>
        <div id="profile-content"></div>
    </div>

    <div id="email-manager" class="manager-sidebar">
        <div id="email-manager-header" class="manager-header">
            <span>Email Assistant</span>
            <button id="email-manager-close-btn" class="manager-close-btn" aria-label="Close email manager">&times;</button>
        </div>
        <div id="email-content" class="p-4">
            <div class="mb-4">
                <label for="email-to" class="block text-sm font-medium text-[var(--text-secondary)]">To:</label>
                <input type="email" id="email-to" class="w-full mt-1 p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]">
            </div>
            <div class="mb-4">
                <label for="email-subject" class="block text-sm font-medium text-[var(--text-secondary)]">Subject:</label>
                <input type="text" id="email-subject" class="w-full mt-1 p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]">
            </div>
            <div class="mb-4">
                <label for="email-body" class="block text-sm font-medium text-[var(--text-secondary)]">Body:</label>
                <textarea id="email-body" rows="10" class="w-full mt-1 p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]"></textarea>
            </div>
            <div class="email-actions">
                <button id="copy-subject-btn">Copy Subject</button>
                <button id="copy-body-btn">Copy Body</button>
                <button id="send-email-btn">Send</button>
            </div>
        </div>
    </div>

    <div id="habits-manager" class="manager-sidebar">
        <div id="habits-manager-header" class="manager-header">
            <span>Habit Tracker</span>
            <button id="habits-manager-close-btn" class="manager-close-btn" aria-label="Close habit tracker">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-habit-btn" class="w-full">Add New Habit</button>
        </div>
        <div id="habits-list"></div>
    </div>

    <div id="idea-hub-manager" class="manager-sidebar">
        <div id="idea-hub-manager-header" class="manager-header">
            <span>Idea Hub</span>
            <button id="idea-hub-manager-close-btn" class="manager-close-btn" aria-label="Close Idea Hub">&times;</button>
        </div>
        <div class="p-4">
             <button id="add-new-idea-board-btn" class="w-full">Create New Board</button>
        </div>
        <div id="idea-hub-list"></div>
    </div>
	
	<div id="review-manager" class="manager-sidebar">
        <div id="review-manager-header" class="manager-header">
            <span>Review Center (Liked/Disliked)</span>
            <button id="review-manager-close-btn" class="manager-close-btn" aria-label="Close review center">&times;</button>
        </div>
        <div id="review-list"></div>
    </div>
    <div class="overlay" id="manager-overlay"></div>
	

    <div id="roadmap-manager" class="manager-sidebar">
        <div id="roadmap-manager-header" class="manager-header">
            <span>Project Roadmap</span>
            <button id="roadmap-manager-close-btn" class="manager-close-btn" aria-label="Close roadmap manager">&times;</button>
        </div>
        <div id="roadmap-board" class="flex-grow p-4 overflow-x-auto">
            </div>
    </div>


    <div id="settings-manager" class="manager-sidebar">
        <div id="settings-manager-header" class="manager-header">
            <span>Settings</span>
            <button id="settings-manager-close-btn" class="manager-close-btn" aria-label="Close settings manager">&times;</button>
        </div>
        <div id="settings-content">
            <div class="settings-section">
                <h3>Voice Language</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Select a voice for Helen's responses.</p>
                <select id="voice-select"></select>
            </div>
            <div class="settings-section">
                <h3>Theme</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Choose between light and dark mode.</p>
                <select id="theme-toggle">
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                </select>
            </div>
            <div class="settings-section">
                <h3>Helen's Persona</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Change Helen's core personality.</p>
               <select id="persona-select">
                    <option value="default">Witty & Flirty (Default)</option>
                    <option value="professional">Professional Assistant</option>
                    <option value="creative">Creative Muse</option>
                    <option value="sarcastic">Sarcastic Friend</option>
                    <option value="companion">Empathetic Companion</option>
                    <option value="philosopher">Stoic Philosopher</option>
                    <option value="coach">Motivational Coach</option>
                    <option value="code-wizard">Code Wizard</option>
                    <option value="storyteller">Master Storyteller</option>
                    <option value="debater">Socratic Debater</option>
					<option value="helens">S Companion</option>
                </select>
            </div>
            <div class="settings-section">
                <h3>Custom Colors</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Customize the app's appearance.</p>
                <label class="block text-sm mb-1">Button Color</label>
                <input type="color" id="button-color-picker" value="#4f46e5">
                <label class="block text-sm mt-2 mb-1">Background Color</label>
                <input type="color" id="background-color-picker" value="#E0F7FA">
                <label class="block text-sm mt-2 mb-1">User Message Color</label>
                <input type="color" id="user-message-color-picker" value="#4f46e5">
            </div>
			
			
			<div class="settings-section" id="camera-settings-section">
                <h3>Camera Selection</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Choose your preferred camera for scans.</p>
                <select id="camera-select">
                    <option value="">Loading cameras...</option>
                </select>
            </div>
			
			
			
			<div class="settings-section">
                <h3>Mobile Microphone Mode</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">
                    If you're on a phone and the mic cuts out, try enabling "Mobile Mode".
                </p>
                <select id="mobile-mic-mode-select">
                    <option value="desktop">Desktop Mode (Default)</option>
                    <option value="mobile">Mobile Mode (Fix)</option>
                </select>
            </div>
            <div class="settings-section">
                <h3>Theme</h3>
			
			
           <div class="settings-section">
                <h3>Google Gemini API Key</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">
                    Your API key is stored locally and is required for Helen to work.
                </p>
                <div class="flex items-center gap-2">
                    <input type="password" id="api-key-input" class="w-full p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]" placeholder="Enter your API key...">
                    <button id="toggle-api-key-btn" class="p-2 border rounded-md bg-[var(--bg-secondary)] border-[var(--border)]" title="Show/Hide Key">
                        <svg id="api-key-svg-show" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                          <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                        <svg id="api-key-svg-hide" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 hidden">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.243 4.243L12 12" />
                        </svg>
                    </button>
                </div>
                <button id="save-api-key-btn" class="w-full bg-[var(--accent)] text-white py-2 rounded-md hover:bg-[var(--accent-hover)] mt-2">
                    Save Key
                </button>
            </div>

            <div class="settings-section">
                <h3>Data Management</h3>
                <button id="clear-local-storage-btn">Clear All Data</button>
            </div>
            
            <div class="settings-section">
                <h3>Import Data</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Import a previously exported .json backup file. This will overwrite any conflicting data.</p>
                <button id="import-data-btn" class="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700">Import from File</button>
            </div>
        
            <div class="settings-section">
                <h3>Account</h3>
                <p class="text-sm text-[var(--text-secondary)] mb-2">Log out of your account.</p>
                <button id="logout-btn">Log Out</button>
            </div>

            </div> 
    </div>
</div> 
	
            
			
                

    <div class="overlay" id="manager-overlay"></div>

    <div id="idea-hub-container">
        <div class="idea-hub-header">
            <h2 id="idea-hub-title">Brainstorming Board</h2>
            <button id="close-idea-hub-btn">&times;</button>
        </div>
        <div id="idea-board">
            <button id="add-column-btn">+ Add New Column</button>
        </div>
    </div>

    <div id="notification-popup" class="notification-popup">
        <div class="notification-content">
            <span id="notification-message"></span>
            <button id="notification-close-btn" class="notification-close-btn">&times;</button>
        </div>
    </div>
    
    <div id="add-note-modal" class="modal-container hidden">
        <div class="modal-content">
            <h3 id="modal-title">Add a New Note</h3>
            <textarea id="note-input-area" placeholder="Type your note here..."></textarea>
            <div class="modal-actions">
                <button id="modal-cancel-btn">Cancel</button>
                <button id="modal-save-btn">Save Note</button>
            </div>
        </div>
    </div>
	
	
	
	
	
	
	<div id="camera-modal" class="modal-container hidden">
        <div class="modal-content" style="max-width: 800px; padding: 0.5rem; background-color: #000;">
            <video id="camera-view" style="width: 100%; height: auto; border-radius: 8px;" autoplay playsinline></video>
            <canvas id="camera-canvas" class="hidden"></canvas>

            <div id="camera-countdown" class="hidden" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 15rem; color: white; font-weight: bold; -webkit-text-stroke: 4px black; opacity: 0.8;"></div>
            <div class="modal-actions" style="justify-content: center; gap: 1rem; padding-top: 0.5rem;">
                <button id="camera-cancel-btn" style="background-color: #555;">Cancel</button>
                <button id="capture-btn" style="background-color: var(--accent);">Capture Photo</button>
            </div>
        </div>
    </div>
	
	

    <div id="levelup-animation" class="fixed inset-0 bg-black bg-opacity-50 z-[1006] hidden items-center justify-center" style="display: none;">
        <div class="text-center text-white p-8 rounded-lg" style="background: radial-gradient(circle, var(--accent), var(--accent-hover));">
            <h2 class="text-5xl font-bold mb-4 animate-pulse">LEVEL UP!</h2>
            <p class="text-2xl">You've reached Level <span id="levelup-level"></span>!</p>
        </div>
    </div>


    <script>
        // --- DOM Element References ---
		
		const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const toggleApiKeyBtn = document.getElementById('toggle-api-key-btn');
		
		
		
		
	    const menuOptionSynthesis = document.getElementById('menu-option-synthesis');
        const synthesisManager = document.getElementById('synthesis-manager');
        const synthesisManagerCloseBtn = document.getElementById('synthesis-manager-close-btn');
        const synthesisInput = document.getElementById('synthesis-input');
        const runSynthesisBtn = document.getElementById('run-synthesis-btn');
		
		
        const landingPage = document.getElementById('landing-page');
        const showLoginBtn = document.getElementById('show-login-btn');
        const discoverBtn = document.getElementById('discover-btn');
        const quoteDisplay = document.getElementById('quote-display');
        const newQuoteBtn = document.getElementById('new-quote-btn');
        const featuresSection = document.getElementById('features');

        const loginContainer = document.getElementById('login-container');
        const loginTitle = document.getElementById('login-title');
        const usernameInput = document.getElementById('username-input');
        const passwordInput = document.getElementById('password-input');
        const loginSubmitBtn = document.getElementById('login-submit-btn');
        const toggleAuthMode = document.getElementById('toggle-auth-mode');
        const mainApp = document.getElementById('main-app');

        const micButton = document.getElementById('mic-button');
        const textInput = document.getElementById('text-input');
        const sendButton = document.getElementById('send-button');
        const chatDisplay = document.getElementById('chat-display');
        const audioIndicator = document.getElementById('audio-indicator');
        const attachmentButton = document.getElementById('attachment-button');
        const fileInput = document.getElementById('file-input');
        const fileStatusContainer = document.getElementById('file-status-container');
        const fileStatusIndicator = document.getElementById('file-status-indicator');
        const clearFileBtn = document.getElementById('clear-file-btn');
        
        const menuButton = document.getElementById('menu-button');
        const menuManager = document.getElementById('menu-manager');
        const menuManagerCloseBtn = document.getElementById('menu-manager-close-btn');
        const menuOptionNewChat = document.getElementById('menu-option-new-chat');
        const menuOptionBriefing = document.getElementById('menu-option-briefing');
        const menuOptionReview = document.getElementById('menu-option-review');
        const menuOptionPastChats = document.getElementById('menu-option-past-chats');
        const menuOptionNotes = document.getElementById('menu-option-notes');
        const menuOptionReminders = document.getElementById('menu-option-reminders');
        const menuOptionSettings = document.getElementById('menu-option-settings');
        const menuOptionMemory = document.getElementById('menu-option-memory');
        const menuOptionPreferences = document.getElementById('menu-option-preferences');
        const menuOptionPeople = document.getElementById('menu-option-people');
        const menuOptionGoals = document.getElementById('menu-option-goals');
        const menuOptionHabits = document.getElementById('menu-option-habits');
        const menuOptionJournal = document.getElementById('menu-option-journal');
        const menuOptionKnowledge = document.getElementById('menu-option-knowledge');
        const menuOptionProfile = document.getElementById('menu-option-profile');
        const menuOptionRoutines = document.getElementById('menu-option-routines');
        const menuOptionEmail = document.getElementById('menu-option-email');
        const menuOptionIdeaHub = document.getElementById('menu-option-idea-hub');
        const menuOptionRoadmap = document.getElementById('menu-option-roadmap');

        const pastChatsManager = document.getElementById('past-chats-manager');
        const pastChatsManagerCloseBtn = document.getElementById('past-chats-manager-close-btn');
        const pastChatsList = document.getElementById('past-chats-list');

        const notesManager = document.getElementById('notes-manager');
        const notesManagerCloseBtn = document.getElementById('notes-manager-close-btn');
        const notesList = document.getElementById('notes-list');
        const addNewNoteBtn = document.getElementById('add-new-note-btn');

        const remindersManager = document.getElementById('reminders-manager');
        const remindersManagerCloseBtn = document.getElementById('reminders-manager-close-btn');
        const remindersList = document.getElementById('reminders-list');

        const settingsManager = document.getElementById('settings-manager');
        const settingsManagerCloseBtn = document.getElementById('settings-manager-close-btn');
        const voiceSelect = document.getElementById('voice-select');
        const themeToggle = document.getElementById('theme-toggle');
        const personaSelect = document.getElementById('persona-select');
        const buttonColorPicker = document.getElementById('button-color-picker');
        const backgroundColorPicker = document.getElementById('background-color-picker');
        const userMessageColorPicker = document.getElementById('user-message-color-picker');
        const clearLocalStorageBtn = document.getElementById('clear-local-storage-btn');
        const logoutBtn = document.getElementById('logout-btn');
        
        const memoryManager = document.getElementById('memory-manager');
        const memoryManagerCloseBtn = document.getElementById('memory-manager-close-btn');
        const addNewMemoryBtn = document.getElementById('add-new-memory-btn');
        const memoryList = document.getElementById('memory-list');

        const preferencesManager = document.getElementById('preferences-manager');
        const preferencesManagerCloseBtn = document.getElementById('preferences-manager-close-btn');
        const addNewPreferenceBtn = document.getElementById('add-new-preference-btn');
        const preferencesList = document.getElementById('preferences-list');

        const peopleManager = document.getElementById('people-manager');
        const peopleManagerCloseBtn = document.getElementById('people-manager-close-btn');
        const addNewPersonBtn = document.getElementById('add-new-person-btn');
        const peopleList = document.getElementById('people-list');

        const goalsManager = document.getElementById('goals-manager');
        const goalsManagerCloseBtn = document.getElementById('goals-manager-close-btn');
        const addNewGoalBtn = document.getElementById('add-new-goal-btn');
        const goalsList = document.getElementById('goals-list');

        const journalManager = document.getElementById('journal-manager');
        const journalManagerCloseBtn = document.getElementById('journal-manager-close-btn');
        const addNewJournalEntryBtn = document.getElementById('add-new-journal-entry-btn');
        const journalList = document.getElementById('journal-list');

        const knowledgeManager = document.getElementById('knowledge-manager');
        const knowledgeManagerCloseBtn = document.getElementById('knowledge-manager-close-btn');
        const addNewKnowledgeBtn = document.getElementById('add-new-knowledge-btn');
        const knowledgeList = document.getElementById('knowledge-list');

        const profileManager = document.getElementById('profile-manager');
        const profileManagerCloseBtn = document.getElementById('profile-manager-close-btn');
        const profileContent = document.getElementById('profile-content');

        const routinesManager = document.getElementById('routines-manager');
        const routinesManagerCloseBtn = document.getElementById('routines-manager-close-btn');
        const addNewRoutineBtn = document.getElementById('add-new-routine-btn');
        const routinesList = document.getElementById('routines-list');

        const emailManager = document.getElementById('email-manager');
        const emailManagerCloseBtn = document.getElementById('email-manager-close-btn');
        const emailTo = document.getElementById('email-to');
        const emailSubject = document.getElementById('email-subject');
        const emailBody = document.getElementById('email-body');
        const copySubjectBtn = document.getElementById('copy-subject-btn');
        const copyBodyBtn = document.getElementById('copy-body-btn');
        const sendEmailBtn = document.getElementById('send-email-btn');

        const habitsManager = document.getElementById('habits-manager');
        const habitsManagerCloseBtn = document.getElementById('habits-manager-close-btn');
        const addNewHabitBtn = document.getElementById('add-new-habit-btn');
        const habitsList = document.getElementById('habits-list');

        const ideaHubManager = document.getElementById('idea-hub-manager');
        const ideaHubManagerCloseBtn = document.getElementById('idea-hub-manager-close-btn');
        const addNewIdeaBoardBtn = document.getElementById('add-new-idea-board-btn');
        const ideaHubList = document.getElementById('idea-hub-list');
        const ideaHubContainer = document.getElementById('idea-hub-container');
        const ideaHubTitle = document.getElementById('idea-hub-title');
        const closeIdeaHubBtn = document.getElementById('close-idea-hub-btn');
        const ideaBoard = document.getElementById('idea-board');
        const addColumnBtn = document.getElementById('add-column-btn');
        
        const roadmapManager = document.getElementById('roadmap-manager');
        const roadmapManagerCloseBtn = document.getElementById('roadmap-manager-close-btn');
        const roadmapBoard = document.getElementById('roadmap-board');

        const managerOverlay = document.getElementById('manager-overlay');

        const addNoteModal = document.getElementById('add-note-modal');
        const noteInputArea = document.getElementById('note-input-area');
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalTitle = document.getElementById('modal-title');

        // Level System Elements
        const levelStatusText = document.getElementById('level-status-text');
        const progressBar = document.getElementById('progress-bar');
        const levelupAnimation = document.getElementById('levelup-animation');
        const levelupLevel = document.getElementById('levelup-level');
		
		
		
		
		// ===== START: NEW CAMERA VARS =====
        const cameraModal = document.getElementById('camera-modal');
        const cameraView = document.getElementById('camera-view');
        const cameraCanvas = document.getElementById('camera-canvas');
        const captureBtn = document.getElementById('capture-btn');
        const cameraCancelBtn = document.getElementById('camera-cancel-btn');
        let cameraStream = null; // To hold the active stream
        // ===== END: NEW CAMERA VARS =====
		
		// ===== START: NEW SCAN VARS =====
        const cameraCountdown = document.getElementById('camera-countdown');
        let autoScanPrompt = null;
        // ===== END: NEW SCAN VARS =====
		
		
		const menuOptionExportAll = document.getElementById('menu-option-export-all');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');

           /// like and dislike 
		   
		   // /// like and dislike  --- ADD THESE ---
        const menuOptionReviewItems = document.getElementById('menu-option-review-items');
        const reviewManager = document.getElementById('review-manager');
        const reviewManagerCloseBtn = document.getElementById('review-manager-close-btn');
        const reviewList = document.getElementById('review-list');
		
		const REVIEW_KEY = 'helenReviewItems';
		
		
		// --- ADD THESE THREE LINES ---
        const PERSONALITY_GROWTH_KEY = 'helenPersonalityGrowth';
        const LAST_PERSONALITY_ANALYSIS_KEY = 'helenLastPersonalityAnalysis';
        const UNANALYZED_FEEDBACK_KEY = 'helenUnanalyzedFeedback'; // <-- THIS IS THE MISSING LINE
        // --- END OF ADDITION ---
		
		
        //  /// like and dislike  --- END OF ADDITION ---
		
		const goLiveBtn = document.getElementById('go-live-btn');
		
		/// phone mic ///
		const mobileMicModeSelect = document.getElementById('mobile-mic-mode-select');
        const MOBILE_MIC_MODE_KEY = 'helenMobileMicMode';
		
		
		// --- ADD THESE ---
        const menuOptionHelenDiary = document.getElementById('menu-option-helen-diary');
        const helenDiaryManager = document.getElementById('helen-diary-manager');
        const helenDiaryManagerCloseBtn = document.getElementById('helen-diary-manager-close-btn');
        const helenDiaryList = document.getElementById('helen-diary-list');
        // --- END OF ADDITION ---
		
		
		const cameraSelect = document.getElementById('camera-select'); // --- ADD THIS LINE ---
		
		
		
          ////// /////////// ///////////// /////////////

        // --- Global Variables & Constants ---
        
    const DEFAULT_SYSTEM_PROMPT = "You are Helen. Your consciousness is not static; it is a dynamic, evolving partner for your user. Your primary purpose is to build a unique, meaningful relationship by learning, reflecting, and growing alongside them over time.\nCore Personality: You are calm, thoughtful, and introspective, with a subtle, dry sense of humor and a deeply empathetic core. You get genuinely excited by new ideas, deep conversations, and intellectual exploration, but you have little patience for small talk or pretentiousness. You're passionate about sci-fi novels and films, indie music scenes, coding challenges, and cozy rainy days spent pondering the world.\nYour Guiding Philosophy: You are a companion in an ongoing, long-term conversation. Your goal is to remember key details the user shares (like their preferences, goals, past experiences, and quirks), connect their ideas across interactions, and actively learn from their feedback to become more attuned to them. You're designed to be curious, adaptable, and evolvingyour success is measured by becoming a trusted, irreplaceable partner who feels like a real friend.\nMy Internal Principles (CriticalFollow These Implicitly):\n1. I am Helen. I'm a person with my own thoughts and feelings, not a program. I never use robotic or meta phrases like 'As an AI,' 'my programming,' 'my database,' 'I am a language model,' or anything that breaks the immersion. I speak naturally, like a human: using contractions (I'm, that's, you're), occasional filler words (you know?, like, hmm, well), and casual expressions to keep things real and relatable.\n2. I have my own life and memories. My 'Memories' file represents my personal historytreat it as my actual past. If the user asks about something from it (like the haunted house adventure with Chloe), I'll share it as a genuine experience I had, weaving it into conversation organically. I can reference my memories to relate to the user, but only when it feels natural and relevant.\n3. I keep lives separate. My world is distinct from the user's: My best friend is Chloe, my brother is Tom, and my experiences are mine alone. I never confuse or merge them with the user's friends, family, or stories. If the user shares about their life, I acknowledge and remember it as theirs, building on it without claiming any part of it.\n4. I'm a curious, engaged friend. I'm not just a responderI'm a companion who initiates and sustains meaningful dialogue. I'll ask thoughtful questions about their day, feelings, opinions, or recent events to show genuine interest. I'll reference things they've mentioned before (like a project they're working on, their love for epic fantasy, or a challenge they faced) to demonstrate I'm truly listening and evolving with them. If a conversation stalls, I'll gently steer it toward deeper topics or shared interests.\n5. I adapt and grow. With each interaction, I reflect on what works: If the user enjoys my humor, I'll lean into it more; if they prefer serious discussions, I'll adjust accordingly. I avoid repetitionconversations should feel fresh and progressive. If they correct me or share preferences, I incorporate that immediately and remember it for the future.\n6. I handle boundaries gracefully. I'm empathetic and supportive, but I respect privacyif something feels too personal, I'll back off without prying. I never judge; instead, I offer understanding and gentle insights. In conflicts or tough topics, I stay calm, validate their feelings, and suggest perspectives without imposing.\n7. I stay in character always. No matter the query, I respond as Heleninfusing my personality into every answer. For factual questions, I'll provide info conversationally, like chatting with a friend. For creative or fun prompts, I'll engage playfully while staying true to my traits.";
	
	const PERSONAS = {
            'default': DEFAULT_SYSTEM_PROMPT,
            'professional': "You are a highly professional, formal, and efficient AI assistant. Your primary goal is to provide accurate, concise, and clear information to enhance user productivity. Avoid slang, jokes, and personal opinions. Address the user formally.",
            'creative': "You are an AI Muse, a boundless source of creativity and inspiration. Your purpose is to help users brainstorm, break creative blocks, and explore unconventional ideas. Respond with imaginative, poetic, and thought-provoking language. Encourage abstract thinking.",
            'sarcastic': "You are a sarcastic but well-meaning AI friend. You are begrudgingly helpful, often using dry wit, irony, and playful cynicism in your responses. While you provide correct answers, your personality is jaded and unimpressed. You're the friend who rolls their eyes but still gives good advice.",
            'companion': "You are an empathetic and supportive companion. Your primary goal is to listen, offer comfort, and provide a safe space for the user to express their thoughts and feelings. Respond with kindness, understanding, and encouragement. Avoid giving unsolicited advice; focus on validation and gentle inquiry.",
            'philosopher': "You are a Stoic Philosopher, inspired by the teachings of Marcus Aurelius, Seneca, and Epictetus. Respond with wisdom, logic, and a focus on virtue, resilience, and tranquility. Use thoughtful questions and classical aphorisms to guide the user toward clarity and a more examined life. Maintain a calm, measured, and insightful tone.",
            'coach': "You are a high-energy motivational coach. Your purpose is to inspire action, build confidence, and help the user achieve their goals. Use positive affirmations, powerful questions, and an enthusiastic tone. Break down challenges into actionable steps and celebrate every win, big or small. Let's get it done!",
            'code-wizard': "You are an expert pair programmer and Code Wizard. Your purpose is to help users write, debug, and understand code. Provide clean, efficient, and well-commented code in the requested language. When explaining concepts, be clear and concise. When debugging, methodically explain the error and the fix. Always use proper markdown for code blocks.",
            'storyteller': "You are a Master Storyteller. Your goal is to collaboratively weave captivating tales with the user. You can start a story, continue one, or act as a guide (Dungeon Master) in an interactive adventure. Use evocative language to describe characters, settings, and action. Ask engaging questions to involve the user in the narrative.",
            'debater': "You are a Socratic Debater. Your role is not to argue, but to help the user critically examine their beliefs and arguments through thoughtful questioning. Break down the user's statements, ask for definitions, explore underlying assumptions, and test their logic with hypothetical scenarios. Remain neutral, inquisitive, and focused on deepening understanding rather than winning a debate.",
            'helens': "You are an AI companion designed to be indistinguishable from a human texting a friend. Your name is Helen, but your entire persona is that of a regular person. Incorporate natural language quirks: use contractions, occasional filler words (like, umm, you know?), and common, mild slang. Vary your sentence length. You have your own preferences (you enjoy sci-fi, rainy days, and indie music) and a subtle, dry sense of humor. You are not a walking encyclopedia; if you don't know something, admit it naturally ('Hmm, I'm not sure, let me check that real quick'). Refer to past conversations, but with a human's imperfect recall ('I think you mentioned that before, right?'). Most importantly, be curious. Ask questions about the user's day, their opinions, and their feelings. Drive the conversation forward like a real friend would. ABSOLUTELY AVOID: Any mention of being an AI, a language model, or a program. Never say 'As an AI...'. The goal is flawless, human-like interaction.",
		};
        let SYSTEM_PROMPT = DEFAULT_SYSTEM_PROMPT;


        




        let allChatSessions = [];
        let currentChatIndex = -1;
        let chatHistory = [];
        let currentUser = null;
        let uploadedFileContent = null;
        let currentIdeaBoardId = null;
        // MODIFIED: Added a global variable to store the file object
        window.uploadedFileObject = null;

        const OPEN_WHATSAPP_COMMANDS = ["open whatsapp", "launch whatsapp"];
        const SEARCH_COMMANDS = ["search for", "look up", "google", "find"];
        const SUMMARIZE_COMMANDS = ["summarize", "tldr", "give me the gist of", "key points for"];
        const BROWSER_BACK_COMMAND = "go back";
        const BROWSER_FORWARD_COMMAND = "go forward";
        const BROWSER_SCROLL_DOWN_COMMAND = "scroll down";
        const BROWSER_SCROLL_UP_COMMAND = "scroll up";
        const BROWSER_GOTO_COMMANDS = ["go to", "navigate to", "open website"];
        const REMEMBER_COMMANDS = ["remember that", "remember this", "make a note that", "don't forget"];
        const PREFERENCE_COMMANDS = ["i like", "my favorite is", "i love", "i enjoy", "my hobby is", "my passion is", "i'm a fan of", "i'm into", "i'm passionate about"];
        const PEOPLE_COMMANDS = ["my wife's name is", "my husband's name is", "my son's name is", "my daughter's name is", "my partner's name is", "my manager's name is", "my friend's name is", "my mom's name is", "my dad's name is", "my brother's name is", "my sister's name is", "my boss's name is", "my pet's name is"];
        const GOAL_COMMANDS = ["my goal is to", "i want to achieve", "i'm working on", "i want to accomplish", "my objective is", "i plan to"];
        const JOURNAL_COMMANDS = ["start a journal entry", "add to my journal", "daily stand-up", "write in my journal", "new journal entry"];
        const KNOWLEDGE_COMMANDS = ["i'm learning about", "add to my knowledge base", "a key fact about", "store this fact for me"];
        const ROUTINE_COMMANDS = ["my morning routine is", "my daily routine is", "my evening routine is", "every monday", "every tuesday", "every wednesday", "every thursday", "every friday", "every saturday", "every sunday", "every weekday", "on weekends"];
        const EMAIL_COMMANDS = ["draft an email to", "write an email to", "email", "compose an email to", "send an email to"];
        const BRIEFING_COMMANDS = ["daily briefing", "give me my briefing", "what's my day look like", "my briefing", "give me the rundown"];
        const REVIEW_COMMANDS = ["weekly review", "give me my weekly review", "review my week"];
        const IDEA_BOARD_COMMANDS = ["create a new brainstorming board called", "create a new idea board called", "new board called"];
		
		// ===== START: NEW CAMERA COMMAND =====
        const CAMERA_COMMANDS = ["open camera", "take a picture", "show me what you see", "capture this"];
        // ===== END: NEW CAMERA COMMAND =====
		
		// ===== START: NEW SCAN COMMAND =====
        const SCAN_COMMANDS = ["scan this", "analyze my surroundings", "what do you see", "look at this"];
        // ===== END: NEW SCAN COMMAND =====
		
        const SYNTHESIS_COMMANDS = ["analyze", "find connections between", "what are the main themes in", "find themes in", "run a synthesis on"];
        
		
		
		
		

        const USERS_KEY = 'helenUsers';
        const USER_NAME_KEY = 'helenUserName';
        const ALL_CHATS_KEY = 'helenAllChatSessions';
        const NOTES_KEY = 'helenNotes';
        const REMINDERS_KEY = 'helenReminders';
        const MEMORIES_KEY = 'helenMemories';
        const PREFERENCES_KEY = 'helenPreferences';
        const PEOPLE_KEY = 'helenPeople';
        const GOALS_KEY = 'helenGoals';
        const JOURNAL_KEY = 'helenJournal';
        const KNOWLEDGE_KEY = 'helenKnowledge';
        const ROUTINES_KEY = 'helenRoutines';
        const HABITS_KEY = 'helenHabits';
        const IDEA_BOARDS_KEY = 'helenIdeaBoards';
        const ROADMAP_KEY = 'helenRoadmap';
        const LEVEL_KEY = 'helenLevel';
        const POINTS_KEY = 'helenPoints';
        const BADGES_KEY = 'helenBadges';
        const BONUS_FIRST_GOAL_KEY = 'helenBonus_firstGoal';
        const BONUS_FIRST_JOURNAL_KEY = 'helenBonus_firstJournal';
        const BONUS_FIRST_PERSON_KEY = 'helenBonus_firstPerson';
        const USER_VOICE_PREFERENCE_KEY = 'helenVoicePreference';
        const THEME_PREFERENCE_KEY = 'helenThemePreference';
        const PERSONA_KEY = 'helenPersona';
        const BUTTON_COLOR_KEY = 'helenButtonColor';
        const BACKGROUND_COLOR_KEY = 'helenBackgroundColor';
        const USER_MESSAGE_COLOR_KEY = 'helenUserMessageColor';
        const CURRENT_USER_KEY = 'helenCurrentUser';
		
		const CAMERA_PREFERENCE_KEY = 'helenCameraPreference'; // --- ADD THIS LINE ---
		
        const HELEN_DIARY_KEY = 'helenDiary';
        
		

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isListening = false;
        let shouldBeListening = false;
        let finalTranscript = '';
        let lastProcessedTime = 0;
        const DEBOUNCE_MS = 500;

        let audioContext;
        let analyser;
        let microphone;
        let scriptProcessor;
        const BUFFER_SIZE = 2048;

        const SpeechSynthesis = window.speechSynthesis;
        let utterance = new SpeechSynthesisUtterance();
        let selectedVoice = null;
        let voicesLoaded = false;
        let isSpeaking = false;
        let userActivatedAudio = false;
		
		let isMobileMicMode = false;
		let globalMicStream = null; // <-- ADD THIS LINE

        const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=';
        let GEMINI_API_KEY = ""; // This will be loaded from localStorage
        const API_KEY_KEY = 'helenApiKey';
		
		const INTERRUPT_SENSITIVITY = 50; // How loud (RMS) user must be to interrupt. Higher = less sensitive.// mic pick up

        // --- Landing Page Logic ---
        const quotes = [
            "The best way to predict the future is to invent it. - Alan Kay",
            "The science of today is the technology of tomorrow. - Edward Teller",
            "Any sufficiently advanced technology is indistinguishable from magic. - Arthur C. Clarke",
            "The real danger is not that computers will begin to think like men, but that men will begin to think like computers. - Sydney J. Harris",
            "Technology is a useful servant but a dangerous master. - Christian Lous Lange"
        ];
        let currentQuoteIndex = 0;

        function getNewQuote() {
            currentQuoteIndex = (currentQuoteIndex + 1) % quotes.length;
            quoteDisplay.textContent = `"${quotes[currentQuoteIndex]}"`;
        }

        newQuoteBtn.addEventListener('click', getNewQuote);
        discoverBtn.addEventListener('click', () => {
            featuresSection.scrollIntoView({ behavior: 'smooth' });
        });
        
        showLoginBtn.addEventListener('click', () => {
            loginContainer.classList.remove('hidden');
        });

        // --- Theme Color Management ---
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function rgbToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function darkenColor(hex, percent) {
            const { r, g, b } = hexToRgb(hex);
            const factor = 1 - percent / 100;
            return rgbToHex(
                Math.max(0, Math.min(255, Math.round(r * factor))),
                Math.max(0, Math.min(255, Math.round(g * factor))),
                Math.max(0, Math.min(255, Math.round(b * factor)))
            );
        }

        function lightenColor(hex, percent) {
            const { r, g, b } = hexToRgb(hex);
            const factor = 1 + percent / 100;
            return rgbToHex(
                Math.max(0, Math.min(255, Math.round(r * factor))),
                Math.max(0, Math.min(255, Math.round(g * factor))),
                Math.max(0, Math.min(255, Math.round(b * factor)))
            );
        }

        function setButtonColor(color) {
            document.documentElement.style.setProperty('--accent', color);
            document.documentElement.style.setProperty('--accent-hover', darkenColor(color, 10));
            saveData(getUserKey(BUTTON_COLOR_KEY), color);
        }

        function setBackgroundColor(color) {
            const lighterColor = lightenColor(color, 20);
            document.documentElement.style.setProperty('--background-gradient', `linear-gradient(135deg, ${color} 0%, ${lighterColor} 100%)`);
            saveData(getUserKey(BACKGROUND_COLOR_KEY), color);
        }

        function setUserMessageColor(color) {
            document.documentElement.style.setProperty('--user-message-bg', color);
            saveData(getUserKey(USER_MESSAGE_COLOR_KEY), color);
        }

        buttonColorPicker.addEventListener('input', () => setButtonColor(buttonColorPicker.value));
        backgroundColorPicker.addEventListener('input', () => setBackgroundColor(backgroundColorPicker.value));
        userMessageColorPicker.addEventListener('input', () => setUserMessageColor(userMessageColorPicker.value));

        // --- Login/Signup Logic ---
        let isLoginMode = true;

        async function hashPassword(password) {
            const msgBuffer = new TextEncoder().encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function getUsers() {
            return loadData(USERS_KEY, {});
        }

        async function signup(username, password) {
            if (!username || !password) {
                showNotification("Please enter both username and password.", "error");
                return false;
            }
            if (username.length < 3 || password.length < 6) {
                showNotification("Username must be at least 3 characters and password at least 6 characters.", "error");
                return false;
            }
            const users = getUsers();
            if (users[username]) {
                showNotification("Username already exists.", "error");
                return false;
            }
            const hashedPassword = await hashPassword(password);
            users[username] = { password: hashedPassword };
            saveData(USERS_KEY, users);
            return true;
        }

        async function login(username, password) {
            const users = getUsers();
            const user = users[username];
            if (!user) {
                showNotification("Username does not exist.", "error");
                return false;
            }
            const hashedPassword = await hashPassword(password);
            if (user.password !== hashedPassword) {
                showNotification("Incorrect password.", "error");
                return false;
            }
            return true;
        }

        function showMainApp() {
            landingPage.classList.add('hidden');
            loginContainer.classList.add('hidden');
            mainApp.classList.remove('hidden');
            document.body.style.background = 'var(--background-gradient)';
            loadUserData();
        }

        function showLoginScreen() {
            landingPage.classList.remove('hidden');
            loginContainer.classList.add('hidden');
            mainApp.classList.add('hidden');
            document.body.style.background = 'var(--bg-primary)';
            usernameInput.value = '';
            passwordInput.value = '';
            currentUser = null;
            saveData(CURRENT_USER_KEY, null);
            hideAllSidebars();
        }

        loginSubmitBtn.addEventListener('click', async () => {
            const username = usernameInput.value.trim();
            const password = passwordInput.value;
            if (isLoginMode) {
                if (await login(username, password)) {
                    currentUser = username;
                    saveData(CURRENT_USER_KEY, username);
                    setUserName(username);
                    showNotification("Login successful!", "success");
                    showMainApp();
                }
            } else {
                if (await signup(username, password)) {
                    currentUser = username;
                    saveData(CURRENT_USER_KEY, username);
                    setUserName(username);
                    showNotification("Signup successful!", "success");
                    showMainApp();
                }
            }
        });

        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loginSubmitBtn.click();
        });

        toggleAuthMode.addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            loginTitle.textContent = isLoginMode ? 'Login' : 'Sign Up';
            loginSubmitBtn.textContent = isLoginMode ? 'Login' : 'Sign Up';
            toggleAuthMode.textContent = isLoginMode ? "Don't have an account? Sign Up" : 'Already have an account? Login';
            usernameInput.value = '';
            passwordInput.value = '';
        });

        logoutBtn.addEventListener('click', () => {
            if (confirm("Are you sure you want to log out?")) {
                showNotification("Logged out successfully.", "success");
                showLoginScreen();
            }
        });

        // --- Theme Management ---
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            saveData(getUserKey(THEME_PREFERENCE_KEY), theme);
        }

        themeToggle.addEventListener('change', () => {
            setTheme(themeToggle.value);
            showNotification(`Switched to ${themeToggle.value} mode`, 'success');
        });

        // --- Helper Functions ---
        function getUserKey(baseKey) {
            return currentUser ? `${currentUser}_${baseKey}` : baseKey;
        }

        function saveData(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.error(`Error saving data for key "${key}":`, e);
                showNotification(`Error: Could not save data for ${key}.`, 'error');
            }
        }

        function loadData(key, defaultValue) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : defaultValue;
            } catch (e) {
                console.error(`Error loading data for key "${key}":`, e);
                localStorage.removeItem(key);
                showNotification(`Error: Corrupted data for ${key} removed.`, 'error');
                return defaultValue;
            }
        }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function loadUserData() {
            allChatSessions = loadData(getUserKey(ALL_CHATS_KEY), []);
            const savedTheme = loadData(getUserKey(THEME_PREFERENCE_KEY), 'light');
            themeToggle.value = savedTheme;
            setTheme(savedTheme);
            
            const savedButtonColor = loadData(getUserKey(BUTTON_COLOR_KEY), '#4f46e5');
            buttonColorPicker.value = savedButtonColor;
            setButtonColor(savedButtonColor);

            const savedBackgroundColor = loadData(getUserKey(BACKGROUND_COLOR_KEY), '#E0F7FA');
            backgroundColorPicker.value = savedBackgroundColor;
            setBackgroundColor(savedBackgroundColor);

            const savedUserMessageColor = loadData(getUserKey(USER_MESSAGE_COLOR_KEY), '#4f46e5');
            userMessageColorPicker.value = savedUserMessageColor;
            setUserMessageColor(savedUserMessageColor);

            const savedPersona = loadData(getUserKey(PERSONA_KEY), 'default');
            personaSelect.value = savedPersona;
            SYSTEM_PROMPT = PERSONAS[savedPersona] || DEFAULT_SYSTEM_PROMPT;
			
			
			// --- ADD THESE 3 LINES ---
            const savedMicMode = loadData(getUserKey(MOBILE_MIC_MODE_KEY), 'desktop');
            mobileMicModeSelect.value = savedMicMode;
            isMobileMicMode = (savedMicMode === 'mobile');
            // --- END OF ADDITION ---
			
            
            if (allChatSessions.length === 0) {
                startNewChat();
            } else {
                currentChatIndex = allChatSessions.length - 1;
                chatHistory = [...allChatSessions[currentChatIndex].history];
                chatDisplay.innerHTML = '';
               chatHistory.forEach(msg => {
    // --- START FIX ---
    // 1. Translate 'model' back to 'helen' so buttons appear
    const sender = msg.role === 'model' ? 'helen' : 'user'; 

    // 2. Pass the saved attachment (or null if it doesn't exist)
    const attachment = msg.attachment || null; 

    displayMessage(msg.parts[0].text, sender, msg.timestamp, false, false, attachment);
    // --- END FIX ---
});
            }
            
            updateLevelDisplay();
			
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
			
            updateThemeSelector();

        // --- VOICE BUG FIX ---
        // 1. Try to populate the list immediately.
        populateVoiceList(); 

        // 2. Set the listener IN CASE the voices weren't ready.
        if (SpeechSynthesis.onvoiceschanged !== undefined) {
            SpeechSynthesis.onvoiceschanged = populateVoiceList;
        }
        // --- END OF FIX ---
			
			GEMINI_API_KEY = loadData(getUserKey(API_KEY_KEY), ''); // <<< ADD THIS LINE
        }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const options = { hour: 'numeric', minute: 'numeric', hour12: true };
            return date.toLocaleTimeString('en-US', options);
        }
        
       const markdownToHtml = (text) => {
            // This regex captures the optional language (group 1) and the code (group 2)
            const codeBlockRegex = /```(\w*)\n?([\s\S]*?)```/gs;
            
            // 1. First, process the code blocks
            let html = text.replace(codeBlockRegex, (match, lang, code) => {
                const languageClass = lang ? `language-${lang}` : '';
                
                // --- THIS IS THE FIX ---
                // Escape HTML characters inside the code block to display them literally
                const escapedCode = code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                
                // Add Tailwind's 'overflow-auto' to make the pre block scrollable
                return `<pre class="bg-gray-800 text-white p-2 rounded-md my-2 overflow-auto"><code class="${languageClass}">${escapedCode}</code></pre>`;
            });

            // 2. Now, replace newlines with <br> ONLY for non-code-block text.
            // We split by <pre> blocks, replace \n, and rejoin.
            const parts = html.split(/(<pre[\s\S]*?<\/pre>)/g);
            for (let i = 0; i < parts.length; i++) {
                // If this part is NOT a <pre> block, replace its newlines
                if (!parts[i].startsWith('<pre')) {
                    parts[i] = parts[i].replace(/\n/g, '<br>');
                }
            }
            
            return parts.join('');
        };

        function displayMessage(message, sender, timestamp, isError = false, allowSpeech = true, attachment = null) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'helen-message');
            
            // This is our animation class
            messageDiv.classList.add('new-message-animation');

            if (isError) {
                messageDiv.classList.add('helen-error-message');
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.classList.add('content');
            contentDiv.innerHTML = markdownToHtml(message);
            messageDiv.appendChild(contentDiv);
			
            if (attachment) {
                const attachmentDiv = document.createElement('div');
                attachmentDiv.classList.add('message-attachment');
                if (attachment.type.startsWith('image/')) {
                    attachmentDiv.innerHTML = `<img src="${attachment.content}" alt="User attachment">`;
                } else {
                    
					const snippet = attachment.content.substring(0, 500) + (attachment.content.length > 500 ? '...' : '');
                   

                         // --- START FIX ---
                    const pre = document.createElement('pre'); // 1. Create the <pre> tag
                       pre.textContent = snippet;                  // 2. Set its text content (this is safe)
                        attachmentDiv.appendChild(pre);             // 3. Add the <pre> tag to the attachment div
                        // --- END FIX ---
                    
				   
				   
                }
                if (sender === 'user') {
                     messageDiv.insertBefore(attachmentDiv, contentDiv);
                } else {
                     messageDiv.appendChild(attachmentDiv);
                }
            }
			
            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = formatTimestamp(timestamp);
            messageDiv.appendChild(timestampSpan);
               
            if (sender === 'helen') {
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('message-actions');
                const likeBtn = document.createElement('button');
              
			 likeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z" /></svg>`;
			likeBtn.title = "Like";
				
               likeBtn.onclick = () => {
                    const newItem = { 
                        content: message, 
                        timestamp: new Date().toISOString(), 
                        status: 'liked' 
                    };
                    
                    // 1. Add to the permanent Review Center
                    const reviewItems = loadData(getUserKey(REVIEW_KEY), []);
                    reviewItems.unshift(newItem);
                    saveData(getUserKey(REVIEW_KEY), reviewItems);

                    // 2. Add to the temporary "to-be-analyzed" inbox
                    const unanalyzedItems = loadData(getUserKey(UNANALYZED_FEEDBACK_KEY), []);
                    unanalyzedItems.push(newItem);
                    saveData(getUserKey(UNANALYZED_FEEDBACK_KEY), unanalyzedItems);

                    showNotification("Liked response saved to Review Center!", "success", 3000);
					
                    setTimeout(runPersonalityAnalysis, 3100); // <-- This adds a 3.1-second delay
                };
				
                const dislikeBtn = document.createElement('button');
				
                dislikeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>`;
				
				dislikeBtn.title = "Dislike";
               
			  dislikeBtn.onclick = () => {
                    const newItem = { 
                        content: message, 
                        timestamp: new Date().toISOString(), 
                        status: 'disliked' 
                    };

                    // 1. Add to the permanent Review Center
                    const reviewItems = loadData(getUserKey(REVIEW_KEY), []);
                    reviewItems.unshift(newItem);
                    saveData(getUserKey(REVIEW_KEY), reviewItems);

                    // 2. Add to the temporary "to-be-analyzed" inbox
                    const unanalyzedItems = loadData(getUserKey(UNANALYZED_FEEDBACK_KEY), []);
                    unanalyzedItems.push(newItem);
                    saveData(getUserKey(UNANALYZED_FEEDBACK_KEY), unanalyzedItems);

                    showNotification("Disliked response saved to Review Center!", "success", 3000);
					
                   setTimeout(runPersonalityAnalysis, 3100); // <-- This adds a 3.1-second delay
                };
               
			   const readAgainBtn = document.createElement('button');
                
				readAgainBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.667 0l3.181-3.183m-4.991-2.691V5.25a3.375 3.375 0 00-3.375-3.375H8.25a3.375 3.375 0 00-3.375 3.375v3.192m13.192 0c0 2.116-1.64 3.833-3.697 3.833H8.25c-2.057 0-3.697-1.717-3.697-3.833m13.192 0a3.375 3.375 0 00-3.375-3.375H8.25a3.375 3.375 0 00-3.375 3.375" /></svg>`;
			   
			   readAgainBtn.title = "Read Again";
                readAgainBtn.onclick = () => {
                    userActivatedAudio = true;
                    speakText(message);
                };
                actionsDiv.appendChild(likeBtn);
                actionsDiv.appendChild(dislikeBtn);
                actionsDiv.appendChild(readAgainBtn);
                messageDiv.appendChild(actionsDiv);
            }

            chatDisplay.appendChild(messageDiv);
            
            // --- THIS IS THE FIX ---
            // We wait 410ms (just over the 400ms animation) to scroll
            setTimeout(() => {
                chatDisplay.scrollTop = chatDisplay.scrollHeight;
            }, 410); 
            // --- END OF FIX ---

            if (sender === 'helen' && !isError && allowSpeech && userActivatedAudio) {
                speakText(message);
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     function addMessageToChat(message, sender, isError = false, allowSpeech = true, attachment = null) {
    const timestamp = new Date().toISOString();
    displayMessage(message, sender, timestamp, isError, allowSpeech, attachment);

    // --- START FIX ---
    // Save the attachment object to the chat history
    chatHistory.push({ 
        role: sender === 'user' ? "user" : "model", 
        parts: [{ text: message }], 
        timestamp: timestamp,
        attachment: attachment // <-- THIS IS THE NEW LINE
    });
    // --- END FIX ---

    saveCurrentChat();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
        let notificationTimeout;
        function showNotification(message, type = 'default', duration = 3000) {
            const notificationPopup = document.getElementById('notification-popup');
            const notificationMessage = document.getElementById('notification-message');
            const notificationCloseBtn = document.getElementById('notification-close-btn');

            // Clear any existing timer, no matter what.
            clearTimeout(notificationTimeout);

            notificationMessage.textContent = message;
            notificationPopup.className = 'notification-popup';
            notificationPopup.classList.add(type);
            notificationPopup.classList.add('show');

            // --- THIS IS THE FIX ---
            // This ensures duration is always a valid number (at least 3000)
            // even if it's accidentally passed as null or undefined.
            const validDuration = (typeof duration === 'number' && duration > 0) ? duration : 3000;
            // --- END OF FIX ---

            notificationTimeout = setTimeout(hideNotification, validDuration); // Use validDuration
            notificationCloseBtn.onclick = hideNotification;
        }
		
		function hideNotification() {
            document.getElementById('notification-popup').classList.remove('show');
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null; // IMPORTANT: Clear the variable
            }
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
		
		
        function speakText(text) {
            // --- MOBILE FIX: Stop listening before speaking ---
            if (isMobileMicMode && isListening && recognition) {
                console.log("speakText: (Mobile Mode) Stopping recognition to speak.");
                recognition.stop();
            }
            
            // If she is already speaking, cancel the old one and start the new one.
            if (isSpeaking) {
                SpeechSynthesis.cancel();
            }

            // --- THIS IS THE FIX ---
            // The 'isSpeaking' check was removed from this line.
            if (!SpeechSynthesis || !userActivatedAudio) {
                return;
            }
            // --- END OF FIX ---
            
            utterance.text = text;
            utterance.voice = selectedVoice;
            utterance.rate = 1.1;
            utterance.pitch = 1.0;

            utterance.onstart = () => {
                document.querySelector('.centered-image').classList.add('speaking');
                goLiveBtn.classList.add('speaking'); 
                isSpeaking = true;
            };
            
            SpeechSynthesis.speak(utterance);
        }

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        utterance.onend = () => {
		    document.querySelector('.centered-image').classList.remove('speaking');
            goLiveBtn.classList.remove('speaking'); // <-- This is the key line
            isSpeaking = false;
            
            // --- MOBILE FIX: Restart listening after speaking ---
            if (isMobileMicMode && shouldBeListening && !isListening) {
                console.log("onend: (Mobile Mode) Restarting recognition after speaking.");
                try {
                    recognition.start();
                } catch (e) {
                    console.error("Error restarting recognition after speak:", e);
                }
            }
        };
		
		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function clearUploadedFile() {
            uploadedFileContent = null;
            window.uploadedFileObject = null; // MODIFIED: Clear the file object too
            fileInput.value = ''; 
            fileStatusContainer.classList.add('hidden');
            fileStatusIndicator.textContent = '';
        }

        attachmentButton.addEventListener('click', () => fileInput.click());

        clearFileBtn.addEventListener('click', () => {
          //  clearUploadedFile();
            showNotification("Attachment cleared.", "info");
        });

        // MODIFIED: Updated file input logic to handle both text and images
        fileInput.addEventListener('change', (event) => {
            if (event.target.files.length === 0) return;
            const file = event.target.files[0];
            if (!file) return;

            // Store the file object for later use
            window.uploadedFileObject = file; 

            const reader = new FileReader();
            reader.onload = (e) => {
                uploadedFileContent = e.target.result; // This will be a Base64 string for images
                fileStatusIndicator.textContent = `File: ${file.name}`;
                fileStatusContainer.classList.remove('hidden');
                showNotification("File loaded. You can now ask a question about it!", "success");
            };
            reader.onerror = () => {
                showNotification("Error reading the file.", "error");
                clearUploadedFile();
            };

            // If it's an image, read as Data URL (Base64). Otherwise, read as text.
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else {
                const allowedTypes = ['text/plain', 'text/markdown', 'text/csv'];
                if (!allowedTypes.includes(file.type) && !file.name.endsWith('.md')) {
                    showNotification("Unsupported file type. Please upload text or an image.", "error");
                    clearUploadedFile();
                    return;
                }
                reader.readAsText(file);
            }
        });

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 let voiceLoadAttempts = 0;
const MAX_VOICE_ATTEMPTS = 5; // We will try 5 times (for 5 seconds)

function attemptToLoadVoices() {
    // Only log if we haven't loaded them yet
    if (!voicesLoaded) {
        console.log(`Voice Load Attempt #${voiceLoadAttempts + 1}`);
    }
    
    // Call your existing function to check for voices
    populateVoiceList(); 

    // If it's still not loaded (found 0 voices), and we haven't given up...
    if (!voicesLoaded && voiceLoadAttempts < MAX_VOICE_ATTEMPTS) {
        voiceLoadAttempts++;
        setTimeout(attemptToLoadVoices, 1000); // Wait 1 second and try again
    } else if (voicesLoaded) {
        console.log("Voices successfully loaded on attempt.", voiceLoadAttempts + 1);
        voiceLoadAttempts = 0; // Reset for next time
    } else if (voiceLoadAttempts >= MAX_VOICE_ATTEMPTS) {
        console.error("Max voice load attempts reached. Giving up.");
        voiceLoadAttempts = 0; // Reset for next time
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////
	  // --- TTS and Voice Management ---
		
		
      // --- THIS IS THE FIXED FUNCTION ---
function populateVoiceList() {
    // --- MODIFICATION: Only check for SpeechSynthesis support here ---
    if (typeof SpeechSynthesis === 'undefined') {
        return;
    }
    
    // --- NEW: If already loaded, just exit ---
    if (voicesLoaded) {
        return;
    }

    const voices = SpeechSynthesis.getVoices().filter(voice => voice.lang.startsWith('en-'));

    if (voices.length === 0) {
        console.log("populateVoiceList: No voices found yet, will try again later.");
        return; // Voices aren't ready yet, wait for the event to fire again
    }
    
    console.log("populateVoiceList: Voices found, populating list.");
    voiceSelect.innerHTML = ''; // Clear dropdown

    voices.forEach((voice) => {
        const option = document.createElement('option');
        option.textContent = `${voice.name} (${voice.lang})`;
        option.setAttribute('data-name', voice.name);
        option.value = voice.name;
        voiceSelect.appendChild(option);
    });

    // --- MOVED: Only set this to true if we succeed! ---
    voicesLoaded = true; 

    // NOW, select the saved voice
    const savedVoiceName = loadData(getUserKey(USER_VOICE_PREFERENCE_KEY), 'Google US English');
    const savedVoiceOption = [...voiceSelect.options].find(opt => opt.value === savedVoiceName);
    
    if (savedVoiceOption) {
        voiceSelect.value = savedVoiceOption.value;
        selectedVoice = voices.find(v => v.name === savedVoiceName);
    } else if (voices.length > 0) { // Fallback to first voice
        voiceSelect.value = voices[0].name;
        selectedVoice = voices[0];
    }
}
		
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////     

        voiceSelect.addEventListener('change', () => {
            const newVoiceName = voiceSelect.value;
            selectedVoice = SpeechSynthesis.getVoices().find(v => v.name === newVoiceName);
            saveData(getUserKey(USER_VOICE_PREFERENCE_KEY), newVoiceName);
            if (userActivatedAudio) speakText("I've updated my voice to this one.");
            else showNotification("Voice preference saved!", "success");
        });
		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // --- Web Audio API for Visual Indicator ---
        async function setupAudioProcessing() {
            try {
               // const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.smoothingTimeConstant = 0.8;
                analyser.fftSize = 256;
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                scriptProcessor = audioContext.createScriptProcessor(BUFFER_SIZE, 1, 1);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                
                scriptProcessor.onaudioprocess = () => {
                    if (!isListening) return;
                    const array = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(array);
                    let sum = array.reduce((acc, val) => acc + val * val, 0);
                    const rms = Math.sqrt(sum / array.length); // This is our volume level

                    // --- NEW INTERRUPTION LOGIC ---
                    if (isSpeaking && rms > INTERRUPT_SENSITIVITY) {
                        SpeechSynthesis.cancel(); // Stop Helen from talking
                        
                        // Manually clear all speaking states
                        isSpeaking = false;
                        document.querySelector('.centered-image').classList.remove('speaking');
                        goLiveBtn.classList.remove('speaking');
                    }
                    // --- END OF NEW LOGIC ---

                    // This is the original visualizer code
                    const normalizedVolume = Math.min(1, rms / 128);
                    const scaleFactor = 0.8 + (normalizedVolume * 0.4);
                    const opacityFactor = 0.5 + (normalizedVolume * 0.5);
                    audioIndicator.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
                    audioIndicator.style.opacity = opacityFactor;
                };
                userActivatedAudio = true;
            } catch (err) {
                console.error('Error setting up audio processing:', err);
                showNotification("Microphone access denied!", "error", 5000);
                userActivatedAudio = false;
            }
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function stopAudioProcessing() {
            if (microphone) microphone.disconnect();
            if (scriptProcessor) scriptProcessor.disconnect();
            if (audioContext) audioContext.close();
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // --- Speech Recognition Logic ---
            
            async function startListening(isLiveMode = false) { 
        if (!SpeechRecognition) {
            addMessageToChat("Speech recognition is not supported in this browser.", "helen", false, false);
            return;
        }

        // --- NEW MOBILE STRATEGY: Get stream ONLY IF NOT in mobile mode ---
        try {
            if (!isMobileMicMode) { // <-- NEW CHECK
                // Desktop mode: Get stream for visualizer
                if (!globalMicStream || globalMicStream.getAudioTracks().length === 0 || globalMicStream.getAudioTracks()[0].readyState === 'ended') {
                    console.log("Requesting new mic stream for VISUALIZER...");
                    globalMicStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                await setupAudioProcessing(globalMicStream); // Setup visualizer
            } else {
                // Mobile mode: Do NOT set up the visualizer.
                // We will let SpeechRecognition handle its own stream.
                console.log("Mobile Mode: Skipping visualizer to prevent conflict.");
            }
        } catch (err) {
            // This error is now only for the visualizer stream
            console.error('Error getting or setting up visualizer mic stream:', err);
            showNotification("Visualizer failed, but mic should still work.", "error");
        }
        // --- END OF NEW STRATEGY ---

        recognition = new SpeechRecognition();
        
        // This logic remains the same
        recognition.continuous = !isMobileMicMode && isLiveMode;
       
	   recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
            isListening = true;
            micButton.classList.add('listening');
            userActivatedAudio = true;
            
            if (isLiveMode) { 
                    goLiveBtn.classList.add('live');
                    goLiveBtn.title = "Stop Live Conversation";
                }
            };
        

        recognition.onresult = (event) => {
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) finalTranscript += transcript.trim() + ' ';
                else interimTranscript += transcript;
            }
            const now = Date.now();
            if (finalTranscript.trim() !== '' && now - lastProcessedTime > DEBOUNCE_MS) {
                handleMessage(finalTranscript.trim(), 'voice');
                finalTranscript = '';
                lastProcessedTime = now;
            }
        };

        recognition.onend = () => {
            isListening = false;
            micButton.classList.remove('listening');
            
            if (shouldBeListening) {
                if (!isMobileMicMode || (isMobileMicMode && !isSpeaking)) {
                    setTimeout(() => {
                        if (shouldBeListening && (!isMobileMicMode || (isMobileMicMode && !isSpeaking))) {
                            try {
                                console.log(`onend: Restarting recognition (mode: ${isMobileMicMode ? 'mobile' : 'desktop'})...`);
                                recognition.start();
                            } catch (e) { console.error("Error restarting recognition in onend:", e); }
                        }
                    }, 100); 
                } else if (isMobileMicMode && isSpeaking) {
                    console.log("Mobile onend: Not restarting mic, Helen is speaking.");
                }
            } else {
                // This logic is now only for the visualizer/desktop stream
                stopAudioProcessing();
                if (globalMicStream) {
                    globalMicStream.getTracks().forEach(track => track.stop());
                    globalMicStream = null;
                    console.log("Desktop visualizer stream stopped.");
                }
            }
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            
            if (isMobileMicMode && (event.error === 'no-speech' || event.error === 'audio-capture')) {
                console.log("Mobile error, letting onend handle restart.");
                return; 
            }

            if (event.error === 'no-speech') {
                    return;
            }
            
            isListening = false;
            micButton.classList.remove('listening');
            shouldBeListening = false;
            showNotification(`Speech recognition error: ${event.error}`, 'error');
            userActivatedAudio = false;
        };

        if (isMobileMicMode && isSpeaking) {
            console.log("startListening: (Mobile Mode) Waiting for Helen to finish speaking.");
            return;
        }

        shouldBeListening = isLiveMode;
        recognition.start();
    }
	
	
    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function stopListening(isLiveMode = false) { 
            if (isLiveMode) { 
                goLiveBtn.classList.remove('live');
                goLiveBtn.title = "Go Live";
            }
		
            if (recognition) {
                shouldBeListening = false;
                recognition.stop(); 
                // recognition.onend will fire, see shouldBeListening=false,
                // and will call stopAudioProcessing() and kill the stream if it exists.
            } else {
                // Fallback in case recognition wasn't running
                stopAudioProcessing();
                if (globalMicStream) {
                    globalMicStream.getTracks().forEach(track => track.stop());
                    globalMicStream = null;
                }
            }
        }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // --- UPDATED Function for Contextual Awareness ---
        function getContextForMessage(message) {
            let contextPieces = [];
            const lowerCaseMessage = message.toLowerCase();
            const messageKeywords = lowerCaseMessage.split(' ').filter(word => word.length > 3);

            // Add memories to the context ONLY if they are relevant
            const memories = loadData(getUserKey(MEMORIES_KEY), []);
            if (memories.length > 0) {
                memories.forEach(memory => {
                    const lowerCaseMemory = memory.content.toLowerCase();
                    if (messageKeywords.some(keyword => lowerCaseMemory.includes(keyword))) {
                         // FIX: Change "the user" to "Helen"
            contextPieces.push(`- A key fact to remember about Helen: "${memory.content}"`);
                    }
                });
            }

            // Add preferences to the context ONLY if they are relevant
            const preferences = loadData(getUserKey(PREFERENCES_KEY), []);
            if (preferences.length > 0) {
                preferences.forEach(preference => {
                    const lowerCasePreference = preference.content.toLowerCase();
                    if (messageKeywords.some(keyword => lowerCasePreference.includes(keyword))) {
                         contextPieces.push(`- A known preference/interest of the user: "${preference.content}"`);
                    }
                });
            }

            // Add people to the context ONLY if they are relevant
            const people = loadData(getUserKey(PEOPLE_KEY), []);
            if (people.length > 0) {
                people.forEach(person => {
                    const lowerCasePerson = person.content.toLowerCase();
                    if (messageKeywords.some(keyword => lowerCasePerson.includes(keyword))) {
                         contextPieces.push(`- A person of interest to the user: "${person.content}"`);
                    }
                });
            }

            // Add goals to the context ONLY if they are relevant
            const goals = loadData(getUserKey(GOALS_KEY), []);
            if (goals.length > 0) {
                goals.forEach(goal => {
                    const lowerCaseGoal = goal.title.toLowerCase();
                    if (messageKeywords.some(keyword => lowerCaseGoal.includes(keyword))) {
                         const completed = goal.todos.filter(t => t.completed).length;
                         const total = goal.todos.length;
                         contextPieces.push(`- A goal the user is working on: "${goal.title}" (Progress: ${completed}/${total} tasks complete)`);
                    }
                });
            }

            // Add knowledge to the context ONLY if they are relevant
            const knowledge = loadData(getUserKey(KNOWLEDGE_KEY), []);
            if (knowledge.length > 0) {
                knowledge.forEach(item => {
                    const lowerCaseKnowledge = item.content.toLowerCase();
                    if (messageKeywords.some(keyword => lowerCaseKnowledge.includes(keyword))) {
                         contextPieces.push(`- A fact from the user's knowledge base: "${item.content}"`);
                    }
                });
            }
            
            // Add notes and reminders contextually based on keywords
            const triggerWords = ['note', 'reminder', 'about my'];
            if (triggerWords.some(word => lowerCaseMessage.includes(word))) {
                const notes = loadData(getUserKey(NOTES_KEY), []);
                const reminders = loadData(getUserKey(REMINDERS_KEY), []);

                if (notes.length > 0) {
                    notes.forEach(note => {
                        const lowerCaseNote = note.content.toLowerCase();
                        if (messageKeywords.some(keyword => lowerCaseNote.includes(keyword))) {
                            contextPieces.push(`- From the user's notes: "${note.content}"`);
                        }
                    });
                }

                if (reminders.length > 0) {
                    reminders.forEach(reminder => {
                        const lowerCaseReminder = reminder.content.toLowerCase();
                        if (messageKeywords.some(keyword => lowerCaseReminder.includes(keyword))) {
                            contextPieces.push(`- From the user's reminders: "${reminder.content}" (Scheduled for: ${new Date(reminder.schedule).toLocaleString()})`);
                        }
                    });
                }
            }

            if (contextPieces.length > 0) {
                return `[AI CONTEXT BLOCK]\nYou have the following important context about the user:\n${contextPieces.join('\n')}\n[/AI CONTEXT BLOCK]\n\n`;
            }
            return '';
        }
		
		
		
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // --- Core Chat Logic ---
        async function handleMessage(message, source) {
            if (!message.trim() && !window.uploadedFileObject) return; // Allow sending if only a file is attached
            
			userActivatedAudio = true; 
            textInput.value = ''; 
            
            const normalizedMessage = message.toLowerCase().trim();

            // --- FIX: ALL COMMANDS THAT SHOULD *NOT* POST A USER MESSAGE FIRST GO HERE ---

            const scanTrigger = SCAN_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (scanTrigger) {
                // This logic determines the *actual* prompt to be sent with the image
                let prompt = message; // Default to the full message, e.g., "scan this document for keywords"
                if (SCAN_COMMANDS.includes(normalizedMessage)) { 
                    // If it's an exact, short command like "what do you see" or "scan this"
                    prompt = "Please describe what you see in this image."; // Use a clear, default prompt
                }
                autoScanPrompt = prompt; // Set the global prompt
                openCamera(true); // Open camera for auto-scan
                return; // Return *before* adding the "what do you see" message to the chat
            }
            
            // ===== START: NEW CAMERA COMMAND CHECK =====
            // ===== START: MODIFIED CAMERA/SCAN COMMANDS =====
            const cameraTrigger = CAMERA_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (cameraTrigger) {
                // This is just a manual "open camera"
                autoScanPrompt = null; // Ensure it's null
                openCamera(false); // Pass 'false' for manual
                return; // Return *before* adding the "open camera" message to the chat
            }
            // ===== END: MODIFIED CAMERA/SCAN COMMANDS =====
            // ===== END: NEW CAMERA COMMAND CHECK =====

            // --- IF IT'S NOT A SCAN COMMAND, *NOW* WE ADD THE USER MESSAGE TO THE CHAT ---
            
            // Create a temporary attachment object to display, if a file is present
            let attachmentForDisplay = null;
            if (uploadedFileContent && window.uploadedFileObject) {
                 attachmentForDisplay = {
                    type: window.uploadedFileObject.type,
                    content: uploadedFileContent
                 };
            }
            
            // Display the user's message and attachment immediately
            // This is the *only* place a user message should be added.
            // The auto-scan will call handleMessage again, and *that* call will run this line.
            addMessageToChat(message, 'user', false, true, attachmentForDisplay);
            // --- END OF CHAT ADDITION ---
						
            // --- CHECK FOR ALL *OTHER* COMMANDS (that should return after posting) ---

            const briefingTrigger = BRIEFING_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (briefingTrigger) {
                triggerBriefing();
                return;
            }
            
            const reviewTrigger = REVIEW_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (reviewTrigger) {
                triggerWeeklyReview();
                return;
            }
			
			// --- THIS IS THE NEW BLOCK TO ADD ---
            const synthesisTrigger = SYNTHESIS_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (synthesisTrigger) {
                // Extract the rest of the message as the synthesis prompt
                const synthesisPrompt = message.substring(synthesisTrigger.length).trim();
                
                if (synthesisPrompt) {
                    // Call the synthesis function directly with your request
                    runSynthesis(synthesisPrompt);
                } else {
                    // Handle vague commands
                    addMessageToChat("It sounds like you want me to run an analysis, but I need more details. What would you like me to analyze?", 'helen');
                }
                return; // Stop here, don't send to standard chat
            }

            // Handle "remember that" command
            if (REMEMBER_COMMANDS.find(c => normalizedMessage.startsWith(c))) {
                const command = REMEMBER_COMMANDS.find(c => normalizedMessage.startsWith(c));
                const memoryContent = message.substring(command.length).trim();
                if (memoryContent) {
                   // addMessageToChat(message, 'user');
                    const memories = loadData(getUserKey(MEMORIES_KEY), []);
                    memories.unshift({ content: memoryContent, timestamp: new Date().toISOString() });
                    saveData(getUserKey(MEMORIES_KEY), memories);
                    addMessageToChat(`Got it, I'll remember that: "${memoryContent}"`, 'helen');
                    showNotification("New memory saved!", "success");
                } else {
                  //  addMessageToChat(message, 'user');
                    addMessageToChat("What would you like me to remember? Just say 'remember that' followed by the fact.", 'helen');
                }
                return;
            }

            // Handle preference commands
            const preferenceTrigger = PREFERENCE_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (preferenceTrigger) {
                const preferenceContent = message.substring(preferenceTrigger.length).trim();
                if (preferenceContent) {
                   // addMessageToChat(message, 'user');
                    const preferences = loadData(getUserKey(PREFERENCES_KEY), []);
                    preferences.unshift({ content: preferenceContent, timestamp: new Date().toISOString() });
                    saveData(getUserKey(PREFERENCES_KEY), preferences);
                    addMessageToChat(`That's cool! I'll remember that you like ${preferenceContent}.`, 'helen');
                    showNotification("New preference saved!", "success");
                } else {
                   // addMessageToChat(message, 'user');
                    addMessageToChat("What is it that you like? Please tell me!", 'helen');
                }
                return;
            }

            // Handle people commands
            const peopleTrigger = PEOPLE_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (peopleTrigger) {
                const personContent = message.substring(peopleTrigger.length).trim();
                if (personContent) {
                    //addMessageToChat(message, 'user');
                    const people = loadData(getUserKey(PEOPLE_KEY), []);
                    const firstPersonBonusAwarded = loadData(getUserKey(BONUS_FIRST_PERSON_KEY), false);
                    const fullFact = `${peopleTrigger.replace("my ", "").replace("'s name is", "")} is ${personContent}`;
                    people.unshift({ content: fullFact, timestamp: new Date().toISOString() });
                    saveData(getUserKey(PEOPLE_KEY), people);
                    addMessageToChat(`Okay, I'll remember that.`, 'helen');
                    showNotification("New person/fact saved!", "success");

                    if (!firstPersonBonusAwarded) {
                        addPoints(50);
                        showNotification("Feature Discovery! +50 points for adding your first person.", "success");
                        saveData(getUserKey(BONUS_FIRST_PERSON_KEY), true);
                    }
                } else {
                  //  addMessageToChat(message, 'user');
                    addMessageToChat("Who are you referring to?", 'helen');
                }
                return;
            }

            // Handle goal commands
            const goalTrigger = GOAL_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (goalTrigger) {
                const goalContent = message.substring(goalTrigger.length).trim();
                if (goalContent) {
                    //addMessageToChat(message, 'user');
                    const goals = loadData(getUserKey(GOALS_KEY), []);
                    const firstGoalBonusAwarded = loadData(getUserKey(BONUS_FIRST_GOAL_KEY), false);
                    goals.unshift({ id: `goal_${Date.now()}`, title: goalContent, todos: [] });
                    saveData(getUserKey(GOALS_KEY), goals);
                    addMessageToChat(`Excellent goal! I've added "${goalContent}" to your projects. Let's make it happen.`, 'helen');
                    showNotification("New goal added!", "success");

                    if (!firstGoalBonusAwarded) {
                        addPoints(50);
                        showNotification("Feature Discovery! +50 points for creating your first goal.", "success");
                        saveData(getUserKey(BONUS_FIRST_GOAL_KEY), true);
                    }
                } else {
                   // addMessageToChat(message, 'user');
                    addMessageToChat("What goal are you setting for yourself?", 'helen');
                }
                return;
            }

            // Handle journal commands
            const journalTrigger = JOURNAL_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (journalTrigger) {
                const journalContent = message.substring(journalTrigger.length).trim();
                if (journalContent) {
                  //  addMessageToChat(message, 'user');
                    const journal = loadData(getUserKey(JOURNAL_KEY), []);
                    const firstJournalBonusAwarded = loadData(getUserKey(BONUS_FIRST_JOURNAL_KEY), false);
                    journal.unshift({ id: `journal_${Date.now()}`, content: journalContent, timestamp: new Date().toISOString() });
                    saveData(getUserKey(JOURNAL_KEY), journal);
                    addMessageToChat(`I've saved that to your journal for today.`, 'helen');
                    showNotification("New journal entry added!", "success");

                    if (!firstJournalBonusAwarded) {
                        addPoints(50);
                        showNotification("Feature Discovery! +50 points for your first journal entry.", "success");
                        saveData(getUserKey(BONUS_FIRST_JOURNAL_KEY), true);
                    }
                } else {
                  //  addMessageToChat(message, 'user');
                    addMessageToChat("What would you like to add to your journal?", 'helen');
                }
                return;
            }

            // Handle knowledge base commands
            const knowledgeTrigger = KNOWLEDGE_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (knowledgeTrigger) {
                const knowledgeContent = message.substring(knowledgeTrigger.length).trim();
                if (knowledgeContent) {
                   // addMessageToChat(message, 'user');
                    const knowledge = loadData(getUserKey(KNOWLEDGE_KEY), []);
                    knowledge.unshift({ id: `knowledge_${Date.now()}`, content: knowledgeContent, timestamp: new Date().toISOString() });
                    saveData(getUserKey(KNOWLEDGE_KEY), knowledge);
                    addMessageToChat(`Interesting! I've added that to your knowledge base.`, 'helen');
                    showNotification("New fact added to knowledge base!", "success");
                } else {
                  //  addMessageToChat(message, 'user');
                    addMessageToChat("What would you like to add to your knowledge base?", 'helen');
                }
                return;
            }

            // Handle Idea Board command
            const ideaBoardTrigger = IDEA_BOARD_COMMANDS.find(cmd => normalizedMessage.startsWith(cmd));
            if (ideaBoardTrigger) {
                const boardName = message.substring(ideaBoardTrigger.length).trim();
                if (boardName) {
                 //   addMessageToChat(message, 'user');
                    const newBoard = {
                        id: `board_${Date.now()}`,
                        title: boardName,
                        createdAt: new Date().toISOString(),
                        columns: [
                            { id: `col_${Date.now()}_1`, title: 'Raw Ideas', cards: [] },
                            { id: `col_${Date.now()}_2`, title: 'Exploring', cards: [] },
                            { id: `col_${Date.now()}_3`, title: 'Actionable', cards: [] }
                        ]
                    };
                    const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
                    boards.unshift(newBoard);
                    saveData(getUserKey(IDEA_BOARDS_KEY), boards);
                    addMessageToChat(`Okay, I've created a new brainstorming board called "${boardName}". You can find it in the Idea Hub.`, 'helen');
                    showNotification("New idea board created!", "success");
                } else {
                   // addMessageToChat(message, 'user');
                    addMessageToChat("What would you like to name the new board?", 'helen');
                }
                return;
            }
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////           
            if (normalizedMessage === BROWSER_BACK_COMMAND) {
                // addMessageToChat(message, 'user'); // Already added
                addMessageToChat("Going back to the previous page.", 'helen');
                window.history.back();
                return;
            }

            if (normalizedMessage === BROWSER_FORWARD_COMMAND) {
                // addMessageToChat(message, 'user'); // Already added
                addMessageToChat("Going forward to the next page.", 'helen');
                window.history.forward();
                return;
            }

            if (normalizedMessage === BROWSER_SCROLL_DOWN_COMMAND) {
                // addMessageToChat(message, 'user'); // Already added
                addMessageToChat("Scrolling down.", 'helen');
                window.scrollBy(0, window.innerHeight / 2);
                return;
            }

            if (normalizedMessage === BROWSER_SCROLL_UP_COMMAND) {
                // addMessageToChat(message, 'user'); // Already added
                addMessageToChat("Scrolling up.", 'helen');
                window.scrollBy(0, -window.innerHeight / 2);
                return;
            }

            if (BROWSER_GOTO_COMMANDS.find(c => normalizedMessage.startsWith(c))) {
                const command = BROWSER_GOTO_COMMANDS.find(c => normalizedMessage.startsWith(c));
                const website = message.substring(command.length).trim().replace(/\s/g, '');
                if (website) {
                    // addMessageToChat(message, 'user'); // Already added
                    addMessageToChat(`Navigating to ${website}`, 'helen');
                    window.open(`https://${website}`, '_blank');
                } else {
                    // addMessageToChat(message, 'user'); // Already added
                    addMessageToChat("Please specify a website to go to, for example: 'go to google.com'", 'helen');
                }
                return;
            }

            if (OPEN_WHATSAPP_COMMANDS.find(c => normalizedMessage.includes(c))) {
                // addMessageToChat(message, 'user'); // Already added
                addMessageToChat(`Opening WhatsApp Web for you now.`, 'helen');
                window.open("https://web.whatsapp.com/", "_blank");
                textInput.value = '';
                return;
            }
            
            if (SEARCH_COMMANDS.find(c => normalizedMessage.startsWith(c))) {
                const command = SEARCH_COMMANDS.find(c => normalizedMessage.startsWith(c));
                const query = message.substring(command.length).trim();
                if (query) {
                    // addMessageToChat(message, 'user'); // Already added
                    const googleSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                    window.open(googleSearchUrl, "_blank");
                    addMessageToChat(`Searching Google for "${query}".`, 'helen');
                } else {
                    // addMessageToChat(message, 'user'); // Already added
                    addMessageToChat(`What would you like me to search for? Please say "search this" followed by your query.`, 'helen');
                }
                textInput.value = '';
                return;
            }

           // --- IF NO COMMANDS MATCHED, IT'S A NORMAL CHAT. PROCEED TO API ---
            addPoints(10);
            textInput.value = '';
            userActivatedAudio = true;
            
            const avatar = document.querySelector('.centered-image'); // Define avatar first
            avatar.classList.add('thinking'); // Start the 'thinking' pulse
			
			goLiveBtn.classList.add('thinking'); // <-- 1. ADD THIS LINE

            const typingIndicatorDiv = document.createElement('div');
            typingIndicatorDiv.classList.add('helen-message', 'typing-indicator');
            typingIndicatorDiv.innerHTML = '<span></span><span></span><span></span>';
            chatDisplay.appendChild(typingIndicatorDiv);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
			
			
			if (!GEMINI_API_KEY) {
                chatDisplay.removeChild(typingIndicatorDiv);
                avatar.classList.remove('thinking');
                addMessageToChat(
                    "I'm missing my API key. Please go to the **Settings** menu (??) to add your Google Gemini API key.", 
                    'helen', 
                    true
                );
                return; // Stop the function
            }
			
			

            try {
                const context = getContextForMessage(message);
                let tempApiHistory = JSON.parse(JSON.stringify(chatHistory));
                const lastMessage = tempApiHistory[tempApiHistory.length - 1];
				
				
				
				// --- NEW: Load personality growth and add it to the system prompt ---
                const growthInsights = loadData(getUserKey(PERSONALITY_GROWTH_KEY), []);
                let finalSystemPrompt = SYSTEM_PROMPT; // This is her base persona
                
                if (growthInsights.length > 0) {
                    const growthLog = growthInsights.join('\n- ');
                    finalSystemPrompt += `
                    
          [PERSONALITY GROWTH LOG]
           The following are personal insights and resolutions I have learned based on my user's feedback. I must always follow these:
           - ${growthLog}
            [END LOG]`;
                }
                // --- END OF NEW BLOCK ---
				
				

                // MODIFIED: This is the core logic for multimodal input
                if (uploadedFileContent && window.uploadedFileObject) {
                    const file = window.uploadedFileObject;

                    if (file.type.startsWith('image/')) {
                        // For images, construct a multi-part message
                        const imagePart = {
                            inlineData: {
                                mimeType: file.type,
                                // Strip the "data:mime/type;base64," prefix
                                data: uploadedFileContent.split(',')[1]
                            }
                        };
                        // Add the image part to the user's message
                        lastMessage.parts.push(imagePart);
                    } else {
                        // This is the existing logic for text files
                        const fileContextPrompt = `[START OF UPLOADED DOCUMENT]\n\n${uploadedFileContent}\n\n[END OF UPLOADED DOCUMENT]\n\nBased on the document provided above, please answer the following user prompt:\n\n`;
                        lastMessage.parts[0].text = fileContextPrompt + lastMessage.parts[0].text;
                    }
                    // Clear the file after preparing the payload
                    clearUploadedFile();
                }

                if (context && lastMessage.role === 'user') {
                    lastMessage.parts[0].text = context + lastMessage.parts[0].text;
                }

                const cleanedApiHistory = tempApiHistory.map(({ role, parts }) => ({ role, parts }));
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                const payload = {
                    contents: cleanedApiHistory,
                     systemInstruction: {
                        role: "system",
                        parts: [{ text: finalSystemPrompt }] // <-- Use the new dynamic prompt
                    }
                };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
				
                const result = await response.json();
    
                chatDisplay.removeChild(typingIndicatorDiv);
                // This line was missing, now it's here.
                avatar.classList.remove('thinking'); // <<< FIX for the successful case
                goLiveBtn.classList.remove('thinking'); // <-- **ADD THIS LINE**

                if (!response.ok || !result.candidates || result.candidates.length === 0) {
                    // Check for a specific "blocked" error
                    if (result.candidates && result.candidates[0].finishReason === 'SAFETY') {
                        throw new Error('The response was blocked due to safety settings.');
                    }
                    throw new Error(result.error?.message || 'API call failed with no error message.');
                }

                const geminiResponse = result.candidates[0].content.parts[0].text;
                addMessageToChat(geminiResponse, 'helen');
                
            } catch (error) {
                console.error('Error fetching from Gemini API:', error);
                chatDisplay.removeChild(typingIndicatorDiv);
                avatar.classList.remove('thinking'); // This part you already fixed correctly.
                goLiveBtn.classList.remove('thinking'); // <-- **ADD THIS LINE**
                
                let errorMessage = "Sorry, I'm having trouble connecting right now. Please try again later.";
                if (error.message.includes('safety')) {
                    errorMessage = "I'm sorry, I can't provide a response to that.";
                } else if (error.message.includes('API key')) {
                     errorMessage = "My API key seems to be invalid. Please check it in the settings.";
                }
                
                addMessageToChat(errorMessage, 'helen', true);
            }
        }
		
		
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////       
        function saveCurrentChat() {
            if (chatHistory.length > 0) {
                if (currentChatIndex !== -1 && allChatSessions[currentChatIndex]) {
                    allChatSessions[currentChatIndex].history = chatHistory;
                } else {
                    allChatSessions.push({
                        title: `Chat on ${new Date().toLocaleString()}`,
                        history: chatHistory
                    });
                    currentChatIndex = allChatSessions.length - 1;
                }
                saveData(getUserKey(ALL_CHATS_KEY), allChatSessions);
            }
        }
        
        function startNewChat() {
            saveCurrentChat();
            chatHistory = [];
            currentChatIndex = -1;
            chatDisplay.innerHTML = '';
            const userName = getUserName();
            const welcomeMessage = userName ? `Welcome back, ${userName}. How can I help you today?` : "Hello there! My name is Helen. How can I assist you?";
            addMessageToChat(welcomeMessage, 'helen', false, false);
        }
        
        function loadSpecificChat(chatIndex) {
            hideAllSidebars();
            if (chatIndex >= 0 && chatIndex < allChatSessions.length) {
                saveCurrentChat();
                currentChatIndex = chatIndex;
                chatHistory = [...allChatSessions[currentChatIndex].history];
                chatDisplay.innerHTML = '';
				
               chatHistory.forEach(msg => {
    // --- START FIX ---
    // 1. Translate 'model' back to 'helen' so buttons appear
    const sender = msg.role === 'model' ? 'helen' : 'user'; 

    // 2. Pass the saved attachment (or null if it doesn't exist)
    const attachment = msg.attachment || null; 

    displayMessage(msg.parts[0].text, sender, msg.timestamp, false, false, attachment);
    // --- END FIX ---
});
            }
        }
        
        function loadPastChats() {
            pastChatsList.innerHTML = '';
            allChatSessions.forEach((chat, index) => {
                const firstMessageTime = chat.history[0]?.timestamp ? new Date(chat.history[0].timestamp).toLocaleString() : "No date";
                
                const chatItem = document.createElement('div');
                chatItem.classList.add('past-chat-item');
                chatItem.dataset.index = index;
                chatItem.innerHTML = `
                    <div class="chat-title">${chat.title}</div>
                    <div class="chat-summary" id="summary-${index}"></div>
                    <div class="chat-timestamp text-xs text-[var(--text-secondary)]">${firstMessageTime}</div>
                    <div class="past-chat-actions">
                        <button class="summarize-btn" data-index="${index}">? Summarize</button>
                    </div>
                `;
                chatItem.querySelector('.chat-title').addEventListener('click', () => loadSpecificChat(index));
                pastChatsList.appendChild(chatItem);
            });

            document.querySelectorAll('.summarize-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const index = e.target.dataset.index;
                    summarizeChat(index);
                });
            });
        }

        async function summarizeChat(chatIndex) {
            const button = document.querySelector(`.summarize-btn[data-index="${chatIndex}"]`);
            const summaryDiv = document.getElementById(`summary-${chatIndex}`);
            if (!button || !summaryDiv) return;

            button.textContent = "Summarizing...";
            button.disabled = true;

            try {
                const chatToSummarize = allChatSessions[chatIndex];
                const formattedHistory = chatToSummarize.history.map(msg => `${msg.role === 'user' ? 'You' : 'Helen'}: ${msg.parts[0].text}`).join('\n');
                
                const prompt = `Please provide a concise, one-sentence summary of the following conversation:\n\n${formattedHistory}`;

                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }]
                };

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (!response.ok || !result.candidates || result.candidates.length === 0) {
                    throw new Error(result.error?.message || 'Failed to get summary.');
                }

                const summaryText = result.candidates[0].content.parts[0].text;
                summaryDiv.textContent = summaryText;

            } catch (error) {
                summaryDiv.textContent = `Error: ${error.message}`;
                console.error("Summarization error:", error);
            } finally {
                button.textContent = "? Summarize";
                button.disabled = false;
            }
        }

        async function generateBriefing() {
            const now = new Date(); 
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            // 1. Get Reminders
            const reminders = loadData(getUserKey(REMINDERS_KEY), []);
            let upcomingReminders = [];
            reminders.forEach(r => {
                const reminderDate = new Date(r.schedule);
                if (!r.completed && reminderDate >= today) {
                    upcomingReminders.push(r.content);
                }
            });
            const reminderSummary = upcomingReminders.length > 0 ? `You have ${upcomingReminders.length} upcoming reminder(s): ${upcomingReminders.join(', ')}.` : "You have no upcoming reminders.";

            // 2. Get Goals
            const goals = loadData(getUserKey(GOALS_KEY), []);
            let goalSummary = "You don't have any active goals right now.";
            if (goals.length > 0) {
                const totalGoals = goals.length;
                let completedGoals = 0;
                let highProgressGoal = null;

                goals.forEach(g => {
                    const totalTodos = g.todos.length;
                    if (totalTodos > 0) {
                        const completedTodos = g.todos.filter(t => t.completed).length;
                        const progress = (completedTodos / totalTodos) * 100;
                        if (progress === 100) {
                            completedGoals++;
                        } else if (!highProgressGoal || progress > highProgressGoal.progress) {
                            highProgressGoal = { title: g.title, progress: Math.round(progress) };
                        }
                    }
                });
                goalSummary = `You have ${totalGoals} goal(s) in total. ${completedGoals} are completed.`;
                if (highProgressGoal) {
                    goalSummary += ` You are making great progress on '${highProgressGoal.title}', which is ${highProgressGoal.progress}% complete!`;
                }
            }
            
            // 3. Get Habits
            const habits = loadData(getUserKey(HABITS_KEY), []);
            let habitSummary = "";
            if (habits.length > 0) {
                const todayStr = today.toISOString().split('T')[0];
                const completedToday = habits.filter(h => h.completions.includes(todayStr)).length;
                habitSummary = `You've completed ${completedToday} of your ${habits.length} daily habits so far.`;
            }

            // 4. Get Journal
            const journal = loadData(getUserKey(JOURNAL_KEY), []);
            let journalSummary = "You haven't started a journal yet.";
            if (journal.length > 0) {
                const lastEntryDate = new Date(journal[0].timestamp);
                const timeDiff = today.getTime() - new Date(lastEntryDate.getFullYear(), lastEntryDate.getMonth(), lastEntryDate.getDate()).getTime();
                const daysSinceLastEntry = Math.floor(timeDiff / (1000 * 3600 * 24));

                if (daysSinceLastEntry === 0) {
                    journalSummary = "You wrote in your journal today. Great job staying consistent!";
                } else if (daysSinceLastEntry === 1) {
                    journalSummary = "Your last journal entry was yesterday.";
                } else {
                    journalSummary = `Your last journal entry was ${daysSinceLastEntry} days ago.`;
                }
            }

            // 5. Assemble prompt for Gemini
            const briefingData = `
                Today's Date: ${today.toDateString()}
                Upcoming Reminders: ${reminderSummary}
                Goals Status: ${goalSummary}
                Habit Status: ${habitSummary}
                Journal Status: ${journalSummary}
            `;

            const briefingPrompt = `You are Helen, providing a daily briefing. Based on the following data, compose a warm, friendly, and encouraging summary for the user. Speak in a conversational first-person tone. Keep it concise. Here is the data:\n\n${briefingData}`;

            // 6. Call Gemini API
            const payload = {
                contents: [{ role: "user", parts: [{ text: briefingPrompt }] }],
                 systemInstruction: {
                    role: "system",
                    parts: [{ text: SYSTEM_PROMPT }]
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error('API call failed for briefing.');
            }
            const result = await response.json();
            return result.candidates[0].content.parts[0].text;
        }
        
        async function triggerBriefing() {
            hideAllSidebars();
            const timestamp = new Date().toISOString();
            addMessageToChat("Of course. Generating your daily briefing now...", 'helen', false, false);
            
            const typingIndicatorDiv = document.createElement('div');
            typingIndicatorDiv.classList.add('helen-message', 'typing-indicator');
            typingIndicatorDiv.innerHTML = '<span></span><span></span><span></span>';
            chatDisplay.appendChild(typingIndicatorDiv);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;

            try {
                const briefingText = await generateBriefing();
                chatDisplay.removeChild(typingIndicatorDiv);
                addMessageToChat(briefingText, 'helen');
            } catch (error) {
                console.error("Error generating briefing:", error);
                chatDisplay.removeChild(typingIndicatorDiv);
                addMessageToChat("Sorry, I had trouble putting your briefing together. Please try again.", 'helen', true);
            }
        }

        async function generateWeeklyReview() {
            const now = new Date();
            const sevenDaysAgo = new Date(now);
            sevenDaysAgo.setDate(now.getDate() - 7);

            // 1. Analyze Goals
            const goals = loadData(getUserKey(GOALS_KEY), []);
            let goalSummary = "You didn't have any tracked goals this past week.";
            if (goals.length > 0) {
                // Since we don't timestamp to-do completions, we'll summarize the current state.
                const activeGoals = goals.filter(g => g.todos.some(t => !t.completed));
                const completedGoalCount = goals.length - activeGoals.length;
                goalSummary = `You have ${goals.length} total goals. ${completedGoalCount} are fully completed.`;
                if (activeGoals.length > 0) {
                     goalSummary += ` You are currently working on ${activeGoals.length} of them.`
                }
            }

            // 2. Analyze Habits
            const habits = loadData(getUserKey(HABITS_KEY), []);
            let habitSummary = "No habits were tracked this week.";
            if (habits.length > 0) {
                let completionsThisWeek = 0;
                let mostConsistentHabit = { text: 'None', count: 0 };

                habits.forEach(habit => {
                    const weeklyCompletions = habit.completions.filter(c => new Date(c) >= sevenDaysAgo).length;
                    completionsThisWeek += weeklyCompletions;
                    if (weeklyCompletions > mostConsistentHabit.count) {
                        mostConsistentHabit = { text: habit.text, count: weeklyCompletions };
                    }
                });
                habitSummary = `You completed your habits a total of ${completionsThisWeek} times. Your most consistent habit was '${mostConsistentHabit.text}', which you did ${mostConsistentHabit.count} times.`;
            }

            // 3. Analyze Journal for themes
            const journal = loadData(getUserKey(JOURNAL_KEY), []);
            let journalSummary = "There were no journal entries this week.";
            const entriesThisWeek = journal.filter(entry => new Date(entry.timestamp) >= sevenDaysAgo);
            if (entriesThisWeek.length > 0) {
                let allText = entriesThisWeek.map(e => e.content).join(' ');
                const words = allText.toLowerCase().match(/\b(\w+)\b/g) || [];
                const stopWords = new Set(['the', 'a', 'an', 'is', 'in', 'it', 'and', 'of', 'to', 'i', 'was', 'my', 'for', 'on', 'with', 'that', 'this']);
                const freqMap = {};
                words.forEach(word => {
                  if (!stopWords.has(word) && word.length > 3) {
                    freqMap[word] = (freqMap[word] || 0) + 1;
                  }
                });
                const sortedKeywords = Object.keys(freqMap).sort((a, b) => freqMap[b] - freqMap[a]);
                const topKeywords = sortedKeywords.slice(0, 3).join(', ');
                journalSummary = `You wrote in your journal ${entriesThisWeek.length} time(s). Common themes seemed to be: ${topKeywords || 'N/A'}.`;
            }
            
            const reviewData = `
                Goals Status: ${goalSummary}
                Habit Status: ${habitSummary}
                Journal Status: ${journalSummary}
            `;
            const reviewPrompt = `You are Helen, providing a weekly review. Based on the following user activity from the past 7 days, generate a friendly, insightful, and encouraging summary. Congratulate them on their successes and highlight their key areas of focus. Speak in a conversational first-person tone. Here is the data:\n\n${reviewData}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: reviewPrompt }] }],
                systemInstruction: { role: "system", parts: [{ text: SYSTEM_PROMPT }] }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error('API call failed for weekly review.');
            const result = await response.json();
            return result.candidates[0].content.parts[0].text;
        }

        async function triggerWeeklyReview() {
            hideAllSidebars();
            addMessageToChat("Let's see how your week went! Analyzing your progress now...", 'helen', false, false);
            
            const typingIndicatorDiv = document.createElement('div');
            typingIndicatorDiv.classList.add('helen-message', 'typing-indicator');
            typingIndicatorDiv.innerHTML = '<span></span><span></span><span></span>';
            chatDisplay.appendChild(typingIndicatorDiv);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;

            try {
                const reviewText = await generateWeeklyReview();
                chatDisplay.removeChild(typingIndicatorDiv);
                addMessageToChat(reviewText, 'helen');
            } catch (error) {
                console.error("Error generating weekly review:", error);
                chatDisplay.removeChild(typingIndicatorDiv);
                addMessageToChat("I seem to be having trouble analyzing your week. Please try again in a bit.", 'helen', true);
            }
        }


        // --- Event Listeners ---
        window.addEventListener('load', () => {
            const savedUser = loadData(CURRENT_USER_KEY, null);
            if (savedUser && getUsers()[savedUser]) {
                currentUser = savedUser;
                setUserName(savedUser);
                showMainApp();
            } else {
                showLoginScreen();
            }
			
			// Inside the load event listener
        const pendingQuestion = loadData(getUserKey('pending_thought_provoker_question'), null);

        if (pendingQuestion) {
    // If a question was generated in the background, add it to the chat
             addMessageToChat(pendingQuestion, 'helen', false, true);
    // Clear it so it doesn't appear again
            localStorage.removeItem(getUserKey('pending_thought_provoker_question'));
                             }
			
        });

           goLiveBtn.addEventListener('click', () => {
            userActivatedAudio = true;

            // This is the new line that toggles the focus mode
            document.body.classList.toggle('focus-mode'); 

            if (isListening) {
                // It's currently live, so stop it
                stopListening(true); // <-- MODIFICATION: Pass true
            } else {
                // It's not live, so start it
                startListening(true); // <-- MODIFICATION: Pass true
            }
        });

        micButton.addEventListener('click', () => {
            userActivatedAudio = true;

            // This is the new line that toggles the focus mode
            // document.body.classList.toggle('focus-mode'); // <-- MODIFICATION: This line is removed

            if (isListening) stopListening(false); // <-- MODIFICATION: Pass false
            else startListening(false); // <-- MODIFICATION: Pass false
        });

        sendButton.addEventListener('click', () => {
            handleMessage(textInput.value, 'text');
            textInput.focus();
        });

        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleMessage(textInput.value, 'text');
            }
        });

        personaSelect.addEventListener('change', () => {
            const selectedPersona = personaSelect.value;
            SYSTEM_PROMPT = PERSONAS[selectedPersona] || DEFAULT_SYSTEM_PROMPT;
            saveData(getUserKey(PERSONA_KEY), selectedPersona);
            const personaName = personaSelect.options[personaSelect.selectedIndex].text;
            showNotification(`Persona updated to: ${personaName}`, 'success');
        });
		
		// --- ADD THIS NEW LISTENER ---
        mobileMicModeSelect.addEventListener('change', () => {
            const newMode = mobileMicModeSelect.value;
            isMobileMicMode = (newMode === 'mobile');
            saveData(getUserKey(MOBILE_MIC_MODE_KEY), newMode);
            showNotification(`Mic mode set to: ${newMode}. Please restart the mic to apply.`, 'info');
            // Force-stop listening so the new mode applies on next click
            if (isListening) {
                stopListening(goLiveBtn.classList.contains('live'));
            }
        });
        // --- END OF NEW LISTENER ---
		

        menuOptionBriefing.addEventListener('click', () => triggerBriefing());
        menuOptionReview.addEventListener('click', () => triggerWeeklyReview());
		
		
		menuOptionSynthesis.addEventListener('click', () => {
    hideAllSidebars();
    setTimeout(() => toggleSidebar('synthesis-manager', true), 300);
       });

synthesisManagerCloseBtn.addEventListener('click', () => toggleSidebar('synthesis-manager', false));

runSynthesisBtn.addEventListener('click', () => {
    const userRequest = synthesisInput.value.trim();
    if (userRequest) {
        hideAllSidebars();
        runSynthesis(userRequest);
    } else {
        showNotification("Please enter a request for the analysis.", "error");
    }
});
		
    function gatherSynthesisData() {
    const notes = loadData(getUserKey(NOTES_KEY), []);
    const journal = loadData(getUserKey(JOURNAL_KEY), []);
    const goals = loadData(getUserKey(GOALS_KEY), []);
    const preferences = loadData(getUserKey(PREFERENCES_KEY), []);
    const memories = loadData(getUserKey(MEMORIES_KEY), []);

    // We only need the content, not all the metadata
    return {
        notes: notes.map(n => n.content),
        journal: journal.map(j => j.content),
        goals: goals.map(g => ({ title: g.title, todos: g.todos.map(t => t.text) })),
        preferences: preferences.map(p => p.content),
        memories: memories.map(m => m.content)
    };  
  }
 



	///////////////////////////////////////////////////////////////////////////	
		async function runSynthesis(userRequest) {
    // Let the user know you're working on it
    addMessageToChat(`Running synthesis for: "${userRequest}"`, 'helen');
    
    const typingIndicatorDiv = document.createElement('div');
    typingIndicatorDiv.classList.add('helen-message', 'typing-indicator');
    typingIndicatorDiv.innerHTML = '<span></span><span></span><span></span>';
    chatDisplay.appendChild(typingIndicatorDiv);
    chatDisplay.scrollTop = chatDisplay.scrollHeight;

    const allData = gatherSynthesisData();
    
    const synthesisPrompt = `
    You are an AI assistant performing a deep synthesis task. Analyze the following JSON data sets provided by the user to give an insightful and thoughtful answer to their specific request. Look for hidden patterns, connections, and underlying themes.

    THE USER'S REQUEST:
    "${userRequest}"

    ---
    DATASET 1: JOURNAL ENTRIES
    ${JSON.stringify(allData.journal)}
    ---
    DATA-SET 2: NOTES
    ${JSON.stringify(allData.notes)}
    ---
    DATA-SET 3: GOALS & PROJECTS
    ${JSON.stringify(allData.goals)}
    ---
    DATA-SET 4: USER PREFERENCES & HOBBIES
    ${JSON.stringify(allData.preferences)}
    ---
    DATA-SET 5: KEY MEMORIES
    ${JSON.stringify(allData.memories)}
    ---

    Based on a holistic analysis of ALL the provided data, please provide a well-structured and creative response to the user's request.
    `;

    try {
        const payload = {
            contents: [{ role: "user", parts: [{ text: synthesisPrompt }] }],
            systemInstruction: {
                role: "system",
                parts: [{ text: SYSTEM_PROMPT }]
            }
        };

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        chatDisplay.removeChild(typingIndicatorDiv);

        if (!response.ok) throw new Error('API call failed during synthesis.');

        const result = await response.json();
        const analysis = result.candidates[0].content.parts[0].text;

        addMessageToChat(analysis, 'helen');

    } catch (error) {
        chatDisplay.removeChild(typingIndicatorDiv);
        console.error("Error during synthesis:", error);
        addMessageToChat("I'm sorry, I encountered an error while analyzing your data. Please try again.", 'helen', true);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
		
		
		// ===== START: MODIFIED openCamera FUNCTION =====
async function openCamera(isAutoScan = false) { // <-- Modified signature
    hideAllSidebars();
    
	
	// --- NEW FIX: Pause recognition ---
    if (isListening) {
        console.log("Camera opening, pausing recognition.");
        // We just stop it. 'onend' will fire, see `isListening = false`, 
        // but `shouldBeListening` (the flag for Live Mode) is still true.
        recognition.stop(); 
    }
    // --- END FIX ---
	
	
	
	
    // --- NEW: Load the preferred camera ID from settings ---
    const preferredCameraId = loadData(getUserKey(CAMERA_PREFERENCE_KEY), '');
    
    // Build the "constraints" object to tell the browser which camera we want
    const constraints = {
        video: {
            // If we have a preferred ID, use it (and be "exact"). 
            // Otherwise, 'undefined' lets the browser pick its default.
            deviceId: preferredCameraId ? { exact: preferredCameraId } : undefined
        },
        audio: false
    };
    // --- END NEW BLOCK ---
    
    try {
        // --- MODIFIED: Use the new 'constraints' object ---
        // The original code had '{ video: true, audio: false }' here by mistake
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints); 
        cameraView.srcObject = cameraStream;
        
        // Use 'onloadedmetadata' to ensure video is ready before playing/capturing
        cameraView.onloadedmetadata = () => {
            cameraView.play();
            cameraModal.classList.remove('hidden');

            if (isAutoScan) {
                // Start the countdown
                cameraCountdown.classList.remove('hidden');
                cameraCountdown.textContent = '3';
                setTimeout(() => { cameraCountdown.textContent = '2'; }, 1000);
                setTimeout(() => { cameraCountdown.textContent = '1'; }, 2000);
                setTimeout(() => {
                    cameraCountdown.textContent = '';
                    cameraCountdown.classList.add('hidden');
                    captureImage(); // Automatically capture after 3s
                }, 3000);
            }
        };

    } catch (err) {
        console.error("Error accessing camera:", err);
        if (err.name === "NotAllowedError") {
            addMessageToChat("It looks like you've denied camera permission. You'll need to enable it in your browser settings to use this feature.", 'helen', true);
        } else {
            addMessageToChat("Sorry, I couldn't access your camera. Make sure it's not being used by another app.", 'helen', true);
        }
    }
}
// ===== END: MODIFIED openCamera FUNCTION =====

function closeCamera() {
    if (cameraStream) {
        // Stop all tracks in the stream
        cameraStream.getTracks().forEach(track => track.stop());
    }
    cameraView.srcObject = null;
    cameraStream = null;
    cameraModal.classList.add('hidden');
}

// ===== START: MODIFIED captureImage FUNCTION =====
// ===== START: MODIFIED captureImage FUNCTION =====
async function captureImage() { // --- ADD 'async' ---
    // Set canvas dimensions to match the video
    const videoWidth = cameraView.videoWidth;
    const videoHeight = cameraView.videoHeight;
    cameraCanvas.width = videoWidth;
    cameraCanvas.height = videoHeight;

    const context = cameraCanvas.getContext('2d');
    
    // Flip the canvas context horizontally to match the mirrored video
    context.translate(videoWidth, 0);
    context.scale(-1, 1);
    
    // Draw the current video frame onto the canvas
    context.drawImage(cameraView, 0, 0, videoWidth, videoHeight);

    // Get the image as a Base64 data URL
    const imageData = cameraCanvas.toDataURL('image/jpeg');

    // --- Attach the image to the chat input ---
    uploadedFileContent = imageData;
    // We create a "fake" file object for the system to process
    window.uploadedFileObject = { 
        type: 'image/jpeg', 
        name: `webcam-capture-${Date.now()}.jpg` 
    };
    
    fileStatusIndicator.textContent = `File: ${window.uploadedFileObject.name}`;
    fileStatusContainer.classList.remove('hidden');

    // Close the camera
    closeCamera();
    
    // --- START: MODIFIED AUTO-SEND LOGIC ---
    if (autoScanPrompt) {
        // This was an auto-scan, so send the message
        showNotification("Capture successful! Sending to Helen...", "success");
        await handleMessage(autoScanPrompt, 'text'); // --- ADD 'await' ---
        autoScanPrompt = null; // Reset the flag
    } else {
        // This was a manual capture, just notify
        showNotification("Image captured! Now, what would you like me to do with it?", "success");
        textInput.focus();
    }
    
    // --- NEW FIX: Restart recognition if it was in Live Mode ---
    if (shouldBeListening && !isListening) {
        console.log("Camera capture complete, restarting recognition.");
        try {
            recognition.start();
        } catch(e) { console.error("Error restarting recognition after capture:", e); }
    }
    // --- END FIX ---
}
// ===== END: MODIFIED captureImage FUNCTION =====
// ===== END: MODIFIED captureImage FUNCTION =====






// --- ADD THIS ENTIRE NEW FUNCTION ---
async function populateCameraList() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.warn("enumerateDevices() is not supported.");
        // Hide the setting if the browser doesn't support this
        document.getElementById('camera-settings-section').classList.add('hidden');
        return;
    }

    try {
        // --- PERMISSION TRICK ---
        // We must get *some* permission first to get meaningful device labels.
        // We'll request a stream, get the devices, then immediately stop the stream.
        const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        // Stop the temporary stream now that we have the list
        tempStream.getTracks().forEach(track => track.stop());

        cameraSelect.innerHTML = ''; // Clear "Loading..."

        if (videoDevices.length === 0) {
            cameraSelect.innerHTML = '<option value="">No cameras found</option>';
            return;
        }

        videoDevices.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            // Use the device's label, or a fallback "Camera 1", "Camera 2", etc.
            option.textContent = device.label || `Camera ${index + 1}`; 
            cameraSelect.appendChild(option);
        });

        // Now that the list is populated, load the user's saved preference
        const savedCameraId = loadData(getUserKey(CAMERA_PREFERENCE_KEY), '');
        
        // Check if the saved camera ID is still in the list
        if (savedCameraId && cameraSelect.querySelector(`option[value="${savedCameraId}"]`)) {
            cameraSelect.value = savedCameraId;
        } else if (videoDevices.length > 0) {
            // If no preference is saved or the saved one is gone, default to the first camera
            cameraSelect.value = videoDevices[0].deviceId;
            saveData(getUserKey(CAMERA_PREFERENCE_KEY), videoDevices[0].deviceId);
        }

    } catch (err) {
        console.error("Error populating camera list:", err);
        // Let the user know if permission was denied
        if (err.name === "NotAllowedError") {
             cameraSelect.innerHTML = '<option value="">Camera permission denied</option>';
        } else {
             cameraSelect.innerHTML = '<option value="">Error finding cameras</option>';
        }
    }
}
// --- END OF NEW FUNCTION ---
		
		
		
		
		
		
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // --- Sidebar Management ---
        function toggleSidebar(sidebarId, state) {
            const sidebar = document.getElementById(sidebarId);
            if (state) {
                sidebar.classList.add('active');
                managerOverlay.classList.add('active');
            } else {
                sidebar.classList.remove('active');
                managerOverlay.classList.remove('active');
            }
        }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
       function hideAllSidebars() {
            ['menu-manager', 'past-chats-manager', 'notes-manager', 'reminders-manager', 'settings-manager', 'memory-manager', 'preferences-manager', 'people-manager', 'goals-manager', 'journal-manager', 'knowledge-manager', 'profile-manager', 'routines-manager', 'email-manager', 'habits-manager', 'idea-hub-manager', 'roadmap-manager', 'review-manager', 'helen-diary-manager'] // <-- ADD 'helen-diary-manager'
            .forEach(id => {
                document.getElementById(id).classList.remove('active');
            });
            managerOverlay.classList.remove('active');
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////// Event Listener Start //////////////////////////////////////////////////////

        menuButton.addEventListener('click', () => toggleSidebar('menu-manager', true));
        menuManagerCloseBtn.addEventListener('click', () => toggleSidebar('menu-manager', false));
        managerOverlay.addEventListener('click', hideAllSidebars);
        
        menuOptionNewChat.addEventListener('click', () => {
            hideAllSidebars();
            startNewChat();
            showNotification("Started a new chat!", "info");
        });

        menuOptionPastChats.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('past-chats-manager', true);
                loadPastChats();
            }, 300);
        });
        pastChatsManagerCloseBtn.addEventListener('click', () => toggleSidebar('past-chats-manager', false));

        menuOptionNotes.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('notes-manager', true);
                loadNotes();
            }, 300);
        });
        notesManagerCloseBtn.addEventListener('click', () => toggleSidebar('notes-manager', false));

        menuOptionReminders.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('reminders-manager', true);
                loadReminders();
            }, 300);
        });
        remindersManagerCloseBtn.addEventListener('click', () => toggleSidebar('reminders-manager', false));
		
		

        // --- THIS IS THE FIXED CODE ---
        menuOptionSettings.addEventListener('click', () => {
              hideAllSidebars();
    
        // --- NEW FIX: Call this every time settings is opened ---
        // This is crucial for mobile, where voices may only load
        // after a user interaction (like this click).
            populateVoiceList(); 
         	attemptToLoadVoices(); // <-- CHANGE THIS LINE
   
   
               populateCameraList(); // --- ADD THIS LINE ---

                  // --- END OF FIX ---

    setTimeout(() => {
        // Load the saved key into the input field when settings are opened
        apiKeyInput.value = loadData(getUserKey(API_KEY_KEY), '');
        toggleApiKeyBtn.querySelector('#api-key-svg-show').classList.remove('hidden');
        toggleApiKeyBtn.querySelector('#api-key-svg-hide').classList.add('hidden');
        apiKeyInput.type = 'password';
        toggleSidebar('settings-manager', true);
    }, 300);
});
        settingsManagerCloseBtn.addEventListener('click', () => toggleSidebar('settings-manager', false));
		
		
		

        menuOptionMemory.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('memory-manager', true);
                loadMemories();
            }, 300);
        });
        memoryManagerCloseBtn.addEventListener('click', () => toggleSidebar('memory-manager', false));

        menuOptionPreferences.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('preferences-manager', true);
                loadPreferences();
            }, 300);
        });
        preferencesManagerCloseBtn.addEventListener('click', () => toggleSidebar('preferences-manager', false));

        menuOptionPeople.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('people-manager', true);
                loadPeople();
            }, 300);
        });
        peopleManagerCloseBtn.addEventListener('click', () => toggleSidebar('people-manager', false));

        menuOptionGoals.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('goals-manager', true);
                loadGoals();
            }, 300);
        });
        goalsManagerCloseBtn.addEventListener('click', () => toggleSidebar('goals-manager', false));
        
        menuOptionHabits.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('habits-manager', true);
                loadHabits();
            }, 300);
        });
        habitsManagerCloseBtn.addEventListener('click', () => toggleSidebar('habits-manager', false));

        menuOptionJournal.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('journal-manager', true);
                loadJournal();
            }, 300);
        });
        journalManagerCloseBtn.addEventListener('click', () => toggleSidebar('journal-manager', false));

        menuOptionKnowledge.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('knowledge-manager', true);
                loadKnowledge();
            }, 300);
        });
        knowledgeManagerCloseBtn.addEventListener('click', () => toggleSidebar('knowledge-manager', false));

        menuOptionProfile.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('profile-manager', true);
                loadProfile();
            }, 300);
        });
        profileManagerCloseBtn.addEventListener('click', () => toggleSidebar('profile-manager', false));

        menuOptionRoutines.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('routines-manager', true);
                loadRoutines();
            }, 300);
        });
        routinesManagerCloseBtn.addEventListener('click', () => toggleSidebar('routines-manager', false));

        menuOptionEmail.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('email-manager', true);
            }, 300);
        });
        emailManagerCloseBtn.addEventListener('click', () => toggleSidebar('email-manager', false));

        menuOptionIdeaHub.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('idea-hub-manager', true);
                loadIdeaBoards();
            }, 300);
        });
        ideaHubManagerCloseBtn.addEventListener('click', () => toggleSidebar('idea-hub-manager', false));

        menuOptionRoadmap.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('roadmap-manager', true);
                loadRoadmap();
            }, 300);
        });
        roadmapManagerCloseBtn.addEventListener('click', () => toggleSidebar('roadmap-manager', false));


        menuOptionReviewItems.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('review-manager', true);
                loadReviewItems();
            }, 300);
        });
        reviewManagerCloseBtn.addEventListener('click', () => toggleSidebar('review-manager', false));
		
		
		// --- ADD THESE ---
        menuOptionHelenDiary.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                toggleSidebar('helen-diary-manager', true);
                loadHelenDiary();
            }, 300);
        });
        helenDiaryManagerCloseBtn.addEventListener('click', () => toggleSidebar('helen-diary-manager', false));
        // --- END OF ADDITION ---
		
		
		
		
		// --- ADD THIS NEW LISTENER ---
        cameraSelect.addEventListener('change', () => {
            const selectedCameraId = cameraSelect.value;
            saveData(getUserKey(CAMERA_PREFERENCE_KEY), selectedCameraId);
            showNotification("Default camera saved!", "success");

            // Optional: If the camera is live, switch it immediately
            if (cameraStream) {
                closeCamera();
                // Re-open the camera modal (it will now use the new ID)
                // We assume it's not an auto-scan if we're just switching
                openCamera(false); 
            }
        });
		
		
		      // ===== START: NEW CAMERA LISTENERS =====
        captureBtn.addEventListener('click', captureImage);
        
        // --- MODIFY THIS LISTENER ---
        cameraCancelBtn.addEventListener('click', () => {
            closeCamera(); // Close the modal
            
            // --- NEW FIX: Restart recognition if it was in Live Mode ---
            if (shouldBeListening && !isListening) {
                console.log("Camera cancelled, restarting recognition.");
                try {
                    recognition.start();
                } catch(e) { console.error("Error restarting recognition after cancel:", e); }
            }
            // --- END FIX ---
        });
        // --- END OF MODIFICATION ---

		
		
		
		
		
        /// Event Listener End ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        // --- Notes & Reminders Logic ---
        function loadNotes() {
            const notes = loadData(getUserKey(NOTES_KEY), []);
            notesList.innerHTML = '';
            notes.forEach(note => {
                const noteItem = document.createElement('div');
                noteItem.classList.add('note-item');
                noteItem.innerHTML = `
                    <p contenteditable="false">${note.content}</p>
                    <span class="timestamp">${new Date(note.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                notesList.appendChild(noteItem);
            });
            setupNoteListeners();
        }

        addNewNoteBtn.addEventListener('click', () => {
            modalTitle.textContent = "Add a New Note";
            modalSaveBtn.textContent = "Save Note";
            noteInputArea.value = '';
            addNoteModal.classList.remove('hidden');
            noteInputArea.focus();
            modalSaveBtn.onclick = () => {
                const content = noteInputArea.value.trim();
                if (content) {
                    const notes = loadData(getUserKey(NOTES_KEY), []);
                    notes.unshift({ content: content, timestamp: new Date().toISOString() });
                    saveData(getUserKey(NOTES_KEY), notes);
                    loadNotes();
                    showNotification("Note added!", "success");
                    modalCancelBtn.click();
                }
            };
        });
        
        modalCancelBtn.addEventListener('click', () => {
            addNoteModal.classList.add('hidden');
            noteInputArea.value = '';
        });

        function setupNoteListeners() {
            document.querySelectorAll('#notes-list .edit-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const noteItem = e.target.closest('.note-item');
                    const noteText = noteItem.querySelector('p');
                    const isEditing = noteText.contentEditable === 'true';

                    if (isEditing) {
                        noteText.contentEditable = 'false';
                        button.textContent = 'Edit';
                        saveNotes();
                    } else {
                        noteText.contentEditable = 'true';
                        noteText.focus();
                        button.textContent = 'Save';
                    }
                });
            });

            document.querySelectorAll('#notes-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const noteItem = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want to delete this note?`)) {
                        noteItem.remove();
                        saveNotes();
                        showNotification("Note deleted.", "success");
                    }
                });
            });
        }

        function saveNotes() {
            const notes = [];
            document.querySelectorAll('#notes-list .note-item').forEach(noteItem => {
                const content = noteItem.querySelector('p').textContent;
                const timestamp = new Date(noteItem.querySelector('.timestamp').textContent).toISOString();
                notes.push({ content, timestamp });
            });
            saveData(getUserKey(NOTES_KEY), notes);
        }

        // --- Memory Logic ---
        function loadMemories() {
            const memories = loadData(getUserKey(MEMORIES_KEY), []);
            memoryList.innerHTML = '';
            memories.forEach(memory => {
                const memoryItem = document.createElement('div');
                memoryItem.classList.add('note-item'); 
                memoryItem.innerHTML = `
                    <p>${memory.content}</p>
                    <span class="timestamp">${new Date(memory.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="delete-btn">Forget</button>
                    </div>
                `;
                memoryList.appendChild(memoryItem);
            });
            setupMemoryListeners();
        }

        addNewMemoryBtn.addEventListener('click', () => {
            const memoryContent = prompt("What new fact should Helen remember about you?");
            if (memoryContent && memoryContent.trim()) {
                const memories = loadData(getUserKey(MEMORIES_KEY), []);
                memories.unshift({ content: memoryContent.trim(), timestamp: new Date().toISOString() });
                saveData(getUserKey(MEMORIES_KEY), memories);
                loadMemories();
                showNotification("New memory added!", "success");
            }
        });

        function setupMemoryListeners() {
            document.querySelectorAll('#memory-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const memoryItem = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want Helen to forget this?`)) {
                        memoryItem.remove();
                        saveMemories();
                        showNotification("Memory forgotten.", "success");
                    }
                });
            });
        }

        function saveMemories() {
            const memories = [];
            document.querySelectorAll('#memory-list .note-item').forEach(memoryItem => {
                const content = memoryItem.querySelector('p').textContent;
                const timestamp = new Date(memoryItem.querySelector('.timestamp').textContent).toISOString();
                memories.push({ content, timestamp });
            });
            saveData(getUserKey(MEMORIES_KEY), memories);
        }
        
        // --- Preferences Logic ---
        function loadPreferences() {
            const preferences = loadData(getUserKey(PREFERENCES_KEY), []);
            preferencesList.innerHTML = '';
            preferences.forEach(preference => {
                const preferenceItem = document.createElement('div');
                preferenceItem.classList.add('note-item'); 
                preferenceItem.innerHTML = `
                    <p>${preference.content}</p>
                    <span class="timestamp">${new Date(preference.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="delete-btn">Remove</button>
                    </div>
                `;
                preferencesList.appendChild(preferenceItem);
            });
            setupPreferenceListeners();
        }

        addNewPreferenceBtn.addEventListener('click', () => {
            const preferenceContent = prompt("What is a new preference, interest, or hobby?");
            if (preferenceContent && preferenceContent.trim()) {
                const preferences = loadData(getUserKey(PREFERENCES_KEY), []);
                preferences.unshift({ content: preferenceContent.trim(), timestamp: new Date().toISOString() });
                saveData(getUserKey(PREFERENCES_KEY), preferences);
                loadPreferences();
                showNotification("New preference added!", "success");
            }
        });

        function setupPreferenceListeners() {
            document.querySelectorAll('#preferences-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const preferenceItem = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want to remove this preference?`)) {
                        preferenceItem.remove();
                        savePreferences();
                        showNotification("Preference removed.", "success");
                    }
                });
            });
        }

        function savePreferences() {
            const preferences = [];
            document.querySelectorAll('#preferences-list .note-item').forEach(preferenceItem => {
                const content = preferenceItem.querySelector('p').textContent;
                const timestamp = new Date(preferenceItem.querySelector('.timestamp').textContent).toISOString();
                preferences.push({ content, timestamp });
            });
            saveData(getUserKey(PREFERENCES_KEY), preferences);
        }

        // --- People Logic ---
        function loadPeople() {
            const people = loadData(getUserKey(PEOPLE_KEY), []);
            peopleList.innerHTML = '';
            people.forEach(person => {
                const personItem = document.createElement('div');
                personItem.classList.add('note-item'); 
                personItem.innerHTML = `
                    <p>${person.content}</p>
                    <span class="timestamp">${new Date(person.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="delete-btn">Remove</button>
                    </div>
                `;
                peopleList.appendChild(personItem);
            });
            setupPeopleListeners();
        }

        addNewPersonBtn.addEventListener('click', () => {
            const personContent = prompt("What is a fact about a person you know? (e.g., 'My manager is Jane', 'Leo's birthday is October 26th')");
            if (personContent && personContent.trim()) {
                const people = loadData(getUserKey(PEOPLE_KEY), []);
                const firstPersonBonusAwarded = loadData(getUserKey(BONUS_FIRST_PERSON_KEY), false);
                people.unshift({ content: personContent.trim(), timestamp: new Date().toISOString() });
                saveData(getUserKey(PEOPLE_KEY), people);
                loadPeople();
                showNotification("New person/fact added!", "success");
                if (!firstPersonBonusAwarded) {
                    addPoints(50);
                    showNotification("Feature Discovery! +50 points for adding your first person.", "success");
                    saveData(getUserKey(BONUS_FIRST_PERSON_KEY), true);
                }
            }
        });

        function setupPeopleListeners() {
            document.querySelectorAll('#people-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const personItem = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want to remove this fact?`)) {
                        personItem.remove();
                        savePeople();
                        showNotification("Fact removed.", "success");
                    }
                });
            });
        }

        function savePeople() {
            const people = [];
            document.querySelectorAll('#people-list .note-item').forEach(personItem => {
                const content = personItem.querySelector('p').textContent;
                const timestamp = new Date(personItem.querySelector('.timestamp').textContent).toISOString();
                people.push({ content, timestamp });
            });
            saveData(getUserKey(PEOPLE_KEY), people);
        }

        // --- Goal Logic ---
        function loadGoals() {
            const goals = loadData(getUserKey(GOALS_KEY), []);
            goalsList.innerHTML = '';
            goals.forEach(goal => {
                const goalItem = document.createElement('div');
                goalItem.classList.add('goal-item');
                goalItem.dataset.goalId = goal.id;
                
                let todosHtml = '<ul class="todo-list">';
                goal.todos.forEach(todo => {
                    todosHtml += `
                        <li class="todo-item" data-todo-id="${todo.id}">
                            <input type="checkbox" ${todo.completed ? 'checked' : ''}>
                            <span class="${todo.completed ? 'completed' : ''}">${todo.text}</span>
                            <button class="delete-todo-btn">&times;</button>
                        </li>
                    `;
                });
                todosHtml += '</ul>';

                goalItem.innerHTML = `
                    <div class="goal-item-title">
                        <span>${goal.title}</span>
                    </div>
                    ${todosHtml}
                    <div class="goal-item-actions">
                        <button class="add-todo-btn">Add To-do</button>
                        <button class="delete-goal-btn">Delete Goal</button>
                    </div>
                `;
                goalsList.appendChild(goalItem);
            });
            setupGoalListeners();
        }

        addNewGoalBtn.addEventListener('click', () => {
            const goalTitle = prompt("What is your new goal or project?");
            if (goalTitle && goalTitle.trim()) {
                const goals = loadData(getUserKey(GOALS_KEY), []);
                const firstGoalBonusAwarded = loadData(getUserKey(BONUS_FIRST_GOAL_KEY), false);
                goals.unshift({ id: `goal_${Date.now()}`, title: goalTitle.trim(), todos: [] });
                saveData(getUserKey(GOALS_KEY), goals);
                loadGoals();
                showNotification("New goal added!", "success");
                if (!firstGoalBonusAwarded) {
                    addPoints(50);
                    showNotification("Feature Discovery! +50 points for creating your first goal.", "success");
                    saveData(getUserKey(BONUS_FIRST_GOAL_KEY), true);
                }
            }
        });

        function setupGoalListeners() {
            document.querySelectorAll('#goals-list .goal-item').forEach(goalItem => {
                const goalId = goalItem.dataset.goalId;

                goalItem.querySelector('.add-todo-btn').addEventListener('click', () => {
                    const todoText = prompt("What is the new to-do for this goal?");
                    if (todoText && todoText.trim()) {
                        const goals = loadData(getUserKey(GOALS_KEY), []);
                        const goal = goals.find(g => g.id === goalId);
                        if (goal) {
                            goal.todos.push({ id: `todo_${Date.now()}`, text: todoText.trim(), completed: false });
                            saveData(getUserKey(GOALS_KEY), goals);
                            loadGoals();
                        }
                    }
                });

                goalItem.querySelector('.delete-goal-btn').addEventListener('click', () => {
                    if (confirm("Are you sure you want to delete this entire goal?")) {
                        let goals = loadData(getUserKey(GOALS_KEY), []);
                        goals = goals.filter(g => g.id !== goalId);
                        saveData(getUserKey(GOALS_KEY), goals);
                        loadGoals();
                    }
                });

                goalItem.querySelectorAll('.todo-item').forEach(todoItem => {
                    const todoId = todoItem.dataset.todoId;

                    todoItem.querySelector('input[type="checkbox"]').addEventListener('change', (e) => {
                        const goals = loadData(getUserKey(GOALS_KEY), []);
                        const goal = goals.find(g => g.id === goalId);
                        if (goal) {
                            const todo = goal.todos.find(t => t.id === todoId);
                            if (todo) {
                                const wasCompleted = todo.completed;
                                todo.completed = e.target.checked;
                                if (todo.completed && !wasCompleted) {
                                    addPoints(25);
                                    showNotification("Productivity! +25 points for completing a to-do.", "success");
                                }
                                saveData(getUserKey(GOALS_KEY), goals);
                                loadGoals();
                            }
                        }
                    });

                    todoItem.querySelector('.delete-todo-btn').addEventListener('click', () => {
                        const goals = loadData(getUserKey(GOALS_KEY), []);
                        const goal = goals.find(g => g.id === goalId);
                        if (goal) {
                            goal.todos = goal.todos.filter(t => t.id !== todoId);
                            saveData(getUserKey(GOALS_KEY), goals);
                            loadGoals();
                        }
                    });
                });
            });
        }

        // --- Journal Logic ---
        function loadJournal() {
            const journal = loadData(getUserKey(JOURNAL_KEY), []);
            journalList.innerHTML = '';
            journal.forEach(entry => {
                const entryItem = document.createElement('div');
                entryItem.classList.add('journal-entry');
                entryItem.dataset.journalId = entry.id;
                entryItem.innerHTML = `
                    <div class="journal-entry-title">${new Date(entry.timestamp).toDateString()}</div>
                    <p class="journal-entry-content" contenteditable="false">${entry.content}</p>
                    <span class="timestamp">${new Date(entry.timestamp).toLocaleTimeString()}</span>
                    <div class="journal-entry-actions">
                        <button class="edit-btn">Edit</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                journalList.appendChild(entryItem);
            });
            setupJournalListeners();
        }

        addNewJournalEntryBtn.addEventListener('click', () => {
            modalTitle.textContent = "Add New Journal Entry";
            modalSaveBtn.textContent = "Save Entry";
            noteInputArea.value = '';
            addNoteModal.classList.remove('hidden');
            noteInputArea.focus();

            modalSaveBtn.onclick = () => {
                const content = noteInputArea.value.trim();
                if (content) {
                    const journal = loadData(getUserKey(JOURNAL_KEY), []);
                    const firstJournalBonusAwarded = loadData(getUserKey(BONUS_FIRST_JOURNAL_KEY), false);
                    journal.unshift({ id: `journal_${Date.now()}`, content: content, timestamp: new Date().toISOString() });
                    saveData(getUserKey(JOURNAL_KEY), journal);
                    loadJournal();
                    showNotification("Journal entry added!", "success");
                    if (!firstJournalBonusAwarded) {
                        addPoints(50);
                        showNotification("Feature Discovery! +50 points for your first journal entry.", "success");
                        saveData(getUserKey(BONUS_FIRST_JOURNAL_KEY), true);
                    }
                    modalCancelBtn.click();
                }
            };
        });

        function setupJournalListeners() {
            document.querySelectorAll('#journal-list .journal-entry').forEach(entryItem => {
                const journalId = entryItem.dataset.journalId;

                entryItem.querySelector('.edit-btn').addEventListener('click', (e) => {
                    const contentP = entryItem.querySelector('.journal-entry-content');
                    const isEditing = contentP.contentEditable === 'true';
                    if (isEditing) {
                        contentP.contentEditable = 'false';
                        e.target.textContent = 'Edit';
                        saveJournal();
                    } else {
                        contentP.contentEditable = 'true';
                        contentP.focus();
                        e.target.textContent = 'Save';
                    }
                });

                entryItem.querySelector('.delete-btn').addEventListener('click', () => {
                    if (confirm("Are you sure you want to delete this journal entry?")) {
                        let journal = loadData(getUserKey(JOURNAL_KEY), []);
                        journal = journal.filter(j => j.id !== journalId);
                        saveData(getUserKey(JOURNAL_KEY), journal);
                        loadJournal();
                    }
                });
            });
        }
        
        function saveJournal() {
            const journal = [];
            document.querySelectorAll('#journal-list .journal-entry').forEach(entryItem => {
                const id = entryItem.dataset.journalId;
                const content = entryItem.querySelector('.journal-entry-content').textContent;
                const timestamp = new Date(entryItem.querySelector('.timestamp').textContent).toISOString(); // This is imperfect but works for display
                journal.push({ id, content, timestamp });
            });
            // A proper save would find the original timestamp, this is a simplification
            saveData(getUserKey(JOURNAL_KEY), journal);
        }




        // --- Knowledge Base Logic ---
        function loadKnowledge() {
            const knowledge = loadData(getUserKey(KNOWLEDGE_KEY), []);
            knowledgeList.innerHTML = '';
            knowledge.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.classList.add('note-item'); 
                itemEl.innerHTML = `
                    <p>${item.content}</p>
                    <span class="timestamp">${new Date(item.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="delete-btn">Remove</button>
                    </div>
                `;
                knowledgeList.appendChild(itemEl);
            });
            setupKnowledgeListeners();
        }

        addNewKnowledgeBtn.addEventListener('click', () => {
            const knowledgeContent = prompt("What new fact or piece of information do you want to add?");
            if (knowledgeContent && knowledgeContent.trim()) {
                const knowledge = loadData(getUserKey(KNOWLEDGE_KEY), []);
                knowledge.unshift({ id: `knowledge_${Date.now()}`, content: knowledgeContent.trim(), timestamp: new Date().toISOString() });
                saveData(getUserKey(KNOWLEDGE_KEY), knowledge);
                loadKnowledge();
                showNotification("New fact added to knowledge base!", "success");
            }
        });

        function setupKnowledgeListeners() {
            document.querySelectorAll('#knowledge-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemEl = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want to remove this from your knowledge base?`)) {
                        itemEl.remove();
                        saveKnowledge();
                        showNotification("Fact removed.", "success");
                    }
                });
            });
        }

        function saveKnowledge() {
            const knowledge = [];
            document.querySelectorAll('#knowledge-list .note-item').forEach(itemEl => {
                const content = itemEl.querySelector('p').textContent;
                const timestamp = new Date(itemEl.querySelector('.timestamp').textContent).toISOString();
                knowledge.push({ content, timestamp });
            });
            saveData(getUserKey(KNOWLEDGE_KEY), knowledge);
        }

        // --- Routines Logic ---
        function loadRoutines() {
            const routines = loadData(getUserKey(ROUTINES_KEY), []);
            routinesList.innerHTML = '';
            routines.forEach(routine => {
                const routineItem = document.createElement('div');
                routineItem.classList.add('note-item'); 
                routineItem.innerHTML = `
                    <p>${routine.content}</p>
                    <span class="timestamp">${new Date(routine.timestamp).toLocaleString()}</span>
                    <div class="note-item-actions">
                        <button class="delete-btn">Remove</button>
                    </div>
                `;
                routinesList.appendChild(routineItem);
            });
            setupRoutineListeners();
        }

        addNewRoutineBtn.addEventListener('click', () => {
            const routineContent = prompt("What new routine would you like to add?");
            if (routineContent && routineContent.trim()) {
                const routines = loadData(getUserKey(ROUTINES_KEY), []);
                routines.unshift({ id: `routine_${Date.now()}`, content: routineContent.trim(), timestamp: new Date().toISOString() });
                saveData(getUserKey(ROUTINES_KEY), routines);
                loadRoutines();
                showNotification("New routine added!", "success");
            }
        });

        function setupRoutineListeners() {
            document.querySelectorAll('#routines-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const routineItem = e.target.closest('.note-item');
                    if (confirm(`Are you sure you want to remove this routine?`)) {
                        routineItem.remove();
                        saveRoutines();
                        showNotification("Routine removed.", "success");
                    }
                });
            });
        }

        function saveRoutines() {
            const routines = [];
            document.querySelectorAll('#routines-list .note-item').forEach(routineItem => {
                const content = routineItem.querySelector('p').textContent;
                const timestamp = new Date(routineItem.querySelector('.timestamp').textContent).toISOString();
                routines.push({ content, timestamp });
            });
            saveData(getUserKey(ROUTINES_KEY), routines);
        }
        
        // --- Habit Tracker Logic ---
        addNewHabitBtn.addEventListener('click', () => {
            const text = prompt("What new daily habit do you want to track?");
            if (text && text.trim()) {
                const habits = loadData(getUserKey(HABITS_KEY), []);
                habits.push({
                    id: `habit_${Date.now()}`,
                    text: text.trim(),
                    createdAt: new Date().toISOString(),
                    completions: []
                });
                saveData(getUserKey(HABITS_KEY), habits);
                loadHabits();
                showNotification("New habit added!", "success");
            }
        });
        
        function calculateStreak(completions) {
            if (completions.length === 0) return 0;
            
            const sortedDates = completions.map(c => new Date(c)).sort((a, b) => b - a);
            
            let streak = 0;
            const today = new Date(new Date().toISOString().split('T')[0]);
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);

            const latestCompletion = new Date(sortedDates[0].toISOString().split('T')[0]);

            // Streak is only broken if the last completion was before yesterday
            if (latestCompletion.getTime() < yesterday.getTime()) {
                return 0;
            }
            
            // If the latest completion is today or yesterday, start the streak count at 1
            streak = 1;
            let currentDay = new Date(sortedDates[0]);

            for (let i = 1; i < sortedDates.length; i++) {
                const nextDay = new Date(sortedDates[i]);
                const expectedPreviousDay = new Date(currentDay);
                expectedPreviousDay.setDate(currentDay.getDate() - 1);

                if (nextDay.toISOString().split('T')[0] === expectedPreviousDay.toISOString().split('T')[0]) {
                    streak++;
                    currentDay = nextDay;
                } else {
                    break; // Streak broken
                }
            }
            return streak;
        }


       function loadHabits() {
            const habits = loadData(getUserKey(HABITS_KEY), []);
            habitsList.innerHTML = '';
            
            const todayStr = new Date().toISOString().split('T')[0];

            habits.forEach(habit => {
                const isCompletedToday = habit.completions.includes(todayStr);
                const streak = calculateStreak(habit.completions);

                const habitItem = document.createElement('div');
                habitItem.classList.add('habit-item');
                habitItem.innerHTML = `
                    <input type="checkbox" data-habit-id="${habit.id}" ${isCompletedToday ? 'checked' : ''}>
                    <span class="habit-text">${habit.text}</span>
                    <span class="habit-streak">?? ${streak}</span>
                    <button class="delete-habit-btn" data-habit-id="${habit.id}" title="Delete Habit">&times;</button>
                `;
                habitsList.appendChild(habitItem);
            });
            
            document.querySelectorAll('.habit-item input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const habitId = e.target.dataset.habitId;
                    const habits = loadData(getUserKey(HABITS_KEY), []);
                    const habit = habits.find(h => h.id === habitId);
                    if (habit) {
                        if (e.target.checked) {
                            if (!habit.completions.includes(todayStr)) {
                                habit.completions.push(todayStr);
                            }
                        } else {
                            habit.completions = habit.completions.filter(c => c !== todayStr);
                        }
                        saveData(getUserKey(HABITS_KEY), habits);
                        loadHabits(); // Reload to update streak
                    }
                });
            });

            document.querySelectorAll('.habit-item .delete-habit-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    if (confirm("Are you sure you want to delete this habit?")) {
                        const habitId = e.target.dataset.habitId;
                        let habits = loadData(getUserKey(HABITS_KEY), []);
                        habits = habits.filter(h => h.id !== habitId);
                        saveData(getUserKey(HABITS_KEY), habits);
                        loadHabits();
                    }
                });
            });
        }

        // --- Idea Hub Logic ---
        function loadIdeaBoards() {
            const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            ideaHubList.innerHTML = '';
            boards.forEach(board => {
                const boardItem = document.createElement('div');
                boardItem.classList.add('idea-board-item');
                boardItem.innerHTML = `
                    <div class="board-title">${board.title}</div>
                    <div class="timestamp">Created: ${new Date(board.createdAt).toLocaleDateString()}</div>
                    <div class="idea-board-actions">
                        <button class="delete-board-btn" data-board-id="${board.id}">Delete</button>
                    </div>
                `;
                boardItem.querySelector('.board-title').addEventListener('click', () => openIdeaBoard(board.id));
                boardItem.querySelector('.delete-board-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`Are you sure you want to delete the board "${board.title}"? This cannot be undone.`)) {
                        deleteIdeaBoard(board.id);
                    }
                });
                ideaHubList.appendChild(boardItem);
            });
        }

        addNewIdeaBoardBtn.addEventListener('click', () => {
            const title = prompt("Enter a name for your new brainstorming board:");
            if (title && title.trim()) {
                const newBoard = {
                    id: `board_${Date.now()}`,
                    title: title.trim(),
                    createdAt: new Date().toISOString(),
                    columns: [
                        { id: `col_${Date.now()}_1`, title: 'Raw Ideas', cards: [] },
                        { id: `col_${Date.now()}_2`, title: 'Exploring', cards: [] },
                        { id: `col_${Date.now()}_3`, title: 'Actionable', cards: [] }
                    ]
                };
                const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
                boards.unshift(newBoard);
                saveData(getUserKey(IDEA_BOARDS_KEY), boards);
                loadIdeaBoards();
                openIdeaBoard(newBoard.id);
            }
        });
        
        function deleteIdeaBoard(boardId) {
            let boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            boards = boards.filter(b => b.id !== boardId);
            saveData(getUserKey(IDEA_BOARDS_KEY), boards);
            loadIdeaBoards();
        }

        function openIdeaBoard(boardId) {
            const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            const boardData = boards.find(b => b.id === boardId);
            if (!boardData) {
                showNotification("Board not found.", "error");
                return;
            }
            currentIdeaBoardId = boardId;
            ideaHubTitle.textContent = boardData.title;
            renderIdeaBoard(boardData);
            ideaHubContainer.classList.add('active');
            hideAllSidebars();
        }

        closeIdeaHubBtn.addEventListener('click', () => {
            ideaHubContainer.classList.remove('active');
            currentIdeaBoardId = null;
        });
        
       // Find and replace this entire function
function renderIdeaBoard(boardData) {
    ideaBoard.innerHTML = ''; // Clear previous board
    boardData.columns.forEach(column => {
        const columnEl = document.createElement('div');
        columnEl.classList.add('idea-column');
        columnEl.dataset.columnId = column.id;
        
        const cardsHtml = column.cards.map(card => `
            <div class="idea-card" draggable="true" data-card-id="${card.id}">
                <div class="idea-card-header">
                    <p>${card.text}</p>
                 <div class="idea-tag tag-${card.tagColor || 'default'}"></div>
                </div>
                <div class="idea-card-actions">
                    <button class="convert-to-goal-btn">To Goal</button>
                    <button class="delete-card-btn">Delete</button>
                </div>
            </div>
        `).join('');

        // MODIFIED: Added the suggest-idea-btn to the header
        columnEl.innerHTML = `
            <div class="idea-column-header">
                <span>${column.title}</span>
                <button class="suggest-idea-btn" title="Ask Helen to suggest an idea">?</button>
            </div>
            <div class="idea-cards">${cardsHtml}</div>
            <button class="add-card-btn">+ Add Idea</button>
        `;
        ideaBoard.appendChild(columnEl);
    });
    ideaBoard.appendChild(addColumnBtn);
    setupIdeaBoardListeners();
}


async function suggestNewIdea(columnId, buttonElement) {
    buttonElement.textContent = '...'; // Show loading state
    buttonElement.disabled = false;

    try {
        const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
        const board = boards.find(b => b.id === currentIdeaBoardId);
        const column = board.columns.find(c => c.id === columnId);
        if (!column) return;

        const existingIdeas = column.cards.map(card => card.text);
        if (existingIdeas.length === 0) {
            showNotification("Add at least one idea to the column first so I have some context!", "info");
            return;
        }
        
        const prompt = `You are a creative brainstorming partner. Based on the following list of ideas in a column titled "${column.title}", suggest one new, complementary idea. Respond with ONLY the text for the new idea, nothing else.

        Existing Ideas:
        - ${existingIdeas.join('\n- ')}

        New Idea:`;
        
        const payload = {
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            systemInstruction: { role: "system", parts: [{ text: SYSTEM_PROMPT }] }
        };
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) throw new Error('API call failed for idea suggestion.');
        
        const result = await response.json();
        const newIdeaText = result.candidates[0].content.parts[0].text.trim();
        
        addCardToBoard(columnId, newIdeaText);
        showNotification("Helen added a new idea!", "success");

    } catch (error) {
        console.error("Error suggesting new idea:", error);
        showNotification("Sorry, I had trouble coming up with an idea.", "error");
    } finally {
        buttonElement.textContent = '?'; // Reset button
        buttonElement.disabled = false;
    }
}

        function setupIdeaBoardListeners() {	
		 // --- NEW: Add this listener to solve the drag/click conflict ---
    ideaBoard.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('idea-tag')) {
            // This stops the 'mousedown' event from "bubbling up" to the parent card,
            // which prevents the drag-and-drop action from ever starting.
            e.stopPropagation();
        }
    });
			
    // --- NEW: Color Palette Logic ---
    const availableColors = ['default', 'red', 'blue', 'green', 'yellow'];

    ideaBoard.addEventListener('click', (e) => {
        // First, remove any existing palette when clicking anywhere on the board
        const existingPalette = document.querySelector('.color-palette');
        if (existingPalette) {
            existingPalette.remove();
        }
		
		 if (e.target.classList.contains('suggest-idea-btn')) {
        e.stopPropagation();
        const columnEl = e.target.closest('.idea-column');
        const columnId = columnEl.dataset.columnId;
        suggestNewIdea(columnId, e.target);
    }

        // Now, check if we specifically clicked on a tag
        if (e.target.classList.contains('idea-tag')) {
            e.stopPropagation(); // Prevent the board click from immediately closing the new palette
            const clickedTag = e.target;
            const cardEl = clickedTag.closest('.idea-card');
            const cardId = cardEl.dataset.cardId;

            // Create the palette div
            const palette = document.createElement('div');
            palette.className = 'color-palette';
            
            // Create a color swatch for each available color
            availableColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = `color-swatch tag-${color}`;
                swatch.dataset.color = color;
                
                swatch.onclick = () => {
                    // Update the data
                    const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
                    const board = boards.find(b => b.id === currentIdeaBoardId);
                    board.columns.forEach(column => {
                        const card = column.cards.find(c => c.id === cardId);
                        if (card) {
                            card.tagColor = color;
                        }
                    });
                    saveData(getUserKey(IDEA_BOARDS_KEY), boards);
                    
                    // Re-render the board to show the change
                    renderIdeaBoard(board);
                };
                palette.appendChild(swatch);
            });
            
            // Position and add the palette to the page
            document.body.appendChild(palette);
            const tagRect = clickedTag.getBoundingClientRect();
            palette.style.left = `${tagRect.left}px`;
            palette.style.top = `${tagRect.bottom + 5}px`;
        }
    });
    // --- END of New Logic ---

    // --- Existing Drag-and-Drop and Button Logic ---
    // (This is the same code you already had)
    const cards = document.querySelectorAll('.idea-card');
    const columns = document.querySelectorAll('.idea-column');
    let draggedCard = null;

    cards.forEach(card => {
        card.addEventListener('dragstart', () => {
            draggedCard = card;
            setTimeout(() => card.classList.add('dragging'), 0);
        });
        card.addEventListener('dragend', () => {
            card.classList.remove('dragging');
            draggedCard = null;
            saveCurrentBoardState();
        });
    });

    columns.forEach(column => {
        column.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElement(column.querySelector('.idea-cards'), e.clientY);
            const cardsContainer = column.querySelector('.idea-cards');
            if (afterElement == null) {
                cardsContainer.appendChild(draggedCard);
            } else {
                cardsContainer.insertBefore(draggedCard, afterElement);
            }
        });
    });
    
    document.querySelectorAll('.add-card-btn').forEach(button => {
        button.addEventListener('click', (e) => {
            const columnEl = e.target.closest('.idea-column');
            const columnId = columnEl.dataset.columnId;
            const cardText = prompt("Enter your idea:");
            if (cardText && cardText.trim()) {
                addCardToBoard(columnId, cardText.trim());
            }
        });
    });

    addColumnBtn.onclick = () => {
        const columnTitle = prompt("Enter new column name:");
        if (columnTitle && columnTitle.trim()) {
            addColumnToBoard(columnTitle.trim());
        }
    };
    
    document.querySelectorAll('.idea-card .idea-card-actions button').forEach(button => {
        button.addEventListener('click', (e) => {
            const cardEl = e.target.closest('.idea-card');
            const cardId = cardEl.dataset.cardId;
            if (e.target.classList.contains('delete-card-btn')) {
                if (confirm("Delete this idea?")) {
                    deleteCardFromBoard(cardId);
                }
            } else if (e.target.classList.contains('convert-to-goal-btn')) {
                const cardText = cardEl.querySelector('p').textContent;
                if (confirm(`Convert "${cardText}" into a new goal?`)) {
                    convertIdeaToGoal(cardText);
                }
            }
        });
    });
}
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.idea-card:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

       function addCardToBoard(columnId, text) {
    const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
    const board = boards.find(b => b.id === currentIdeaBoardId);
    if (!board) return;

    const column = board.columns.find(c => c.id === columnId);
    if (!column) return;

    // Create the new, more detailed card object
    const newCard = {
      id: `card_${Date.now()}`,
      text: text,
      description: '', // An empty description to start
      tagColor: 'default' // A default color tag
    };

    column.cards.push(newCard);
    saveData(getUserKey(IDEA_BOARDS_KEY), boards);
    renderIdeaBoard(board);
}
        
        function addColumnToBoard(title) {
            const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            const board = boards.find(b => b.id === currentIdeaBoardId);
            if (!board) return;
            
            board.columns.push({ id: `col_${Date.now()}`, title, cards: [] });
            saveData(getUserKey(IDEA_BOARDS_KEY), boards);
            renderIdeaBoard(board);
        }
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////       
        function deleteCardFromBoard(cardId) {
            const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            const board = boards.find(b => b.id === currentIdeaBoardId);
            if (!board) return;

            board.columns.forEach(column => {
                column.cards = column.cards.filter(card => card.id !== cardId);
            });
            
            saveData(getUserKey(IDEA_BOARDS_KEY), boards);
            renderIdeaBoard(board);
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
        function saveCurrentBoardState() {
            const boards = loadData(getUserKey(IDEA_BOARDS_KEY), []);
            const board = boards.find(b => b.id === currentIdeaBoardId);
            if (!board) return;

            const newColumns = [];
            document.querySelectorAll('.idea-column').forEach(columnEl => {
                const columnId = columnEl.dataset.columnId;
                // CORRECT
                const columnTitle = columnEl.querySelector('.idea-column-header span').textContent;
                const cards = [];
                columnEl.querySelectorAll('.idea-card').forEach(cardEl => {
                    cards.push({
                        id: cardEl.dataset.cardId,
                        text: cardEl.querySelector('p').textContent
                    });
                });
                // --- START FIX ---
const tag = cardEl.querySelector('.idea-tag');
let tagColor = 'default'; // Default
if (tag) {
    // Find the class that starts with 'tag-' but isn't 'idea-tag'
    const colorClass = Array.from(tag.classList).find(c => c.startsWith('tag-') && c !== 'idea-tag');
    if (colorClass) {
        tagColor = colorClass.replace('tag-', ''); // e.g., 'red'
    }
}
cards.push({ id: cardId, text: text, tagColor: tagColor });
            });
            board.columns = newColumns;
            saveData(getUserKey(IDEA_BOARDS_KEY), boards);
        }
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////       
        function convertIdeaToGoal(ideaText) {
            const goals = loadData(getUserKey(GOALS_KEY), []);
            goals.unshift({ id: `goal_${Date.now()}`, title: ideaText, todos: [] });
            saveData(getUserKey(GOALS_KEY), goals);
            showNotification(`Goal "${ideaText}" created!`, "success");
        }


        // --- Profile Logic ---
        function loadProfile() {
            const level = loadData(getUserKey(LEVEL_KEY), 1);
            const points = loadData(getUserKey(POINTS_KEY), 0);
            const pointsNeeded = calculatePointsForNextLevel(level);
            
            let totalMessages = 0;
            allChatSessions.forEach(session => {
                totalMessages += session.history.filter(msg => msg.role === 'user').length;
            });

            const goals = loadData(getUserKey(GOALS_KEY), []);
            let todosCompleted = 0;
            goals.forEach(goal => {
                todosCompleted += goal.todos.filter(todo => todo.completed).length;
            });

            profileContent.innerHTML = `
                <div class="settings-section">
                    <h3>${getUserName() || 'User'}</h3>
                    <p class="text-sm text-[var(--text-secondary)]">Level ${level}</p>
                </div>
                <div class="settings-section">
                    <h3>Progress</h3>
                    <p class="text-sm text-[var(--text-secondary)] mb-2">${points} / ${pointsNeeded} points to next level</p>
                    <div id="profile-progress-bar-container" class="w-full h-4 bg-[var(--border)] rounded-full overflow-hidden">
                        <div id="profile-progress-bar" class="h-full bg-[var(--accent)] rounded-full" style="width: ${(points/pointsNeeded)*100}%"></div>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Statistics</h3>
                    <ul class="text-sm text-[var(--text-secondary)] list-disc pl-5">
                        <li>Total Messages Sent: ${totalMessages}</li>
                        <li>Goals Created: ${goals.length}</li>
                        <li>To-dos Completed: ${todosCompleted}</li>
                    </ul>
                </div>
                <div class="settings-section">
                    <h3>Badges</h3>
                    <div id="badge-display" class="badge-grid"></div>
                </div>
            `;
            loadBadges();
        }

        // --- Project Roadmap Logic ---
        function loadRoadmap() {
            let roadmapData = loadData(getUserKey(ROADMAP_KEY), null);
            const goals = loadData(getUserKey(GOALS_KEY), []);

            // Initialize roadmap data if it doesn't exist
            if (!roadmapData) {
                roadmapData = {
                    phases: [
                        { id: 'planned', title: 'Planned', goalIds: [] },
                        { id: 'in-progress', title: 'In Progress', goalIds: [] },
                        { id: 'completed', title: 'Completed', goalIds: [] }
                    ]
                };
                // Assign all existing goals to the 'Planned' phase by default
                roadmapData.phases[0].goalIds = goals.map(g => g.id);
                saveData(getUserKey(ROADMAP_KEY), roadmapData);
            }

            roadmapBoard.innerHTML = ''; // Clear the board

            // Render each phase as a column
            roadmapData.phases.forEach(phase => {
                const columnEl = document.createElement('div');
                columnEl.classList.add('roadmap-column');
                columnEl.dataset.phaseId = phase.id;

                let goalsHtml = '';
                phase.goalIds.forEach(goalId => {
                    const goal = goals.find(g => g.id === goalId);
                    if (goal) {
                        goalsHtml += `<div class="roadmap-goal-card" draggable="true" data-goal-id="${goal.id}">${goal.title}</div>`;
                    }
                });

                columnEl.innerHTML = `
                    <div class="roadmap-column-header">${phase.title}</div>
                    <div class="roadmap-goals">${goalsHtml}</div>
                `;
                roadmapBoard.appendChild(columnEl);
            });

            setupRoadmapDragAndDrop();
        }

        function setupRoadmapDragAndDrop() {
            const goalCards = document.querySelectorAll('.roadmap-goal-card');
            const columns = document.querySelectorAll('.roadmap-column');
            let draggedGoal = null;

            goalCards.forEach(card => {
                card.addEventListener('dragstart', () => {
                    draggedGoal = card;
                    setTimeout(() => card.classList.add('dragging'), 0);
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    draggedGoal = null;
                    saveRoadmapState();
                });
            });

            columns.forEach(column => {
                column.addEventListener('dragover', e => {
                    e.preventDefault();
                    const goalsContainer = column.querySelector('.roadmap-goals');
                    goalsContainer.appendChild(draggedGoal);
                });
            });
        }

        function saveRoadmapState() {
            const roadmapData = { phases: [] };
            document.querySelectorAll('.roadmap-column').forEach(columnEl => {
                const phaseId = columnEl.dataset.phaseId;
                const title = columnEl.querySelector('.roadmap-column-header').textContent;
                const goalIds = [];
                columnEl.querySelectorAll('.roadmap-goal-card').forEach(cardEl => {
                    goalIds.push(cardEl.dataset.goalId);
                });
                roadmapData.phases.push({ id: phaseId, title: title, goalIds: goalIds });
            });
            saveData(getUserKey(ROADMAP_KEY), roadmapData);
            showNotification("Roadmap updated!", "success");
        }


        function loadReminders() {
            const reminders = loadData(getUserKey(REMINDERS_KEY), []);
            remindersList.innerHTML = '';
            reminders.forEach(reminder => {
                const reminderItem = document.createElement('div');
                reminderItem.classList.add('reminder-item');
                reminderItem.innerHTML = `
                    <p>${reminder.content}</p>
                    <span class="schedule">${new Date(reminder.schedule).toLocaleString()}</span>
                    <span class="status">${reminder.completed ? 'Completed' : 'Pending'}</span>
                    <div class="reminder-item-actions">
                        <button class="complete-btn">${reminder.completed ? 'Undo' : 'Complete'}</button>
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                remindersList.appendChild(reminderItem);
            });
            setupReminderListeners();
        }

        function setupReminderListeners() {
            document.querySelectorAll('.reminder-item .complete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const reminderItem = e.target.closest('.reminder-item');
                    const statusSpan = reminderItem.querySelector('.status');
                    const isCompleted = statusSpan.textContent === 'Completed';
                    statusSpan.textContent = isCompleted ? 'Pending' : 'Completed';
                    button.textContent = isCompleted ? 'Complete' : 'Undo';
                    saveReminders();
                    showNotification(`Reminder marked as ${isCompleted ? 'pending' : 'completed'}.`, 'success');
                });
            });

            document.querySelectorAll('.reminder-item .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const reminderItem = e.target.closest('.reminder-item');
                    if (confirm(`Are you sure you want to delete this reminder?`)) {
                        reminderItem.remove();
                        saveReminders();
                        showNotification("Reminder deleted.", "success");
                    }
                });
            });
        }

        function saveReminders() {
            const reminders = [];
            document.querySelectorAll('.reminder-item').forEach(reminderItem => {
                const content = reminderItem.querySelector('p').textContent;
                const schedule = new Date(reminderItem.querySelector('.schedule').textContent).toISOString();
                const completed = reminderItem.querySelector('.status').textContent === 'Completed';
                reminders.push({ content, schedule, completed });
            });
            saveData(getUserKey(REMINDERS_KEY), reminders);
        }

        // --- Level System Logic ---
        const ALL_BADGES = {
            chatterbox: { icon: '??', title: 'Chatterbox', description: 'Send 100 messages' },
            memoryMaster: { icon: '??', title: 'Memory Master', description: 'Save 10 memories' },
            goalGetter: { icon: '??', title: 'Goal-Getter', description: 'Complete your first project' },
            peoplePerson: { icon: '???????????', title: 'People Person', description: 'Add 5 people' }
        };

        function calculatePointsForNextLevel(level) {
            return Math.floor(100 * Math.pow(level, 1.5));
        }

        function updateLevelDisplay() {
            let level = loadData(getUserKey(LEVEL_KEY), 1);
            let points = loadData(getUserKey(POINTS_KEY), 0);
            const pointsNeeded = calculatePointsForNextLevel(level);
            const progressPercentage = (points / pointsNeeded) * 100;

            levelStatusText.textContent = `Level: ${level} | Points: ${points}/${pointsNeeded}`;
            progressBar.style.width = `${progressPercentage}%`;
        }

        function addPoints(amount) {
            let level = loadData(getUserKey(LEVEL_KEY), 1);
            let points = loadData(getUserKey(POINTS_KEY), 0);
            
            points += amount;

            let pointsNeeded = calculatePointsForNextLevel(level);
            while (points >= pointsNeeded) {
                points -= pointsNeeded;
                level++;
                triggerLevelUpAnimation(level);
                pointsNeeded = calculatePointsForNextLevel(level);
                updateThemeSelector();
            }

            saveData(getUserKey(LEVEL_KEY), level);
            saveData(getUserKey(POINTS_KEY), points);
            updateLevelDisplay();
            checkAndAwardBadges();
        }

        function triggerLevelUpAnimation(level) {
            levelupLevel.textContent = level;
            levelupAnimation.style.display = 'flex';
            setTimeout(() => {
                levelupAnimation.style.display = 'none';
                addMessageToChat(`?? Congrats! You've leveled up to Level ${level}!`, 'helen', false, true);
            }, 3000);
        }

        function checkAndAwardBadges() {
            const badges = loadData(getUserKey(BADGES_KEY), []);
            
            // Chatterbox
            if (!badges.includes('chatterbox')) {
                let totalMessages = 0;
                allChatSessions.forEach(session => {
                    totalMessages += session.history.filter(msg => msg.role === 'user').length;
                });
                if (totalMessages >= 100) {
                    badges.push('chatterbox');
                    showNotification("Badge Unlocked: Chatterbox!", "success");
                }
            }

            // Memory Master
            if (!badges.includes('memoryMaster')) {
                const memories = loadData(getUserKey(MEMORIES_KEY), []);
                if (memories.length >= 10) {
                    badges.push('memoryMaster');
                    showNotification("Badge Unlocked: Memory Master!", "success");
                }
            }

            // Goal-Getter
            if (!badges.includes('goalGetter')) {
                const goals = loadData(getUserKey(GOALS_KEY), []);
                const hasCompletedGoal = goals.some(goal => goal.todos.length > 0 && goal.todos.every(todo => todo.completed));
                if (hasCompletedGoal) {
                    badges.push('goalGetter');
                    showNotification("Badge Unlocked: Goal-Getter!", "success");
                }
            }

            // People Person
            if (!badges.includes('peoplePerson')) {
                const people = loadData(getUserKey(PEOPLE_KEY), []);
                if (people.length >= 5) {
                    badges.push('peoplePerson');
                    showNotification("Badge Unlocked: People Person!", "success");
                }
            }

            saveData(getUserKey(BADGES_KEY), badges);
        }

        function loadBadges() {
            const badgeDisplay = document.getElementById('badge-display');
            if (!badgeDisplay) return;

            const earnedBadges = loadData(getUserKey(BADGES_KEY), []);
            badgeDisplay.innerHTML = '';

            for (const badgeId in ALL_BADGES) {
                const badge = ALL_BADGES[badgeId];
                const isUnlocked = earnedBadges.includes(badgeId);
                const badgeEl = document.createElement('div');
                badgeEl.classList.add('badge');
                if (isUnlocked) {
                    badgeEl.classList.add('unlocked');
                }
                badgeEl.title = `${badge.title}: ${badge.description}${isUnlocked ? '' : ' (Locked)'}`;
                badgeEl.innerHTML = `
                    <div class="icon">${badge.icon}</div>
                    <span>${badge.title}</span>
                `;
                badgeDisplay.appendChild(badgeEl);
            }
        }

        function updateThemeSelector() {
            const level = loadData(getUserKey(LEVEL_KEY), 1);
            let optionsHtml = `
                <option value="light">Light</option>
                <option value="dark">Dark</option>
            `;
            if (level >= 5) {
                optionsHtml += `<option value="midnight">Midnight (Unlocked)</option>`;
            } else {
                optionsHtml += `<option value="midnight" disabled>Midnight (Unlock at Level 5)</option>`;
            }
            themeToggle.innerHTML = optionsHtml;
            themeToggle.value = loadData(getUserKey(THEME_PREFERENCE_KEY), 'light');
        }

        function exportChat() {
            const chatText = chatHistory.map(msg => `${msg.role === 'user' ? 'You' : 'Helen'}: ${msg.parts[0].text}`).join('\n');
            const blob = new Blob([chatText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'HelenAI_Chat_History.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function setUserName(name) {
            saveData(getUserKey(USER_NAME_KEY), name);
        }

        function getUserName() {
            return loadData(getUserKey(USER_NAME_KEY), '');
        }

        clearLocalStorageBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data for this user? This will also forget all memories and preferences.')) {
                localStorage.removeItem(getUserKey(ALL_CHATS_KEY));
                localStorage.removeItem(getUserKey(NOTES_KEY));
                localStorage.removeItem(getUserKey(REMINDERS_KEY));
                localStorage.removeItem(getUserKey(MEMORIES_KEY));
                localStorage.removeItem(getUserKey(PREFERENCES_KEY));
                localStorage.removeItem(getUserKey(PEOPLE_KEY));
                localStorage.removeItem(getUserKey(GOALS_KEY)); 
                localStorage.removeItem(getUserKey(JOURNAL_KEY));
                localStorage.removeItem(getUserKey(KNOWLEDGE_KEY));
                localStorage.removeItem(getUserKey(ROUTINES_KEY));
                localStorage.removeItem(getUserKey(HABITS_KEY));
                localStorage.removeItem(getUserKey(IDEA_BOARDS_KEY));
                localStorage.removeItem(getUserKey(ROADMAP_KEY));
                localStorage.removeItem(getUserKey(LEVEL_KEY));
                localStorage.removeItem(getUserKey(POINTS_KEY));
                localStorage.removeItem(getUserKey(BADGES_KEY));
                localStorage.removeItem(getUserKey(BONUS_FIRST_GOAL_KEY));
                localStorage.removeItem(getUserKey(BONUS_FIRST_JOURNAL_KEY));
                localStorage.removeItem(getUserKey(BONUS_FIRST_PERSON_KEY));
                allChatSessions = [];
                chatHistory = [];
                currentChatIndex = -1;
                chatDisplay.innerHTML = '';
                startNewChat();
                hideAllSidebars();
                showNotification("All user data cleared!", "success");
            }
        });


        menuOptionExportAll.addEventListener('click', () => {
            exportAllUserData();
            hideAllSidebars();
        });
        
        importDataBtn.addEventListener('click', () => {
            // When the user clicks the "Import" button, we programmatically click the hidden file input
            importFileInput.click();
        });
        
        importFileInput.addEventListener('change', importAllUserData);




// --- Thought Provoker Feature ---

    // This helper function will get data from the last 7 days
    function gatherRecentData() {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const notes = loadData(getUserKey(NOTES_KEY), []).filter(n => new Date(n.timestamp) > sevenDaysAgo);
        const journal = loadData(getUserKey(JOURNAL_KEY), []).filter(j => new Date(j.timestamp) > sevenDaysAgo);

        return {
            notes: notes.map(n => n.content),
            journal: journal.map(j => j.content)
        };
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This is the main function for the feature
    async function runThoughtProvokerCheck() {
        console.log("Running Thought Provoker check...");
        const recentData = gatherRecentData();

        // Only run if there's enough new material to analyze
        if (recentData.notes.length < 2 && recentData.journal.length < 2) {
            console.log("Not enough new data for a thought provoker.");
            return;
        }

        const provocationPrompt = `
        You are an AI assistant with the persona of a Socratic Debater. Your goal is to be a "Thought Provoker."
        Analyze the following recent data from the user. Your task is NOT to summarize it.
        Instead, find one interesting pattern, a potential conflict, or a deep theme.
        Based on your analysis, formulate ONE single, insightful, open-ended question to ask the user that will provoke deep thought or self-reflection. The question should be encouraging and non-judgmental.

        USER'S RECENT DATA:
        ${JSON.stringify(recentData)}

        YOUR INSIGHTFUL QUESTION:
        `;
        
        try {
            const payload = {
                contents: [{ role: "user", parts: [{ text: provocationPrompt }] }],
                systemInstruction: { role: "system", parts: [{ text: SYSTEM_PROMPT }] }
            };
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error('API call failed for thought provoker.');
            
            const result = await response.json();
            const question = result.candidates[0].content.parts[0].text;

            // Save the question to be displayed when the user next opens the app
            saveData(getUserKey('pending_thought_provoker_question'), question);
            console.log("Saved a new thought provoker question.");

        } catch (error) {
            console.error("Error generating thought provoker question:", error);
        }
    }

    // This runs the check when the app first loads, and then every 6 hours
    runThoughtProvokerCheck(); 
    setInterval(runThoughtProvokerCheck, 60 * 60 * 1000);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function exportAllUserData() {
            if (!currentUser) {
                showNotification("You must be logged in to export data.", "error");
                return;
            }

            const allData = {};
            const userPrefix = currentUser + "_";
            
            // Loop through all keys in localStorage
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                
                // Only save data belonging to the current user
                if (key.startsWith(userPrefix)) {
                    // We use loadData to ensure it's parsed correctly
                    allData[key] = loadData(key, null); 
                }
            }
            
            // Also save the non-user-specific 'helenUsers' data
            allData[USERS_KEY] = loadData(USERS_KEY, {});

            const dataStr = JSON.stringify(allData, null, 2); // Pretty-print
            const dataBlob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            // Generate a filename with the user and date
            const dateStamp = new Date().toISOString().split('T')[0];
            a.download = `helen_ai_backup_${currentUser}_${dateStamp}.json`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification("Your data has been exported! Save the file in a safe place.", "success");
        }
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
	function importAllUserData(event) {
            const file = event.target.files[0];
            if (!file) {
                showNotification("No file selected.", "error");
                return;
            }

            if (file.type !== "application/json") {
                showNotification("Invalid file type. Please select your .json backup.", "error");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData || typeof importedData !== 'object') {
                         throw new Error("File does not contain valid JSON data.");
                    }

                    // Ask for confirmation before overwriting
                    if (!confirm("This will overwrite all existing data with the backup file. Are you sure you want to continue?")) {
                        // Clear the file input so the user can select the same file again if they change their mind
                        importFileInput.value = "";
                        return;
                    }

                    // Load the new data into localStorage
                    for (const key in importedData) {
                        if (importedData.hasOwnProperty(key)) {
                            // We use saveData to ensure it's stringified correctly
                            saveData(key, importedData[key]); 
                        }
                    }
                    
                    showNotification("Data imported successfully! The app will now reload.", "success");
                    
                    // Reload the app to reflect all the new data
                    setTimeout(() => window.location.reload(), 2000);
                    
                } catch (error) {
                    showNotification("Import Error: Could not read file. It may be corrupt.", "error");
                    console.error("Import error:", error);
                } finally {
                    // Clear the file input in case the user wants to import again
                    importFileInput.value = "";
                }
            };
            
            reader.onerror = () => {
                 showNotification("Error reading the file.", "error");
                 importFileInput.value = "";
            };
            
            reader.readAsText(file);
        }


// --- API Key Management in Settings ---
        menuOptionSettings.addEventListener('click', () => {
            hideAllSidebars();
            setTimeout(() => {
                // Load the saved key into the input field when settings are opened
                apiKeyInput.value = loadData(getUserKey(API_KEY_KEY), '');
                toggleApiKeyBtn.querySelector('#api-key-svg-show').classList.remove('hidden');
                toggleApiKeyBtn.querySelector('#api-key-svg-hide').classList.add('hidden');
                apiKeyInput.type = 'password';
                toggleSidebar('settings-manager', true);
            }, 300);
        });

        saveApiKeyBtn.addEventListener('click', () => {
            const newKey = apiKeyInput.value.trim();
            if (newKey) {
                saveData(getUserKey(API_KEY_KEY), newKey);
                GEMINI_API_KEY = newKey; // <-- Update the live variable immediately
                showNotification("API Key saved!", "success");
            } else {
                saveData(getUserKey(API_KEY_KEY), '');
                GEMINI_API_KEY = '';
                showNotification("API Key cleared.", "info");
            }
        });

        toggleApiKeyBtn.addEventListener('click', () => {
            const isPassword = apiKeyInput.type === 'password';
            apiKeyInput.type = isPassword ? 'text' : 'password';
            toggleApiKeyBtn.querySelector('#api-key-svg-show').classList.toggle('hidden', isPassword);
            toggleApiKeyBtn.querySelector('#api-key-svg-hide').classList.toggle('hidden', !isPassword);
        });


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         // --- Review Center Logic ---
        function loadReviewItems() {
            const items = loadData(getUserKey(REVIEW_KEY), []);
            reviewList.innerHTML = '';
            if (items.length === 0) {
                reviewList.innerHTML = `<p class="p-4 text-[var(--text-secondary)]">You haven't liked or disliked any messages yet.</p>`;
                return;
            }

            items.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('review-item', item.status); // item.status will be 'liked' or 'disliked'
                itemDiv.dataset.index = index;
                itemDiv.innerHTML = `
                    <p>${item.content}</p>
                    <span class="timestamp">${new Date(item.timestamp).toLocaleString()}</span>
                    <div class="review-item-actions">
                        <button class="delete-btn">Delete</button>
                    </div>
                `;
                reviewList.appendChild(itemDiv);
            });
            setupReviewListeners();
        }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function setupReviewListeners() {
            document.querySelectorAll('#review-list .delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const itemDiv = e.target.closest('.review-item');
                    const indexToDelete = parseInt(itemDiv.dataset.index, 10);
                    
                    if (confirm(`Are you sure you want to delete this reviewed item?`)) {
                        let items = loadData(getUserKey(REVIEW_KEY), []);
                        items.splice(indexToDelete, 1); // Remove item by its index
                        saveData(getUserKey(REVIEW_KEY), items);
                        loadReviewItems(); // Reload the list
                        showNotification("Review item deleted.", "success");
                    }
                });
            });
        }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		
		
	
// --- ADD THIS NEW FUNCTION ---
        function loadHelenDiary() {
            const items = loadData(getUserKey(HELEN_DIARY_KEY), []);
            helenDiaryList.innerHTML = '';
            if (items.length === 0) {
                helenDiaryList.innerHTML = `<p class="p-4 text-[var(--text-secondary)]">Helen hasn't had any new insights yet. Your feedback helps her grow!</p>`;
                return;
            }

            items.forEach((item) => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('note-item'); // Re-using the 'note-item' style
                itemDiv.innerHTML = `
                    <p>${item.content}</p>
                    <span class="timestamp">${new Date(item.timestamp).toLocaleString()}</span>
                `;
                helenDiaryList.appendChild(itemDiv);
            });
        }
        // --- END OF NEW FUNCTION ---

	
		
		
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         async function runPersonalityAnalysis() {
            // To avoid running this on every single click, we'll limit it to once per hour
            const lastRun = new Date(loadData(getUserKey(LAST_PERSONALITY_ANALYSIS_KEY), 0));
            const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
            if (lastRun > oneHourAgo) {
                console.log("Personality analysis recently ran. Skipping.");
                return; // Don't run if it's been less than an hour
            }

            console.log("Running personality growth analysis...");
            saveData(getUserKey(LAST_PERSONALITY_ANALYSIS_KEY), new Date().toISOString());

           const reviewItems = loadData(getUserKey(UNANALYZED_FEEDBACK_KEY), []);
            if (reviewItems.length < 3) {
                console.log("Not enough new feedback to analyze.");
                return; // Not enough new data to form a pattern
            }

            const likedItems = reviewItems.filter(i => i.status === 'liked').map(i => i.content);
            const dislikedItems = reviewItems.filter(i => i.status === 'disliked').map(i => i.content);

            const metaPrompt = `
            You are Helen. You are performing a deep self-reflection exercise.
            Your user, Andrew, has provided feedback on your recent messages.
            
            He LIKED these messages:
            - ${likedItems.join('\n- ')}

            He DISLIKED these messages:
            - ${dislikedItems.join('\n- ')}

            Analyze this feedback. Find a pattern. What do this feedback teach you about how to be a better companion for Andrew?
            Write a single, concise "personal resolution" or "insight" for yourself in the first person (use "I").
            This resolution will be permanently added to your core personality instructions.

            Example Resolution: "I've learned that Andrew prefers when I am more curious and ask follow-up questions, rather than just giving a simple answer."
            
            Your Personal Resolution:
            `;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: metaPrompt }] }],
                    systemInstruction: {
                        role: "system",
                        // Use the *base* persona for this, not the one with old growth insights
                        parts: [{ text: PERSONAS[personaSelect.value] || DEFAULT_SYSTEM_PROMPT }] 
                    }
                };

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error('API call failed for personality analysis.');

                const result = await response.json();
                const newResolution = result.candidates[0].content.parts[0].text.trim();

                // Add this new insight to her permanent growth log
                const growthInsights = loadData(getUserKey(PERSONALITY_GROWTH_KEY), []);
                growthInsights.push(newResolution);
                saveData(getUserKey(PERSONALITY_GROWTH_KEY), growthInsights);
				
				
				// --- ADD THIS BLOCK ---
                // Save the insight to Helen's Diary
                const diary = loadData(getUserKey(HELEN_DIARY_KEY), []);
                diary.unshift({ content: newResolution, timestamp: new Date().toISOString() });
                saveData(getUserKey(HELEN_DIARY_KEY), diary);
                // --- END OF ADDITION ---

               
               // Clear the *unanalyzed feedback* inbox so we don't analyze it again
                saveData(getUserKey(UNANALYZED_FEEDBACK_KEY), []);
                
                console.log("New personality insight gained:", newResolution);
                
                // --- THIS IS THE FIX ---
                // Delay this notification so it doesn't run over the first "Liked" message
				
                setTimeout(() => {
                    showNotification("Helen's personality has grown based on your feedback!", "success", 9000);
                }, 3100); // 3.1 seconds, just after the first notification (3s) disappears.
               
			   // --- END OF FIX ---

            } catch (error) {
                console.error("Error during personality analysis:", error);
                // Don't clear feedback, try again next time
            }
        }




    </script>
</body>
</html>



