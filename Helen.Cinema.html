<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN v3.1: TACTICAL + CINEMA</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 2px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
        
        /* DEBUG CONSOLE */
        #debug-log {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 150px;
            background: rgba(0,0,0,0.8); color: #ff0055; font-size: 12px;
            overflow-y: scroll; padding: 10px; z-index: 999; display: none;
            pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<canvas id="ambilight-canvas" width="32" height="32" style="display:none;"></canvas>
<div id="flash"></div>
<div id="debug-log"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN v3.1</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    
    <div class="status" id="system-status">
        [ SYSTEM BOOT ]<br>
        Waiting for modules...
    </div>

    <div id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button id="btn-init">INITIALIZE SYSTEM</button>
        <button id="btn-reset" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="btn-group" id="main-controls" style="display:none;">
        <button id="btn-load">üìÇ LOAD FILES</button>
        <button id="btn-tilt">üì± ENABLE FLIGHT</button>
        <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [TILT] PHONE TO FLY<br>
            [GAZE] LOOK AT RED SQUARE FOR MENU<br>
            [CINEMA] LOAD VIDEO FOR THEATER
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    // --- DEBUG LOGGING ---
    function log(msg) {
        console.log(msg);
        const d = document.getElementById('debug-log');
        d.style.display = 'block';
        d.innerHTML += `> ${msg}<br>`;
        d.scrollTop = d.scrollHeight;
    }
    window.onerror = function(msg, url, line) { log(`ERROR: ${msg} (Line ${line})`); };

    // --- VARIABLES ---
    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    let audioListener; 
    
    let reticle, cockpitGroup, cockpitPanels = [];
    let lastMenuToggleTime = 0;
    
    let currentSpeed = 0, targetSpeed = 0;
    let currentRot = 0, targetRot = 0;
    const MAX_SPEED = 0.08, MAX_ROT = 0.04;

    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition, synth = window.speechSynthesis;
    let isListening = false, isSpeaking = false, aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try {
        const saved = localStorage.getItem('helen_chat_history');
        if(saved) chatHistory = JSON.parse(saved);
    } catch(e) {}

    let CUSTOM_DATABASE = []; 
    // Default demo video
    const DEFAULT_DATABASE = [ 
        { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' }
    ];
    let targets = []; 
    
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 
    
    let isMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    const MOUSE_SENSITIVITY = 0.02;

    let isTiltActive = false;
    let tiltCalibration = { beta: 0, gamma: 0 };
    let currentTilt = { beta: 0, gamma: 0 };
    const TILT_DEADZONE = 5, TILT_SPEED = 0.002;

    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1, menuScrollIndex = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";
    
    let menuSelectionTimer = 0, gazeProgress = 0;       

    let activeCamId = null, currentVideoElement = null;
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false };
    
    const _moveDir = new THREE.Vector3(), _strafeDir = new THREE.Vector3();

    const AI_FOLLOW_DIST = 2.5, AI_WALK_SPEED = 0.03;

    let isCinemaMode = false;
    let cinemaGroup = null, cinemaLight = null, ambilightCtx = null, cinemaScreenMesh = null;
    const AMBILIGHT_INTENSITY = 2.0;

    // --- INIT BUTTONS ---
    document.getElementById('btn-init').addEventListener('click', () => {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 5) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else alert("INVALID KEY");
    });
    
    document.getElementById('btn-reset').addEventListener('click', () => {
        localStorage.clear(); location.reload();
    });

    document.getElementById('btn-load').addEventListener('click', () => {
        document.getElementById('intel-input').click();
    });

    document.getElementById('btn-tilt').addEventListener('click', () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
            .then(r => { if (r === 'granted') activateTilt(); else alert("DENIED"); })
            .catch(e => log(e));
        } else activateTilt();
    });

    function activateTilt() {
        sysMessage = "TILT ACTIVE"; updateMenuDisplay();
        isTiltActive = true;
        let calibrated = false;
        window.addEventListener('deviceorientation', (event) => {
            if (!event.beta) return;
            if (!calibrated) { tiltCalibration.beta = event.beta; tiltCalibration.gamma = event.gamma; calibrated = true; }
            currentTilt.beta = THREE.MathUtils.lerp(currentTilt.beta, event.beta - tiltCalibration.beta, 0.1);
            currentTilt.gamma = THREE.MathUtils.lerp(currentTilt.gamma, event.gamma - tiltCalibration.gamma, 0.1);
        });
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
                initVoice();
            } catch(e) { log("AI ERROR: " + e.message); }
        }
    }

    // --- CORE SETUP ---
    async function init3D() {
        try {
            scene = new THREE.Scene();
            dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100); dolly.add(camera);
            
            audioListener = new THREE.AudioListener(); camera.add(audioListener);

            // Camera Feed Texture
            const video = document.getElementById('camera-feed');
            await startCameraStream(); 
            
            const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; 
            
            // Vision Shader
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
            const fragmentShader = `
                uniform sampler2D tDiffuse; uniform float uMode; varying vec2 vUv;
                void main() {
                    vec4 c = texture2D(tDiffuse, vUv);
                    if (uMode > 2.5) gl_FragColor = vec4(0,0,0,1); // Black
                    else if (uMode > 0.5) { // Edge
                        float d = 0.001;
                        vec4 h = -1.0*texture2D(tDiffuse,vUv+vec2(-d,-d)) + -2.0*texture2D(tDiffuse,vUv+vec2(-d,0)) + -1.0*texture2D(tDiffuse,vUv+vec2(-d,d)) + 1.0*texture2D(tDiffuse,vUv+vec2(d,-d)) + 2.0*texture2D(tDiffuse,vUv+vec2(d,0)) + 1.0*texture2D(tDiffuse,vUv+vec2(d,d));
                        vec4 v = -1.0*texture2D(tDiffuse,vUv+vec2(-d,-d)) + -2.0*texture2D(tDiffuse,vUv+vec2(0,-d)) + -1.0*texture2D(tDiffuse,vUv+vec2(d,-d)) + 1.0*texture2D(tDiffuse,vUv+vec2(-d,d)) + 2.0*texture2D(tDiffuse,vUv+vec2(0,d)) + 1.0*texture2D(tDiffuse,vUv+vec2(d,d));
                        float val = length(sqrt(h*h + v*v));
                        gl_FragColor = val > 0.5 ? vec4(0,1,1,1) : vec4(0,0.05,0.1,1);
                    } else gl_FragColor = c;
                }
            `;

            camMaterial = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 } },
                vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
            });
            const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

            // HUD
            const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
            hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas);
            const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
            hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

            // Lighting
            cinemaLight = new THREE.PointLight(0xffffff, 0, 30); cinemaLight.position.set(0, 5, 0); scene.add(cinemaLight);
            scene.add(new THREE.DirectionalLight(0xffffff, 2)); scene.add(new THREE.AmbientLight(0xffffff, 1));
            ambilightCtx = document.getElementById('ambilight-canvas').getContext('2d');

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
            renderer.setPixelRatio(1); renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            createCockpit(); 
            createMenuSystem();
            
            const btn = VRButton.createButton(renderer); 
            document.getElementById('vr-btn-container').appendChild(btn);
            renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

            log("SYSTEM READY");
            animate();

        } catch(e) { log("CRITICAL INIT ERROR: " + e.message); }
    }

    async function startCameraStream() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await video.play();
        } catch(e) { log("CAMERA FAIL: " + e.message); }
    }

    // --- ANIMATION LOOP ---
    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            handleCockpit(); 
            updateMenuPosition(); 
            updateHUD(); 
            updateAmbilight(); 
            
            // AI Skeletons & Audio Orbs
            targets.forEach(t => { 
                if(t.userData.isModel && t.userData.aiActive) updateAI(t);
                if(t.userData.isAudio && t.userData.isPlaying) {
                    const s = 1.0 + Math.sin(Date.now() * 0.01) * 0.2;
                    t.scale.set(s,s,s);
                }
            }); 

            renderer.render(scene, camera); 
        });
    }

    // --- COCKPIT & MENU ---
    function createCockpit() {
        cockpitGroup = new THREE.Group();
        cockpitGroup.position.set(0, -1.6, -1.0); cockpitGroup.rotation.x = -Math.PI/2 + 0.2; 
        dolly.add(cockpitGroup);
        
        const fwd = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 3), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.5}));
        fwd.rotation.x = Math.PI/2; fwd.userData = { action: "FORWARD", baseScale: 1 };
        cockpitGroup.add(fwd); cockpitPanels.push(fwd);

        const menuBtn = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0055, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }));
        menuBtn.position.set(0, -0.6, 0); menuBtn.userData = { action: "TOGGLE_MENU", baseScale: 1 };
        cockpitGroup.add(menuBtn); cockpitPanels.push(menuBtn);

        const reticleGeo = new THREE.RingGeometry(0.015, 0.02, 32);
        reticle = new THREE.Mesh(reticleGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true }));
        reticle.position.z = -1; camera.add(reticle);
    }

    function handleCockpit() {
        if (!cockpitGroup || isCinemaMode) return;
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(cockpitPanels);
        
        targetSpeed = 0;
        cockpitPanels.forEach(p => { p.material.opacity = 0.5; p.scale.setScalar(p.userData.baseScale); });
        
        if (intersects.length > 0) {
            const p = intersects[0].object;
            p.material.opacity = 1; p.scale.setScalar(p.userData.baseScale*1.2);
            if (p.userData.action === "FORWARD") targetSpeed = MAX_SPEED;
            if (p.userData.action === "TOGGLE_MENU" && Date.now() - lastMenuToggleTime > 1500) {
                isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; 
                lastMenuToggleTime = Date.now();
                if(isMenuOpen) updateMenuPosition();
            }
        }
        
        if (isTiltActive && Math.abs(currentTilt.beta) > TILT_DEADZONE) {
            targetSpeed = (currentTilt.beta - TILT_DEADZONE) * -TILT_SPEED;
        }

        currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.1);
        if (Math.abs(currentSpeed) > 0.001) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, currentSpeed);
        }
    }

    // --- MENU SYSTEM ---
    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        menuMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true }));
        menuGroup.add(menuMesh); scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; ctx.fillStyle = 'rgba(0,10,20,0.9)'; ctx.fillRect(0,0,1024,1024);
        ctx.fillStyle = '#00ffff'; ctx.font = '60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL OS", 512, 80);
        
        const opts = ["SAVE MISSION", "LOAD MISSION", "CLEAR ALL", "VOICE COMMS", "VISUAL SCAN", "WIPE MEMORY", "CINEMA MODE"];
        const list = [...opts, ...CUSTOM_DATABASE.map(i => i.label)];
        
        ctx.textAlign = 'left'; ctx.font = '50px Courier New';
        let y = 180;
        for (let i = 0; i < 9; i++) {
            const idx = menuScrollIndex + i;
            if (idx >= list.length) break;
            ctx.fillStyle = (idx === hoveredFileIndex) ? '#fff' : '#00aaaa';
            ctx.fillText((idx === hoveredFileIndex ? "> " : "  ") + list[idx], 80, y);
            y += 70;
        }
        if(sysMessage) { ctx.fillStyle='#00ff00'; ctx.fillText(sysMessage, 100, 900); }
        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(idx) {
        if (idx === 0) saveMission();
        else if (idx === 1) loadMission();
        else if (idx === 2) { targets.forEach(t => deleteObject(t)); sysMessage="CLEARED"; }
        else if (idx === 3) { if(recognition) recognition.start(); else sysMessage="NO VOICE"; }
        else if (idx === 4) performVisualScan();
        else if (idx === 5) { chatHistory=[]; sysMessage="MEMORY WIPED"; }
        else if (idx === 6) { 
            const vid = CUSTOM_DATABASE.find(x => x.type === 'video');
            enterCinemaMode(vid || { src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4' });
        }
        else {
            const item = CUSTOM_DATABASE[idx - 7];
            if(item) {
                const pos = camera.getWorldPosition(new THREE.Vector3()).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(3));
                if(item.type === 'image') spawnScreen(pos, item);
                else if(item.type === 'video') enterCinemaMode(item);
                else if(item.type === 'pdf') spawnScreen(pos, item);
                else if(item.type === 'audio') spawnAudio(pos, item);
                else spawnModel(pos, item);
            }
        }
        isMenuOpen = false; menuGroup.visible = false;
    }
    
    // --- FILE INPUT ---
    document.getElementById('intel-input').addEventListener('change', async (e) => {
        for (let file of e.target.files) {
            let type = 'image';
            if(file.name.endsWith('.pdf')) type = 'pdf';
            if(file.type.includes('video')) type = 'video';
            if(file.type.includes('audio')) type = 'audio';
            if(file.name.endsWith('.glb')) type = 'glb';
            
            let item = { label: file.name.toUpperCase(), type: type, src: URL.createObjectURL(file) };
            if (type === 'pdf') item.buffer = await file.arrayBuffer();
            CUSTOM_DATABASE.push(item);
        }
        sysMessage = "FILES LOADED"; updateMenuDisplay();
    });

    // --- CINEMA LOGIC ---
    function enterCinemaMode(data) {
        if(isCinemaMode) exitCinemaMode();
        isCinemaMode = true;
        camMaterial.uniforms.uMode.value = 3.0; 
        cockpitGroup.visible = false;
        
        cinemaGroup = new THREE.Group();
        cinemaGroup.position.copy(camera.getWorldPosition(new THREE.Vector3()));
        scene.add(cinemaGroup);

        const video = document.createElement('video');
        video.src = data.src; video.crossOrigin = "anonymous"; video.loop = true; video.play();
        currentVideoElement = video;

        const geo = new THREE.CylinderGeometry(10, 10, 9, 32, 1, true, -Math.PI/1.5/2, Math.PI/1.5);
        geo.scale(-1, 1, 1);
        const mat = new THREE.MeshBasicMaterial({ map: new THREE.VideoTexture(video) });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.y = Math.PI;
        cinemaGroup.add(mesh);
        
        // Exit Button
        const exit = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.4), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        exit.position.set(0, -2, -5); exit.userData = { action: 'EXIT_CINEMA' };
        cinemaGroup.add(exit); targets.push(exit);
    }

    function exitCinemaMode() {
        isCinemaMode = false; camMaterial.uniforms.uMode.value = visionMode; cockpitGroup.visible = true;
        if(currentVideoElement) { currentVideoElement.pause(); currentVideoElement = null; }
        if(cinemaGroup) { scene.remove(cinemaGroup); cinemaGroup = null; }
        targets = targets.filter(t => t.userData.action !== 'EXIT_CINEMA');
    }

    function updateAmbilight() {
        if (!isCinemaMode || !currentVideoElement) return;
        ambilightCtx.drawImage(currentVideoElement, 0, 0, 32, 32);
        const p = ambilightCtx.getImageData(16, 16, 1, 1).data;
        cinemaLight.color.setRGB(p[0]/255, p[1]/255, p[2]/255);
        cinemaLight.intensity = AMBILIGHT_INTENSITY;
    }

    // --- SPAWNERS ---
    async function spawnScreen(pos, data) {
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
        mesh.position.copy(pos); mesh.lookAt(camera.position); scene.add(mesh); targets.push(mesh);
        
        if (data.type === 'pdf') {
            const pdf = await pdfjsLib.getDocument(data.buffer.slice(0)).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({scale:3});
            const cvs = document.createElement('canvas'); cvs.width=viewport.width; cvs.height=viewport.height;
            await page.render({canvasContext:cvs.getContext('2d'), viewport}).promise;
            mesh.material.map = new THREE.CanvasTexture(cvs); 
            mesh.scale.set(1.8 * (viewport.width/viewport.height), 1.8, 1);
        } else {
            new THREE.TextureLoader().load(data.src, t => { mesh.material.map=t; mesh.scale.set(1.8*(t.image.width/t.image.height), 1.8, 1); });
        }
    }

    function spawnAudio(pos, data) {
        const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3), new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true}));
        mesh.position.copy(pos); scene.add(mesh); targets.push(mesh);
        mesh.userData = { isAudio: true, isPlaying: false };
        // Simplified audio logic (browser autoplay policies block audio without interaction)
        const a = new Audio(data.src); a.loop=true; mesh.userData.audio = a;
    }
    
    function spawnModel(pos, data) {
        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        loader.load(data.src, (o) => {
            const m = data.type === 'fbx' ? o : o.scene;
            m.position.copy(pos); m.scale.setScalar(0.5); scene.add(m); targets.push(m);
            m.userData = { isModel: true, aiActive: true, skeleton: mapBones(m) };
        });
    }

    // --- HELPER ---
    function mapBones(m) {
        let skel = {}; m.traverse(o => { if(o.isBone && o.name.includes('Head')) skel.head = o; }); return skel;
    }
    function updateAI(m) {
        if(m.userData.skeleton.head) m.lookAt(camera.position); 
    }
    function deleteObject(o) { scene.remove(o); targets=targets.filter(t=>t!==o); }

    function updateMenuPosition() {
        if (!isMenuOpen) return;
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        menuGroup.position.copy(camera.position.clone().add(dir.multiplyScalar(2.5)));
        menuGroup.lookAt(camera.position);
    }
    
    function updateHUD() {
        if(!hudContext) return;
        const ctx = hudContext; ctx.clearRect(0,0,1024,1024);
        if(isCinemaMode) {
            ctx.fillStyle = '#00ffff'; ctx.font='40px Courier'; ctx.textAlign='center'; ctx.fillText("CINEMA MODE", 512, 900);
            // Gaze for exit
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            if (raycaster.intersectObjects(targets).find(x=>x.object.userData.action==='EXIT_CINEMA')) {
                gazeProgress += 0.02; if(gazeProgress>1) { exitCinemaMode(); gazeProgress=0; }
                ctx.beginPath(); ctx.arc(512,512,60,0,Math.PI*2*gazeProgress); ctx.strokeStyle='red'; ctx.lineWidth=10; ctx.stroke();
            } else gazeProgress=0;
        } else {
             // Normal Gaze
             if(isMenuOpen) {
                 raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                 const hit = raycaster.intersectObject(menuMesh)[0];
                 if(hit && hit.uv.y < 0.82) {
                     const idx = Math.floor((0.82 - hit.uv.y)/0.068) + menuScrollIndex;
                     if(idx !== hoveredFileIndex) { hoveredFileIndex = idx; menuSelectionTimer = Date.now(); updateMenuDisplay(); }
                     if (Date.now() - menuSelectionTimer > 1500) spawnFromMenu(idx);
                     // Draw gaze circle
                     gazeProgress = Math.min((Date.now()-menuSelectionTimer)/1500, 1);
                     ctx.beginPath(); ctx.arc(512,512,60,0,Math.PI*2*gazeProgress); ctx.strokeStyle='cyan'; ctx.lineWidth=10; ctx.stroke();
                 }
             }
        }
        hudTexture.needsUpdate = true;
    }

    function initVoice() {
        try {
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.onresult = (e) => askGemini(e.results[0][0].transcript);
        } catch(e) { log("VOICE NOT SUPPORTED"); }
    }
    async function askGemini(p) {
        if(!model) return;
        try {
            const res = await model.generateContent(p);
            const txt = res.response.text();
            let u = new SpeechSynthesisUtterance(txt); synth.speak(u);
        } catch(e) { log("AI ERROR"); }
    }
    function performVisualScan() {
        const c = document.createElement('canvas'); c.width=640; c.height=480;
        c.getContext('2d').drawImage(document.getElementById('camera-feed'),0,0,c.width,c.height);
        // Add Gemini vision logic here if needed
        sysMessage = "SCAN COMPLETE"; updateMenuDisplay();
    }
    
    // --- START ---
    if(GEMINI_KEY) checkAuth();
    if(localStorage.getItem('helen_layout_ai')) document.getElementById('restore-msg').style.display = 'block';
    
    // Ensure INIT is called
    window.addEventListener('load', () => { 
        log("WINDOW LOADED. Click INIT to start.");
        startCameraStream(); // Warm up camera
    });

</script>
</body>
</html>
