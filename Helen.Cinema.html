<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: TACTICAL OS V3.0 (CINEMA EDITION)</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 2px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
        /* Hidden canvas for Ambilight analysis */
        #ambilight-canvas { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<canvas id="ambilight-canvas" width="32" height="32"></canvas> <div id="flash"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN v3.0</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    
    <div class="status" id="system-status">
        [ COCKPIT MK.III ]<br>
        System Initialized.<br>
        Look DOWN at the Chevrons.
    </div>

    <div id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="btn-group" id="main-controls" style="display:none;">
        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD INTEL</button>
        <button onclick="requestTiltAccess()">üì± ENABLE TILT DRIVE</button>
        <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [TILT] PHONE TO FLY (FWD/BACK/SIDE)<br>
            [GAZE] LOOK AT RED SQUARE FOR MENU<br>
            [CINEMA] LOAD VIDEO FOR THEATER MODE
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    let audioListener; 
    
    // --- COCKPIT VARIABLES ---
    let reticle;
    let cockpitGroup; 
    let cockpitPanels = [];
    let lastMenuToggleTime = 0;
    
    let currentSpeed = 0;
    let targetSpeed = 0;
    let currentRot = 0;
    let targetRot = 0;

    const MAX_SPEED = 0.08;
    const MAX_ROT = 0.04;

    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition; 
    let synth = window.speechSynthesis;
    let isListening = false;
    let isSpeaking = false;
    let aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try {
        const saved = localStorage.getItem('helen_chat_history');
        if(saved) chatHistory = JSON.parse(saved);
    } catch(e) {}

    let CUSTOM_DATABASE = []; 
    // ADDED: Sample video for Cinema Mode testing
    const DEFAULT_DATABASE = [ 
        { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' }
    ];
    let targets = []; 
    
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 
    let pendingRestore = false; 

    // --- INPUT VARIABLES ---
    let isMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    const MOUSE_SENSITIVITY = 0.02;
    const VR_WALK_SPEED = 0.05;

    // --- TILT CONTROL VARIABLES ---
    let isTiltActive = false;
    let tiltCalibration = { beta: 0, gamma: 0 };
    let currentTilt = { beta: 0, gamma: 0 };
    const TILT_DEADZONE = 5; 
    const TILT_SPEED = 0.002;

    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let menuScrollIndex = 0; 
    let lastMenuScrollTime = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";
    
    // --- GAZE VARIABLES ---
    let menuSelectionTimer = 0; 
    let gazeProgress = 0;       
    let hoveredPageButton = null;

    // HUD Optimization
    let lastHudState = "";

    let activeCamId = null, currentVideoElement = null;
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false, dpadDown: false, dpadUp: false, dpadLeft: false, dpadRight: false };
    
    const SPEED = 0.1; 
    const ROTATE_SPEED = 0.05; 
    const MOVE_SPEED = 0.05;
    const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();
    const _camRight = new THREE.Vector3(); const _camUp = new THREE.Vector3();

    const AI_FOLLOW_DIST = 2.5; 
    const AI_STOP_DIST = 1.5;
    const AI_BACKUP_DIST = 0.8;
    const AI_WALK_SPEED = 0.03;

    // --- NEW: CINEMA MODE VARIABLES ---
    let isCinemaMode = false;
    let cinemaGroup = null;
    let cinemaLight = null;
    let ambilightCtx = null;
    let cinemaScreenMesh = null;
    const AMBILIGHT_INTENSITY = 2.0;

    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else {
            alert("KEY TOO SHORT.");
        }
    };

    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key');
        localStorage.removeItem('helen_layout_ai');
        localStorage.removeItem('helen_chat_history'); 
        location.reload();
    }
    
    window.requestTiltAccess = function() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') activateTiltListener();
                    else alert("Permission denied.");
                })
                .catch(console.error);
        } else {
            activateTiltListener();
        }
    };

    function activateTiltListener() {
        sysMessage = "TILT DRIVE ACTIVE"; updateMenuDisplay();
        isTiltActive = true;
        let calibrated = false;
        
        window.addEventListener('deviceorientation', (event) => {
            if (!event.beta || !event.gamma) return;
            if (!calibrated) {
                tiltCalibration.beta = event.beta;
                tiltCalibration.gamma = event.gamma;
                calibrated = true;
            }
            currentTilt.beta = THREE.MathUtils.lerp(currentTilt.beta, event.beta - tiltCalibration.beta, 0.1);
            currentTilt.gamma = THREE.MathUtils.lerp(currentTilt.gamma, event.gamma - tiltCalibration.gamma, 0.1);
        });
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Cockpit Mk.III Active.<br>Look DOWN to Pilot.`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ 
                    model: "gemini-2.5-flash",
                    systemInstruction: "You are HELEN, a tactical AI companion. Responses concise & robotic."
                });
                initVoice();
            } catch(e) { console.error("AI INIT FAILED", e); }
        }
    }

    function initVoice() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; if(aiStatus === "LISTENING...") aiStatus = "PROCESSING..."; updateHUD(); };
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                askGemini(transcript);
            };
        }
    }

    async function performVisualScan() {
        if (!model) return;
        aiStatus = "CAPTURING VISUALS..."; updateHUD();
        const flash = document.getElementById('flash');
        flash.style.opacity = 0.8;
        setTimeout(() => { flash.style.opacity = 0; }, 100);

        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('vision-canvas');
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        const base64Image = dataUrl.split(',')[1]; 

        aiStatus = "ANALYZING TARGET..."; updateHUD();
        try {
            const prompt = "Analyze this image tactically.";
            const imagePart = { inlineData: { data: base64Image, mimeType: "image/jpeg" } };
            const result = await model.generateContent([prompt, imagePart]);
            const response = await result.response;
            speak(response.text());
        } catch (error) {
            aiStatus = "VISUAL ERROR";
            speak("Visual sensors malfunctioned.");
        }
    }

    async function askGemini(prompt) {
        aiStatus = "THINKING..."; updateHUD();
        try {
            const chat = model.startChat({
                history: chatHistory,
                generationConfig: { maxOutputTokens: 100 },
            });
            const result = await chat.sendMessage(prompt);
            const text = await result.response.text();
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            if(chatHistory.length > 20) chatHistory = chatHistory.slice(chatHistory.length - 20);
            saveMemory();
            speak(text);
        } catch (error) {
            aiStatus = "ERR: NET";
            speak("System Error.");
        }
    }
    
    function saveMemory() { localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory)); }
    function wipeMemory() {
        chatHistory = [];
        localStorage.removeItem('helen_chat_history');
        sysMessage = "MEMORY WIPED";
        speak("Memory banks cleared.");
        updateMenuDisplay();
    }

    function speak(text) {
        if (synth.speaking) synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1; utterance.pitch = 1.0;
        const voices = synth.getVoices();
        const preferred = voices.find(v => v.name.includes("Google US English") || v.name.includes("Female"));
        if(preferred) utterance.voice = preferred;
        utterance.onstart = () => { isSpeaking = true; aiStatus = "SPEAKING"; updateHUD(); };
        utterance.onend = () => { isSpeaking = false; aiStatus = "STANDBY"; updateHUD(); };
        synth.speak(utterance);
    }
    
    if(GEMINI_KEY) checkAuth();

    if (localStorage.getItem('helen_layout_ai')) {
        document.getElementById('restore-msg').style.display = 'block';
        pendingRestore = true;
    }

    const input = document.getElementById('intel-input');
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                let type = 'image'; 
                
                if (name.endsWith('.PDF')) type = 'pdf';
                else if (name.endsWith('.FBX')) type = 'fbx';
                else if (name.endsWith('.GLB') || name.endsWith('.GLTF')) type = 'glb';
                else if (name.endsWith('.MP3') || name.endsWith('.WAV')) type = 'audio';
                else if (name.endsWith('.CSV')) type = 'chart';
                else if (file.type.startsWith('video')) type = 'video';
                else if (file.type.startsWith('image')) type = 'image';
                
                let src = URL.createObjectURL(file);
                if (type === 'pdf') {
                    const buffer = await file.arrayBuffer();
                    CUSTOM_DATABASE.push({ type: 'pdf', buffer: buffer, label: name });
                } else if (type === 'chart') {
                    const text = await file.text();
                    CUSTOM_DATABASE.push({ type: 'chart', data: text, label: name });
                } else {
                    CUSTOM_DATABASE.push({ type: type, src: src, label: name });
                }
            }
            input.value = ''; 
            sysMessage = "FILES LOADED"; updateMenuDisplay();
        }
    });

    function saveMission() {
        const layout = targets.map(t => {
            if(t === cinemaGroup) return null; // Don't save cinema mode
            return {
                label: t.userData.label,
                pos: t.position,
                rot: t.rotation,
                scale: t.scale,
                type: t.userData.type
            };
        }).filter(t => t !== null);
        localStorage.setItem('helen_layout_ai', JSON.stringify(layout));
        sysMessage = "MISSION SAVED"; updateMenuDisplay(); 
        setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function loadMission() {
        const raw = localStorage.getItem('helen_layout_ai');
        if (!raw) { sysMessage = "NO DATA FOUND"; updateMenuDisplay(); return; }
        const layout = JSON.parse(raw);
        let restoredCount = 0;
        layout.forEach(item => {
            const dbItem = CUSTOM_DATABASE.find(f => f.label === item.label) || DEFAULT_DATABASE[0];
            if (dbItem) {
                const pos = new THREE.Vector3(item.pos.x, item.pos.y, item.pos.z);
                const rot = new THREE.Euler(item.rot._x, item.rot._y, item.rot._z);
                const scale = item.scale ? new THREE.Vector3(item.scale.x, item.scale.y, item.scale.z) : null;
                
                if (dbItem.type === 'fbx' || dbItem.type === 'glb') spawnModel(pos, dbItem, rot, scale);
                else if (dbItem.type === 'audio') spawnAudio(pos, dbItem);
                else if (dbItem.type === 'chart') spawnChart(pos, dbItem);
                else spawnScreen(pos, dbItem, rot);
                restoredCount++;
            }
        });
        sysMessage = `RESTORED ${restoredCount} UNITS`; updateMenuDisplay(); 
    }

    function clearMission() {
        localStorage.removeItem('helen_layout_ai');
        [...targets].forEach(t => deleteObject(t));
        sysMessage = "DATABASE WIPED"; updateMenuDisplay();
    }

    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front'));
        startCameraStream(cameras.length > 0 ? cameras[0].deviceId : null);
    }

    async function startCameraStream(preferredId) {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            const constraints = preferredId ? { video: { deviceId: { exact: preferredId } } } : { video: { facingMode: 'environment' } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            await video.play();
            currentStream = stream;
            videoTrack = stream.getVideoTracks()[0];
            if (camMaterial) {
                camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
                camMaterial.uniforms.tDiffuse.value.colorSpace = THREE.SRGBColorSpace;
            }
        } catch (err) {}
    }

    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            if (uMode > 2.5) { // CINEMA MODE (BLACK)
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else if (uMode > 1.5) { // VOID MODE
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else if (uMode > 0.5) { // EDGE MODE
                float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                vec4 horizEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) + -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec4 vertEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) + -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
            } else gl_FragColor = color; 
        }
    `;
    
    function initMouseControl() {
        function getPos(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        window.addEventListener('contextmenu', (e) => { e.preventDefault(); });

        const onDown = (e) => {
            if (e.button === 2) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; return; }
            if (isMenuOpen) return;
            if (e.button === 0 || e.type === 'touchstart') {
                isMouseDown = true;
                const pos = getPos(e);
                previousMousePosition = pos;
            }
        };

        const onUp = () => { isMouseDown = false; };

        const onMove = (e) => {
            if (!isMouseDown || !dolly || isMenuOpen || isCinemaMode) return; // LOCK MOVEMENT IN CINEMA
            if(e.preventDefault) e.preventDefault();
            if (!renderer.xr.isPresenting) {
                const pos = getPos(e);
                const deltaX = pos.x - previousMousePosition.x;
                const deltaY = pos.y - previousMousePosition.y;
                previousMousePosition = pos;
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -deltaY * MOUSE_SENSITIVITY);
                dolly.position.addScaledVector(_strafeDir, deltaX * MOUSE_SENSITIVITY);
            }
        };

        window.addEventListener('mousedown', onDown);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchmove', onMove, { passive: false });
    }

    function createCockpit() {
        if(cockpitGroup) { dolly.remove(cockpitGroup); }
        cockpitGroup = new THREE.Group();
        cockpitGroup.position.set(0, -1.6, -1.0); 
        cockpitGroup.rotation.x = -Math.PI / 2 + 0.2; 
        dolly.add(cockpitGroup);
        cockpitPanels = [];

        // Simple Chevron for Cockpit
        const fwd = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 3), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.5}));
        fwd.rotation.x = Math.PI / 2;
        fwd.userData = { action: "FORWARD", baseScale: 1 };
        cockpitGroup.add(fwd); cockpitPanels.push(fwd);

        // Menu Button
        const menuBtn = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0055, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }));
        menuBtn.position.set(0, -0.6, 0); 
        menuBtn.userData = { action: "TOGGLE_MENU", baseScale: 1 };
        cockpitGroup.add(menuBtn); cockpitPanels.push(menuBtn);

        if(!reticle) {
            const ringGeo = new THREE.RingGeometry(0.015, 0.02, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(ringGeo, ringMat);
            reticle.position.z = -1;
            camera.add(reticle);
        }
    }

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100); dolly.add(camera);
        
        audioListener = new THREE.AudioListener();
        camera.add(audioListener);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps = false; 
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
            vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

        // HUD Setup
        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas); hudTexture.minFilter = THREE.LinearFilter;
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        // Ambilight Setup
        ambilightCtx = document.getElementById('ambilight-canvas').getContext('2d');
        cinemaLight = new THREE.PointLight(0xffffff, 0, 30);
        cinemaLight.position.set(0, 5, 0);
        scene.add(cinemaLight);

        const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(0, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 1));
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" }); 
        renderer.setPixelRatio(1); 
        renderer.setSize(window.innerWidth, window.innerHeight); 
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        initMouseControl();
        createCockpit(); 
        const btn = VRButton.createButton(renderer); btn.className = "primary"; document.getElementById('vr-btn-container').appendChild(btn);
        
        renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

        createMenuSystem();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        animate();
    }

    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        menuGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; const w = 1024; const h = 1024;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        
        ctx.fillStyle = 'rgba(0, 10, 20, 0.9)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const sysOpts = [
            { label: "[SAVE MISSION]", type: "sys" },
            { label: "[LOAD MISSION]", type: "sys" },
            { label: "[CLEAR ALL]", type: "sys" },
            { label: "[VOICE COMMS]", type: "sys" },
            { label: "[VISUAL SCAN]", type: "sys" },
            { label: "[WIPE MEMORY]", type: "sys" },
            { label: "[CINEMA MODE]", type: "sys" } // NEW
        ];
        
        const fullList = [...sysOpts, ...db];
        
        ctx.textAlign = 'left'; ctx.font = '50px Courier New';
        let listY = 180;
        
        for (let i = 0; i < MAX_MENU_VISIBLE; i++) {
            const realIndex = menuScrollIndex + i;
            if (realIndex >= fullList.length) break;
            const item = fullList[realIndex];
            const isHovered = (realIndex === hoveredFileIndex);
            
            if (isHovered) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 60, 60);
                ctx.fillStyle = '#fff'; ctx.fillText(`> ${item.label}`, 80, listY);
            } else {
                ctx.fillStyle = item.type === 'sys' ? '#ff0055' : '#00aaaa';
                ctx.fillText(`  ${item.label}`, 80, listY);
            }
            if (item.type !== 'sys') { ctx.fillStyle = '#666'; ctx.fillText(item.type.toUpperCase(), w - 200, listY); }
            listY += 70;
        }

        if (sysMessage) {
            ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100);
            ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(sysMessage, w/2, h/2 + 15);
        }
        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(index) {
        if (index === 0) { saveMission(); return; }
        if (index === 1) { loadMission(); return; }
        if (index === 2) { clearMission(); return; }
        if (index === 3) { if(recognition) recognition.start(); else sysMessage = "VOICE NOT READY"; updateMenuDisplay(); return; }
        if (index === 4) { performVisualScan(); updateMenuDisplay(); setTimeout(()=>{ isMenuOpen=false; menuGroup.visible=false; }, 500); return; }
        if (index === 5) { wipeMemory(); return; }
        if (index === 6) { 
            // DEFAULT CINEMA (Demo Video)
             // Find a video in DB or use default
             const vid = CUSTOM_DATABASE.find(x => x.type === 'video');
             if(vid) enterCinemaMode(vid);
             else { sysMessage = "LOAD VIDEO FIRST"; updateMenuDisplay(); }
             return; 
        }

        const fileIndex = index - 7; 
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        
        if (fileIndex >= 0 && fileIndex < db.length) {
            const item = db[fileIndex];
            if(item.type === 'video') {
                // Ask or Default to Cinema? Let's default to Cinema for this "Edition"
                enterCinemaMode(item);
                isMenuOpen = false; menuGroup.visible = false;
                return;
            }

            // Normal Spawn Logic
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const pos = camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(3));
            if (item.type === 'fbx' || item.type === 'glb') { pos.y = 0; spawnModel(pos, item); }
            else if (item.type === 'audio') { pos.y = 1.6; spawnAudio(pos, item); }
            else if (item.type === 'chart') { pos.y = 1.0; spawnChart(pos, item); }
            else { pos.y = 1.6; spawnScreen(pos, item); }
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    // --- NEW: CINEMA LOGIC ---
    function enterCinemaMode(data) {
        if(isCinemaMode) exitCinemaMode();
        isCinemaMode = true;
        camMaterial.uniforms.uMode.value = 3.0; // Black Background
        cockpitGroup.visible = false; // Hide cockpit

        cinemaGroup = new THREE.Group();
        
        // Align to user gaze
        const pos = camera.getWorldPosition(new THREE.Vector3());
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
        cinemaGroup.position.copy(pos);
        cinemaGroup.lookAt(pos.clone().add(dir));
        
        scene.add(cinemaGroup);

        // Create Video Element
        const videoElem = document.createElement('video'); 
        videoElem.src = data.src; 
        videoElem.crossOrigin = "anonymous"; 
        videoElem.loop = true; videoElem.playsInline = true;
        videoElem.play();
        currentVideoElement = videoElem;
        
        const tex = new THREE.VideoTexture(videoElem);
        tex.colorSpace = THREE.SRGBColorSpace;

        // Curved Screen (Imitating A-Frame curvedimage)
        // Cylinder Geometry: Open ended, flip side to view from inside
        const radius = 10;
        const height = 9;
        const angle = Math.PI / 1.5; // 120 degrees
        const geometry = new THREE.CylinderGeometry(radius, radius, height, 32, 1, true, -angle/2, angle);
        geometry.scale(-1, 1, 1); // Flip inside out
        
        const material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        cinemaScreenMesh = new THREE.Mesh(geometry, material);
        cinemaScreenMesh.position.set(0, 0, 0); 
        cinemaScreenMesh.rotation.y = Math.PI; // Face the user
        cinemaGroup.add(cinemaScreenMesh);

        // Exit Button (Floating below)
        const exitGeo = new THREE.PlaneGeometry(1, 0.4);
        const exitMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const exitBtn = new THREE.Mesh(exitGeo, exitMat);
        exitBtn.position.set(0, -2, -5);
        exitBtn.userData = { isButton: true, action: 'EXIT_CINEMA' };
        
        // Text for button
        const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
        const ctx = canvas.getContext('2d'); ctx.fillStyle='white'; ctx.font='40px Courier'; ctx.fillText("EXIT CINEMA", 20, 50);
        const t = new THREE.CanvasTexture(canvas);
        const txtMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.25), new THREE.MeshBasicMaterial({map:t, transparent:true}));
        txtMesh.position.z = 0.01; exitBtn.add(txtMesh);
        
        cinemaGroup.add(exitBtn);
        targets.push(exitBtn);

        sysMessage = "CINEMA MODE ACTIVE"; updateMenuDisplay();
    }

    function exitCinemaMode() {
        isCinemaMode = false;
        camMaterial.uniforms.uMode.value = visionMode; // Restore vision
        cockpitGroup.visible = true;

        if (currentVideoElement) { currentVideoElement.pause(); currentVideoElement = null; }
        if (cinemaGroup) { 
            scene.remove(cinemaGroup); 
            // Clean up meshes
            cinemaGroup.traverse(o => { if(o.isMesh) { o.geometry.dispose(); if(o.material.map) o.material.map.dispose(); } });
            cinemaGroup = null; 
        }
        cinemaLight.intensity = 0;
        
        // Remove cinema targets
        targets = targets.filter(t => t.userData.action !== 'EXIT_CINEMA');
    }

    function updateAmbilight() {
        if (!isCinemaMode || !currentVideoElement || !ambilightCtx) return;
        try {
            ambilightCtx.drawImage(currentVideoElement, 0, 0, 32, 32);
            const p = ambilightCtx.getImageData(16, 16, 1, 1).data;
            const color = new THREE.Color(`rgb(${p[0]}, ${p[1]}, ${p[2]})`);
            cinemaLight.color.lerp(color, 0.1);
            cinemaLight.intensity = AMBILIGHT_INTENSITY;
        } catch(e) {}
    }

    // --- HELPER FUNCTIONS ---
    function spawnModel(position, data, rotation = null, scale = null) {
        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        loader.load(data.src, (loaded) => {
            const model = data.type === 'fbx' ? loaded : loaded.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z) || 1; 
            const scaleFactor = 1.0 / maxDim; 
            model.scale.set(scaleFactor, scaleFactor, scaleFactor);
            if (scale) model.scale.copy(scale);
            model.position.copy(position);
            if (rotation) model.rotation.copy(rotation);
            model.userData = { isScreen: true, isModel: true, label: data.label, type: data.type };
            scene.add(model); targets.push(model);
        });
    }

    function spawnScreen(position, data, rotation = null) {
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity:0.9 });
        const screen = new THREE.Mesh(geometry, material);
        screen.position.copy(position); 
        if(rotation) screen.rotation.copy(rotation); else screen.lookAt(camera.getWorldPosition(new THREE.Vector3()));
        
        if (data.type === 'image') {
            new THREE.TextureLoader().load(data.src, (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace; screen.material.map = tex;
                screen.scale.set(1.8 * (tex.image.width/tex.image.height), 1.8, 1);
            });
        }
        screen.userData = { isScreen: true, label: data.label, type: data.type };
        scene.add(screen); targets.push(screen);
    }
    
    function spawnAudio(pos, data) {
         // Placeholder for audio logic
    }
    function spawnChart(pos, data) {
         // Placeholder for chart logic
    }

    function deleteObject(obj) {
        scene.remove(obj); targets = targets.filter(t => t !== obj);
    }

    function handleCockpit() {
        if (!cockpitGroup || isCinemaMode) return; // Disable cockpit in cinema
        
        // Simple Gaze-based flight logic
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(cockpitPanels, false);

        targetSpeed = 0; targetRot = 0;
        
        cockpitPanels.forEach(p => { p.material.opacity = 0.5; p.scale.setScalar(p.userData.baseScale); });

        if (intersects.length > 0) {
            const p = intersects[0].object;
            p.material.opacity = 1.0; p.scale.setScalar(p.userData.baseScale * 1.2);
            if (p.userData.action === "FORWARD") targetSpeed = MAX_SPEED;
            if (p.userData.action === "TOGGLE_MENU") {
                if (Date.now() - lastMenuToggleTime > 1500) { 
                    isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; 
                    if(isMenuOpen) updateMenuPosition(); 
                    lastMenuToggleTime = Date.now();
                }
            }
        }
        
        // Tilt Drive Override
        if (isTiltActive) {
            if (Math.abs(currentTilt.beta) > TILT_DEADZONE) targetSpeed = (currentTilt.beta - TILT_DEADZONE) * -TILT_SPEED;
        }

        currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.1);
        if (Math.abs(currentSpeed) > 0.001) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, currentSpeed);
        }
    }

    function updateMenuPosition() {
        if (!isMenuOpen || !menuGroup) return;
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
        menuGroup.position.copy(camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(2.5))); 
        menuGroup.lookAt(camera.getWorldPosition(new THREE.Vector3()));
    }

    function handleInput() {
        const pads = navigator.getGamepads();
        const pad = pads[0] || pads[1]; // simplified

        // GAMEPAD CINEMA CONTROLS
        if (isCinemaMode && pad && currentVideoElement) {
            if (pad.buttons[0].pressed && !lastBtn.x) { // X / A Button
                if(currentVideoElement.paused) currentVideoElement.play(); else currentVideoElement.pause();
            }
            if (pad.buttons[1].pressed && !lastBtn.circle) { // Circle / B Button
                exitCinemaMode();
            }
            if (pad.axes[0] < -0.5) currentVideoElement.currentTime -= 0.1; // Seek Back
            if (pad.axes[0] > 0.5) currentVideoElement.currentTime += 0.1; // Seek Fwd
            
            lastBtn.x = pad.buttons[0].pressed;
            lastBtn.circle = pad.buttons[1].pressed;
            return; // Skip other inputs
        }

        // STANDARD INPUTS
        if (isCinemaMode) {
             // Just gaze for exit button
             raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
             const intersects = raycaster.intersectObjects(targets);
             if (intersects.length > 0 && intersects[0].object.userData.action === 'EXIT_CINEMA') {
                 gazeProgress += 0.02;
                 if(gazeProgress >= 1) { exitCinemaMode(); gazeProgress = 0; }
             } else gazeProgress = 0;
             return;
        }

        // ... Existing Gaze Logic for Menu ...
        if (isMenuOpen && menuMesh) {
             raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
             const intersects = raycaster.intersectObject(menuMesh);
             if (intersects.length > 0) {
                 const uvY = intersects[0].uv.y;
                 if (uvY < 0.82) {
                     const visualIdx = Math.floor((0.82 - uvY) / 0.068);
                     const realIdx = visualIdx + menuScrollIndex;
                     if(realIdx !== hoveredFileIndex) { hoveredFileIndex = realIdx; menuSelectionTimer = Date.now(); updateMenuDisplay(); }
                     else {
                         const elapsed = Date.now() - menuSelectionTimer;
                         gazeProgress = Math.min(elapsed / 1500, 1.0);
                         if(elapsed > 1500) { spawnFromMenu(realIdx); hoveredFileIndex = -1; menuSelectionTimer = Date.now() + 5000; }
                     }
                 }
             } else { if(hoveredFileIndex !== -1) { hoveredFileIndex = -1; updateMenuDisplay(); } }
        }
        
        // ... Gamepad standard ...
        if (pad) {
            if (pad.buttons[3].pressed && !lastBtn.triangle) {
                visionMode = (visionMode + 1) % 3;
                if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
            }
            lastBtn.triangle = pad.buttons[3].pressed;
        }
    }

    function updateHUD() {
        if(!hudContext) return;
        const currentState = `M:${isMenuOpen}|S:${isSpeaking}|L:${isListening}|V:${visionMode}|C:${isCinemaMode}|P:${gazeProgress.toFixed(2)}`;
        if (currentState === lastHudState) return;
        lastHudState = currentState; 

        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        const cx = w/2; const cy = h/2;

        if (isCinemaMode) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.font = '30px Courier New';
            ctx.fillText("CINEMA MODE ACTIVE", cx, h - 100);
            if (gazeProgress > 0) {
                ctx.beginPath(); ctx.arc(cx, cy, 60, 0, Math.PI * 2 * gazeProgress);
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 10; ctx.stroke();
            }
        } else {
            // Normal HUD
            ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
            if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
            else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }
            ctx.textAlign = 'left'; ctx.fillText(`AI: [${aiStatus}]`, 40, 60);

            if (gazeProgress > 0.05) {
                ctx.beginPath(); ctx.arc(cx, cy, 60, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * gazeProgress));
                ctx.lineWidth = 10; ctx.strokeStyle = '#00ffff'; ctx.stroke();
            }
            if(!isMenuOpen) {
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; 
                ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
            }
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            handleCockpit(); 
            updateMenuPosition(); 
            updateHUD(); 
            updateAmbilight(); // RUN AMBILIGHT
            renderer.render(scene, camera); 
        });
    }
</script>
</body>
</html>
