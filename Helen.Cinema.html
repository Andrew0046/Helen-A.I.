<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: CINEMA OS (HYBRID)</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: none; /* Let clicks pass through to hidden inputs */
        }
        .interactive { pointer-events: auto; }
        
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; pointer-events: auto; }
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 2px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; pointer-events: auto; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
        
        /* Ambilight Canvas (Hidden) */
        #light-canvas { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<canvas id="light-canvas" width="32" height="32"></canvas>
<div id="flash"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN: CINEMA</h1>
    
    <div class="status" id="system-status">
        [ THEATER PROTOCOL v1.0 ]<br>
        3D Environment / Media Integration.<br>
        Initialize to proceed.
    </div>

    <div id="api-container" class="interactive">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="btn-group interactive" id="main-controls" style="display:none;">
        <button onclick="document.getElementById('intel-input').click()">ðŸ“‚ LOAD MEDIA / DATA</button>
        <button onclick="requestTiltAccess()">ðŸ“± ENABLE GYRO</button>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [TILT/WASD] MOVE CAMERA<br>
            [LOOK DOWN] COCKPIT CONTROLS<br>
            [GAZE] SELECT ITEMS<br>
            [MEDIA] AUTO-DETECTS VIDEO/AUDIO
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    // --- CORE THREE.JS VARIABLES ---
    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    let audioListener; 
    
    // --- HELEN VARIABLES ---
    let reticle;
    let cockpitGroup; 
    let cockpitPanels = [];
    let lastMenuToggleTime = 0;
    let currentSpeed = 0, targetSpeed = 0;
    let currentRot = 0, targetRot = 0;
    
    // --- CINEMA VARIABLES (MERGED) ---
    let cinemaGroup, cinemaScreen, cinemaBacklight;
    let videoTexture, activeVideoElement;
    let isCinemaActive = false;
    let cinemaMode = 0; // 0=Curved, 1=180, 2=360
    let ambilightCanvas, ambilightCtx;
    let cinemaControls = []; // Specific cockpit buttons for media

    // --- AI VARIABLES ---
    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model, recognition, synth = window.speechSynthesis;
    let isListening = false, isSpeaking = false, aiStatus = "STANDBY"; 
    let chatHistory = [];

    // --- DATA ---
    let CUSTOM_DATABASE = []; 
    let targets = []; // Things we can look at
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 

    // --- INPUT ---
    let isMouseDown = false, prevMouse = { x: 0, y: 0 };
    let isTiltActive = false, tiltCalibration = { beta: 0, gamma: 0 }, currentTilt = { beta: 0, gamma: 0 };
    let menuGroup, menuMesh, menuCtx, menuTexture, isMenuOpen = false;
    let hoveredFileIndex = -1, menuScrollIndex = 0;
    let menuSelectionTimer = 0, gazeProgress = 0;
    let sysMessage = "";

    // --- CONSTANTS ---
    const MAX_SPEED = 0.08, MAX_ROT = 0.04;
    const MOUSE_SENSITIVITY = 0.02;
    const VR_WALK_SPEED = 0.05;
    const TILT_DEADZONE = 5, TILT_SPEED = 0.002;
    const _moveDir = new THREE.Vector3(), _strafeDir = new THREE.Vector3();

    // ==========================================
    // 1. SYSTEM INITIALIZATION
    // ==========================================

    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else { alert("KEY TOO SHORT."); }
    };

    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key');
        localStorage.removeItem('helen_chat_history'); 
        location.reload();
    }
    
    window.requestTiltAccess = function() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => { if (response === 'granted') activateTiltListener(); })
                .catch(console.error);
        } else { activateTiltListener(); }
    };

    function activateTiltListener() {
        sysMessage = "GYRO LINKED"; updateMenuDisplay();
        isTiltActive = true;
        let calibrated = false;
        window.addEventListener('deviceorientation', (event) => {
            if (!event.beta || !event.gamma) return;
            if (!calibrated) { tiltCalibration.beta = event.beta; tiltCalibration.gamma = event.gamma; calibrated = true; }
            currentTilt.beta = THREE.MathUtils.lerp(currentTilt.beta, event.beta - tiltCalibration.beta, 0.1);
            currentTilt.gamma = THREE.MathUtils.lerp(currentTilt.gamma, event.gamma - tiltCalibration.gamma, 0.1);
        });
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Cinema Modules Loaded.<br>Look DOWN for Controls.`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ model: "gemini-2.5-flash", systemInstruction: "You are HELEN, a tactical AI. You control a media interface. Commands: Play, Pause, Scan." });
                initVoice();
            } catch(e) { console.error("AI INIT FAILED", e); }
        }
    }

    // ==========================================
    // 2. FILE LOADING & CINEMA LOGIC
    // ==========================================

    const input = document.getElementById('intel-input');
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                let type = 'unknown';
                
                if (file.type.startsWith('video')) type = 'video';
                else if (file.type.startsWith('image')) type = 'image';
                else if (file.type.startsWith('audio')) type = 'audio';
                else if (name.endsWith('.PDF')) type = 'pdf';
                else if (name.endsWith('.GLB') || name.endsWith('.GLTF')) type = 'glb';

                // Store object URL
                CUSTOM_DATABASE.push({ type: type, src: URL.createObjectURL(file), label: name, file: file });
            }
            input.value = ''; 
            sysMessage = "FILES LOADED";
            updateMenuDisplay();
        }
    });

    function spawnFromMenu(index) {
        // System Commands
        if (index === 0) { 
            // Toggle Camera/Void
            if (camMaterial.uniforms.uMode.value === 0) {
                camMaterial.uniforms.uMode.value = 2; // Void
                sysMessage = "VOID MODE";
            } else {
                camMaterial.uniforms.uMode.value = 0; // Camera
                sysMessage = "AR MODE";
            }
            updateMenuDisplay();
            return;
        } 
        if (index === 1) { performVisualScan(); updateMenuDisplay(); return; }
        
        // File Loading
        const fileIndex = index - 2; 
        const item = CUSTOM_DATABASE[fileIndex];
        
        if (item) {
            if (item.type === 'video') {
                initCinemaMode(item);
            } else if (item.type === 'image') {
                spawnScreen(item);
            } else if (item.type === 'glb') {
                const pos = camera.getWorldPosition(new THREE.Vector3()).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(3));
                spawnModel(pos, item);
            }
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    // --- THE CORE CINEMA ENGINE (MERGED) ---
    function initCinemaMode(data) {
        // Clear previous cinema
        if(activeVideoElement) { activeVideoElement.pause(); activeVideoElement.remove(); }
        if(cinemaGroup) { scene.remove(cinemaGroup); targets = targets.filter(t => t !== cinemaScreen); }

        isCinemaActive = true;
        
        // Switch to Dark Environment for viewing
        camMaterial.uniforms.uMode.value = 2; // Force Void Mode
        
        // Create Video Element
        activeVideoElement = document.createElement('video');
        activeVideoElement.src = data.src;
        activeVideoElement.crossOrigin = "anonymous";
        activeVideoElement.loop = true;
        activeVideoElement.playsInline = true;
        activeVideoElement.play();

        videoTexture = new THREE.VideoTexture(activeVideoElement);
        videoTexture.colorSpace = THREE.SRGBColorSpace;
        
        cinemaGroup = new THREE.Group();
        
        // 1. Curved Screen (Default)
        // A section of a cylinder
        const geometry = new THREE.CylinderGeometry(15, 15, 14, 64, 1, true, Math.PI + 0.6, Math.PI - 1.2); 
        // Flip geometry so texture is on inside
        geometry.scale(-1, 1, 1);
        
        const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
        cinemaScreen = new THREE.Mesh(geometry, material);
        cinemaScreen.position.set(0, 4, -8); // Position in front of user
        cinemaScreen.rotation.y = -Math.PI/2;
        cinemaScreen.userData = { isScreen: true, label: "CINEMA SCREEN", isCinema: true };
        
        cinemaGroup.add(cinemaScreen);
        targets.push(cinemaScreen);

        // 2. Ambilight (Backlight)
        cinemaBacklight = new THREE.PointLight(0xffffff, 0.5, 40);
        cinemaBacklight.position.set(0, 5, -5);
        cinemaGroup.add(cinemaBacklight);
        
        // 3. Floor Reflection
        const floorGeo = new THREE.PlaneGeometry(60, 60);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0x000000, roughness: 0.1, metalness: 0.8,
            map: videoTexture // Reflect the video roughly
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI/2;
        floor.position.y = -4;
        cinemaGroup.add(floor);

        scene.add(cinemaGroup);
        
        // Initialize Audio
        if(!audioListener) { audioListener = new THREE.AudioListener(); camera.add(audioListener); }
        const sound = new THREE.Audio(audioListener);
        // Attach audio logic if needed, but VideoTexture usually handles audio output from DOM
        // For spatial audio, we'd need MediaElementSource, but let's stick to DOM audio for sync
        
        sysMessage = "THEATER ACTIVE";
        rebuildCockpit(); // Switch to Media Controls
    }

    function updateAmbilight() {
        if (!activeVideoElement || activeVideoElement.paused) return;
        if (!ambilightCtx) {
            ambilightCanvas = document.getElementById('light-canvas');
            ambilightCtx = ambilightCanvas.getContext('2d');
        }
        
        try {
            ambilightCtx.drawImage(activeVideoElement, 0, 0, 32, 32);
            const p = ambilightCtx.getImageData(16, 16, 1, 1).data;
            const hex = (p[0] << 16) + (p[1] << 8) + p[2];
            cinemaBacklight.color.setHex(hex);
            cinemaBacklight.intensity = 0.8 + (Math.random() * 0.1); // Slight flicker for realism
        } catch(e) {}
    }

    function toggleVideoMode() {
        if (!isCinemaActive || !cinemaScreen) return;
        cinemaMode = (cinemaMode + 1) % 3;
        
        cinemaGroup.remove(cinemaScreen);
        targets = targets.filter(t => t !== cinemaScreen);
        
        let geo;
        
        if (cinemaMode === 0) {
             // Curved Screen
             geo = new THREE.CylinderGeometry(15, 15, 14, 64, 1, true, Math.PI + 0.6, Math.PI - 1.2);
             cinemaScreen.scale.set(-1,1,1);
             cinemaScreen.rotation.y = -Math.PI/2;
             sysMessage = "MODE: CURVED";
        } else if (cinemaMode === 1) {
             // 180 Dome
             geo = new THREE.SphereGeometry(30, 64, 32, 0, Math.PI, 0, Math.PI);
             cinemaScreen.scale.set(-1,1,1);
             cinemaScreen.rotation.y = -Math.PI/2;
             sysMessage = "MODE: 180 IMAX";
        } else {
             // 360 Sphere
             geo = new THREE.SphereGeometry(30, 64, 32);
             cinemaScreen.scale.set(-1,1,1);
             cinemaScreen.rotation.y = 0;
             sysMessage = "MODE: 360 VR";
        }
        
        cinemaScreen.geometry.dispose();
        cinemaScreen.geometry = geo;
        
        cinemaGroup.add(cinemaScreen);
        targets.push(cinemaScreen);
        updateMenuDisplay();
    }

    // ==========================================
    // 3. 3D COCKPIT & CONTROLS
    // ==========================================

    function createChevron(color) {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.3); shape.lineTo(0.3, -0.2); shape.lineTo(0, -0.1);
        shape.lineTo(-0.3, -0.2); shape.lineTo(0, 0.3);
        const geo = new THREE.ShapeGeometry(shape);
        const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const arrow = new THREE.Mesh(geo, mat);
        arrow.add(new THREE.Mesh(new THREE.CircleGeometry(0.35, 32), new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.1 })));
        return arrow;
    }
    
    function createButton(label, color) {
        const geo = new THREE.PlaneGeometry(0.5, 0.3);
        const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const mesh = new THREE.Mesh(geo, mat);
        const edges = new THREE.EdgesGeometry(geo);
        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color })));
        
        // Text Label
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color === 0x00ff00 ? '#00ff00' : '#00ffff';
        ctx.font = 'bold 30px Courier New'; ctx.textAlign='center'; ctx.fillText(label, 64, 40);
        const tex = new THREE.CanvasTexture(canvas);
        const labelMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.2), new THREE.MeshBasicMaterial({map:tex, transparent:true}));
        labelMesh.position.z = 0.01;
        mesh.add(labelMesh);
        
        return mesh;
    }

    function rebuildCockpit() {
        if(cockpitGroup) { dolly.remove(cockpitGroup); }
        cockpitGroup = new THREE.Group();
        cockpitGroup.position.set(0, -1.6, -1.0); 
        cockpitGroup.rotation.x = -Math.PI / 2 + 0.2; 
        dolly.add(cockpitGroup);
        cockpitPanels = [];

        // Always add Menu Button (Center Bottom)
        const menuBtn = createButton("MENU", 0xff0055);
        menuBtn.position.set(0, -0.6, 0);
        menuBtn.userData = { action: "TOGGLE_MENU", baseScale: 1 };
        cockpitGroup.add(menuBtn);
        cockpitPanels.push(menuBtn);

        if (isCinemaActive) {
            // --- MEDIA CONTROLS ---
            const btnPlay = createButton("PLAY/PAUSE", 0x00ff00);
            btnPlay.position.set(0, 0.3, 0); btnPlay.scale.setScalar(1.5);
            btnPlay.userData = { action: "MEDIA_PLAY", baseScale: 1.5 };
            cockpitGroup.add(btnPlay); cockpitPanels.push(btnPlay);

            const btnBack = createButton("<< 15s", 0x00ffff);
            btnBack.position.set(-0.7, 0, 0);
            btnBack.userData = { action: "MEDIA_RW", baseScale: 1 };
            cockpitGroup.add(btnBack); cockpitPanels.push(btnBack);
            
            const btnFwd = createButton("15s >>", 0x00ffff);
            btnFwd.position.set(0.7, 0, 0);
            btnFwd.userData = { action: "MEDIA_FF", baseScale: 1 };
            cockpitGroup.add(btnFwd); cockpitPanels.push(btnFwd);

            const btnMode = createButton("VIEW MODE", 0xffff00);
            btnMode.position.set(0, 0.8, 0);
            btnMode.userData = { action: "MEDIA_MODE", baseScale: 1 };
            cockpitGroup.add(btnMode); cockpitPanels.push(btnMode);
            
        } else {
            // --- FLIGHT CONTROLS ---
            const fwd = createChevron(0x00ff00);
            fwd.position.set(0, 0.5, 0); fwd.userData = { action: "FORWARD", baseScale: 1.5 }; fwd.scale.setScalar(1.5);
            cockpitGroup.add(fwd); cockpitPanels.push(fwd);

            const left = createChevron(0x00ffff);
            left.position.set(-0.6, 0, 0); left.rotation.z = Math.PI/2; left.userData = { action: "LEFT", baseScale: 1 };
            cockpitGroup.add(left); cockpitPanels.push(left);

            const right = createChevron(0x00ffff);
            right.position.set(0.6, 0, 0); right.rotation.z = -Math.PI/2; right.userData = { action: "RIGHT", baseScale: 1 };
            cockpitGroup.add(right); cockpitPanels.push(right);
        }
    }

    function handleCockpitInteraction() {
        if (!cockpitGroup) return;
        const time = Date.now() * 0.003;
        cockpitGroup.position.y = -1.6 + Math.sin(time) * 0.02;

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(cockpitPanels, false);
        targetSpeed = 0; targetRot = 0;
        
        cockpitPanels.forEach(p => { 
            p.material.opacity = 0.4; 
            p.scale.setScalar(p.userData.baseScale); 
        });

        if (intersects.length > 0) {
            const p = intersects[0].object;
            p.material.opacity = 1.0;
            p.scale.setScalar(p.userData.baseScale * 1.2);
            
            // Movement Logic
            if (p.userData.action === "FORWARD") targetSpeed = MAX_SPEED;
            if (p.userData.action === "LEFT") targetRot = MAX_ROT;
            if (p.userData.action === "RIGHT") targetRot = -MAX_ROT;
            
            // System Logic
            if (p.userData.action === "TOGGLE_MENU") {
                if (Date.now() - lastMenuToggleTime > 1500) { 
                    isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen;
                    if(isMenuOpen) updateMenuDisplay();
                    lastMenuToggleTime = Date.now();
                }
            }

            // Media Logic (Gaze Gated)
            if (p.userData.action.startsWith("MEDIA")) {
                if(!menuSelectionTimer) menuSelectionTimer = Date.now();
                if(Date.now() - menuSelectionTimer > 1500) {
                    if(p.userData.action === "MEDIA_PLAY" && activeVideoElement) {
                         if(activeVideoElement.paused) activeVideoElement.play(); else activeVideoElement.pause();
                    }
                    if(p.userData.action === "MEDIA_RW" && activeVideoElement) activeVideoElement.currentTime -= 15;
                    if(p.userData.action === "MEDIA_FF" && activeVideoElement) activeVideoElement.currentTime += 15;
                    if(p.userData.action === "MEDIA_MODE") toggleVideoMode();
                    
                    menuSelectionTimer = Date.now() + 500; // Debounce
                    sysMessage = "COMMAND SENT"; updateMenuDisplay();
                }
            } else { menuSelectionTimer = 0; }
        } else { menuSelectionTimer = 0; }

        currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.1);
        currentRot = THREE.MathUtils.lerp(currentRot, targetRot, 0.1);

        if (Math.abs(currentSpeed) > 0.001) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, currentSpeed);
        }
        if (Math.abs(currentRot) > 0.001) dolly.rotation.y += currentRot;
    }

    // ==========================================
    // 4. MENU & HUD
    // ==========================================

    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        
        // Add a line border
        const edges = new THREE.EdgesGeometry(geometry);
        menuGroup.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff })));
        
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        if(!menuCtx) return;
        const ctx = menuCtx; const w = 1024; const h = 1024;
        
        ctx.fillStyle = 'rgba(0, 10, 20, 0.95)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const sysOpts = [
            { label: "[TOGGLE AR/VOID]", type: "sys" },
            { label: "[VISUAL SCAN]", type: "sys" }
        ];
        
        const fullList = [...sysOpts, ...CUSTOM_DATABASE];
        let listY = 180;
        
        for (let i = 0; i < 9; i++) {
            const index = i + menuScrollIndex;
            if (index >= fullList.length) break;
            const item = fullList[index];
            const isHovered = (index === hoveredFileIndex);
            
            if (isHovered) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 60, 60);
                ctx.fillStyle = '#fff'; ctx.fillText(`> ${item.label}`, 80, listY);
            } else {
                ctx.fillStyle = item.type === 'sys' ? '#ff0055' : '#00aaaa';
                ctx.fillText(`  ${item.label}`, 80, listY);
            }
            ctx.fillStyle = '#666'; ctx.fillText(item.type.toUpperCase(), w - 200, listY);
            listY += 70;
        }

        if (sysMessage) {
            ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100);
            ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(sysMessage, w/2, h/2 + 15);
        }
        menuTexture.needsUpdate = true;
    }

    function updateHUD() {
        if(!hudContext) return;
        const w = 1024; const h = 1024; const ctx = hudContext;
        ctx.clearRect(0, 0, w, h);
        
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New'; ctx.fillStyle = '#00ffff';
        ctx.fillText(`MODE: ${isCinemaActive ? 'THEATER' : 'TACTICAL'}`, w-40, 60);
        ctx.textAlign = 'left'; 
        ctx.fillStyle = isListening ? '#ff0055' : '#00ffff';
        ctx.fillText(`AI: [${aiStatus}]`, 40, 60);

        const cx = w/2; const cy = h/2;
        
        // Reticle
        if (gazeProgress > 0.05) {
            ctx.beginPath(); ctx.arc(cx, cy, 60, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * gazeProgress));
            ctx.lineWidth = 10; ctx.strokeStyle = '#00ffff'; ctx.stroke();
        }

        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; 
        ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();

        hudTexture.needsUpdate = true;
    }

    // ==========================================
    // 5. STANDARD OBJECT SPAWNING (Non-Cinema)
    // ==========================================
    
    async function spawnScreen(data) {
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity:0.9 });
        const screen = new THREE.Mesh(geometry, material);
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        screen.position.copy(camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(3)));
        screen.lookAt(camera.position);
        
        const tex = new THREE.TextureLoader().load(data.src);
        tex.colorSpace = THREE.SRGBColorSpace;
        screen.material.map = tex;
        
        const img = new Image(); img.src = data.src;
        img.onload = () => { screen.scale.set(1.8 * (img.width/img.height), 1.8, 1); }
        
        screen.userData = { isScreen: true, label: data.label };
        scene.add(screen); targets.push(screen);
    }
    
    function spawnModel(pos, data) {
        const loader = new GLTFLoader();
        loader.load(data.src, (gltf) => {
             const model = gltf.scene;
             model.position.copy(pos);
             model.scale.set(0.5, 0.5, 0.5);
             scene.add(model); targets.push(model);
        });
    }

    // ==========================================
    // 6. MAIN ENGINE SETUP
    // ==========================================

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100); 
        dolly.add(camera);
        
        // Reticle (Simple Ring)
        const ringGeo = new THREE.RingGeometry(0.015, 0.02, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, opacity: 0.8, transparent: true });
        reticle = new THREE.Mesh(ringGeo, ringMat); reticle.position.z = -1; camera.add(reticle);

        // HUD Plane
        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas);
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        // Camera Feed (Passthrough)
        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps=false;
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
            fragmentShader: `uniform sampler2D tDiffuse; uniform float uMode; varying vec2 vUv;
            void main() {
                vec4 c = texture2D(tDiffuse, vUv);
                if (uMode > 1.5) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // VOID
                else gl_FragColor = c; // NORMAL
            }`,
            depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 
        
        // Start Camera
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }).then(stream => {
            video.srcObject = stream; video.play();
        });

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(1); renderer.setSize(window.innerWidth, window.innerHeight); 
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        rebuildCockpit(); 
        createMenuSystem();
        
        const btn = VRButton.createButton(renderer);
        document.getElementById('vr-btn-container').appendChild(btn);
        
        renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

        // Event Listeners
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        // Mouse Look
        document.addEventListener('mousedown', (e) => { isMouseDown=true; prevMouse = {x:e.clientX, y:e.clientY}; });
        document.addEventListener('mouseup', () => isMouseDown=false);
        document.addEventListener('mousemove', (e) => {
            if(isMouseDown && !isMenuOpen) {
                const dx = e.clientX - prevMouse.x; const dy = e.clientY - prevMouse.y;
                dolly.rotation.y -= dx * 0.002;
                prevMouse = {x:e.clientX, y:e.clientY};
            }
        });

        renderer.setAnimationLoop(animate);
    }

    // ==========================================
    // 7. INPUT & ANIMATION LOOP
    // ==========================================

    function handleGaze() {
        if(isMenuOpen && menuMesh) {
            // Menu Gaze Interaction
            menuGroup.lookAt(camera.position);
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObject(menuMesh);
            
            if (intersects.length > 0) {
                const uvY = intersects[0].uv.y;
                if (uvY < 0.82) {
                    const idx = Math.floor((0.82 - uvY) / 0.068) + menuScrollIndex;
                    const listSize = 2 + CUSTOM_DATABASE.length; // 2 sys opts
                    
                    if (idx < listSize) {
                        if (hoveredFileIndex !== idx) { hoveredFileIndex = idx; menuSelectionTimer = Date.now(); updateMenuDisplay(); }
                        else {
                            gazeProgress = Math.min((Date.now() - menuSelectionTimer) / 1500, 1.0);
                            if (gazeProgress >= 1.0) { spawnFromMenu(idx); hoveredFileIndex = -1; menuSelectionTimer = Date.now() + 5000; }
                        }
                    }
                }
            } else { hoveredFileIndex = -1; updateMenuDisplay(); gazeProgress = 0; }
        } else {
            gazeProgress = 0;
        }
    }
    
    // Voice Functions
    function initVoice() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SR) {
            recognition = new SR();
            recognition.continuous = false; recognition.lang = 'en-US';
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; aiStatus = "PROCESSING..."; updateHUD(); };
            recognition.onresult = (e) => { askGemini(e.results[0][0].transcript); };
        }
    }
    
    async function askGemini(prompt) {
        if(prompt.toLowerCase().includes("play") || prompt.toLowerCase().includes("pause")) {
            if(activeVideoElement) { 
                activeVideoElement.paused ? activeVideoElement.play() : activeVideoElement.pause();
                speak("Media toggled.");
                return;
            }
        }
        
        try {
            const result = await model.generateContent(prompt);
            const text = result.response.text();
            speak(text);
        } catch(e) { speak("Error."); }
    }
    
    function speak(text) {
        const u = new SpeechSynthesisUtterance(text);
        u.onstart = () => { isSpeaking = true; aiStatus="SPEAKING"; updateHUD(); };
        u.onend = () => { isSpeaking = false; aiStatus="STANDBY"; updateHUD(); };
        synth.speak(u);
    }
    
    async function performVisualScan() {
        const flash = document.getElementById('flash'); flash.style.opacity = 0.8; setTimeout(() => { flash.style.opacity = 0; }, 100);
        
        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('vision-canvas');
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video,0,0);
        
        try {
            const data = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
            const result = await model.generateContent(["Analyze this tactical view.", { inlineData: { data: data, mimeType: "image/jpeg" } }]);
            speak(result.response.text());
        } catch(e) {}
    }

    function animate() {
        // Tilt Handling
        if(isTiltActive && Math.abs(currentTilt.beta) > TILT_DEADZONE) {
            const speed = (currentTilt.beta - (currentTilt.beta > 0 ? TILT_DEADZONE : -TILT_DEADZONE)) * TILT_SPEED;
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, speed);
        }

        handleCockpitInteraction();
        handleGaze();
        updateAmbilight(); // Syncs light with video
        updateHUD();
        renderer.render(scene, camera);
    }

    init3D();
</script>
</body>
</html>