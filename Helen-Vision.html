<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: HOLO-DECK</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        input { background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; font-family: 'Courier New'; text-align: center; letter-spacing: 2px; }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; }
        button { padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace; background: transparent; color: #00ffff; border: 2px solid #00ffff; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        button:hover { background: #00ffff; color: #000; }
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        #flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; opacity: 0; pointer-events: none; z-index: 200; transition: opacity 0.1s; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<div id="flash"></div>
<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    <div class="status" id="system-status">
        [ COCKPIT MODULE ]<br>
        Holographic Flight Deck Online.<br>
        Look DOWN to operate.
    </div>
    <div id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>
    <div class="btn-group" id="main-controls" style="display:none;">
        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD INTEL</button>
        <div id="vr-btn-container"></div>
        <div class="controls-hint">
            [GAZE] LOOK AT DASHBOARD TO MOVE<br>
            [L-CLICK] DRAG / [R-CLICK] MENU
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    
    // --- COCKPIT VARIABLES ---
    let reticle;
    let gazeButtons = []; 
    let gazeGroup;
    const GAZE_SPEED = 0.05;
    const GAZE_ROTATE_SPEED = 0.03;
    let speedIndicator;

    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition; 
    let synth = window.speechSynthesis;
    let isListening = false;
    let isSpeaking = false;
    let aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try { const saved = localStorage.getItem('helen_chat_history'); if(saved) chatHistory = JSON.parse(saved); } catch(e) {}
    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [ { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' } ];
    let targets = []; 
    
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 
    let lastPageTurnTime = 0; const PAGE_DEBOUNCE = 300; 

    // INPUT VARS
    let isMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    const MOUSE_SENSITIVITY = 0.02;
    const VR_WALK_SPEED = 0.05;

    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let menuScrollIndex = 0; 
    let lastMenuScrollTime = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";

    let activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false };
    
    const SPEED = 0.1; const ROTATE_SPEED = 0.05; const MOVE_SPEED = 0.05; const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();
    const _camRight = new THREE.Vector3(); const _camUp = new THREE.Vector3();
    const AI_FOLLOW_DIST = 2.5; const AI_BACKUP_DIST = 0.8; const AI_WALK_SPEED = 0.03;

    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) { localStorage.setItem('helen_gemini_key', key); GEMINI_KEY = key; checkAuth(); }
        else { alert("KEY TOO SHORT."); }
    };
    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key'); localStorage.removeItem('helen_layout_ai');
        localStorage.removeItem('helen_chat_history'); location.reload();
    }
    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Cockpit Active.<br>Use Mouse or Gaze to Move.`;
            try { genAI = new GoogleGenerativeAI(GEMINI_KEY); model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" }); initVoice(); } catch(e) {}
        }
    }
    function initVoice() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition(); recognition.continuous = false; recognition.lang = 'en-US';
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; if(aiStatus === "LISTENING...") aiStatus = "PROCESSING..."; updateHUD(); };
            recognition.onresult = (event) => { askGemini(event.results[0][0].transcript); };
        }
    }
    async function performVisualScan() {
        if (!model) return;
        aiStatus = "SCANNING..."; updateHUD();
        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('vision-canvas'); canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        const base64Image = canvas.toDataURL('image/jpeg', 0.8).split(',')[1]; 
        try {
            const result = await model.generateContent(["Analyze tactically.", { inlineData: { data: base64Image, mimeType: "image/jpeg" } }]);
            speak((await result.response).text());
        } catch (e) { aiStatus = "ERROR"; speak("Sensor failure."); }
    }
    async function askGemini(prompt) {
        aiStatus = "THINKING..."; updateHUD();
        try {
            const chat = model.startChat({ history: chatHistory });
            const result = await chat.sendMessage(prompt);
            const text = (await result.response).text();
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            if(chatHistory.length > 20) chatHistory = chatHistory.slice(-20);
            localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory));
            speak(text);
        } catch (e) { aiStatus = "NET ERR"; speak("Network error."); }
    }
    function speak(text) {
        if (synth.speaking) synth.cancel();
        const u = new SpeechSynthesisUtterance(text); u.rate = 1.1;
        u.onstart = () => { isSpeaking = true; aiStatus = "SPEAKING"; updateHUD(); };
        u.onend = () => { isSpeaking = false; aiStatus = "STANDBY"; updateHUD(); };
        synth.speak(u);
    }
    if(GEMINI_KEY) checkAuth();
    if (localStorage.getItem('helen_layout_ai')) document.getElementById('restore-msg').style.display = 'block';

    const input = document.getElementById('intel-input');
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i]; const name = file.name.toUpperCase();
                let type = 'image'; 
                if (name.endsWith('.PDF')) type = 'pdf'; else if (name.endsWith('.FBX')) type = 'fbx'; else if (name.endsWith('.GLB')) type = 'glb'; else if (file.type.startsWith('video')) type = 'video';
                if (type === 'pdf') CUSTOM_DATABASE.push({ type: 'pdf', buffer: await file.arrayBuffer(), label: name });
                else CUSTOM_DATABASE.push({ type: type, src: URL.createObjectURL(file), label: name });
            }
            input.value = ''; 
        }
    });

    function saveMission() {
        const layout = targets.map(t => ({ label: t.userData.label, pos: t.position, rot: t.rotation, scale: t.scale, type: t.userData.type }));
        localStorage.setItem('helen_layout_ai', JSON.stringify(layout)); sysMessage = "SAVED"; updateMenuDisplay();
    }
    function loadMission() {
        const raw = localStorage.getItem('helen_layout_ai'); if (!raw) return;
        JSON.parse(raw).forEach(item => {
            const dbItem = CUSTOM_DATABASE.find(f => f.label === item.label) || DEFAULT_DATABASE[0];
            if (dbItem) {
                if (dbItem.type === 'fbx' || dbItem.type === 'glb') spawnModel(new THREE.Vector3().copy(item.pos), dbItem, new THREE.Euler().copy(item.rot), new THREE.Vector3().copy(item.scale));
                else spawnScreen(new THREE.Vector3().copy(item.pos), dbItem, new THREE.Euler().copy(item.rot));
            }
        });
        sysMessage = "RESTORED"; updateMenuDisplay();
    }
    function clearMission() { localStorage.removeItem('helen_layout_ai'); targets.forEach(deleteObject); sysMessage = "CLEARED"; updateMenuDisplay(); }

    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        allBackCameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front')).map(c => c.deviceId);
        startCameraStream(allBackCameras[0]);
    }
    async function startCameraStream(id) {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: id ? { deviceId: { exact: id } } : { facingMode: 'environment' } });
            const video = document.getElementById('camera-feed'); video.srcObject = stream; await video.play();
            if (camMaterial) camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
        } catch (e) {}
    }
    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 c = texture2D(tDiffuse, vUv);
            if (uMode > 0.5) {
                float g = dot(c.rgb, vec3(0.299, 0.587, 0.114));
                if(g < 0.2) gl_FragColor = vec4(0.0, 0.1, 0.05, 1.0); 
                else if (g > 0.8) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);
                else gl_FragColor = vec4(0.0, g, g, 1.0);
            } else gl_FragColor = c; 
        }
    `;
    
    function initMouseControl() {
        window.addEventListener('contextmenu', (e) => e.preventDefault());
        const onDown = (e) => {
            if (e.button === 2) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; return; }
            if (isMenuOpen || renderer.xr.isPresenting) return;
            isMouseDown = true; previousMousePosition = { x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY };
        };
        const onMove = (e) => {
            if (!isMouseDown || isMenuOpen || renderer.xr.isPresenting) return;
            const x = e.clientX || e.touches[0].clientX; const y = e.clientY || e.touches[0].clientY;
            const dx = x - previousMousePosition.x; const dy = y - previousMousePosition.y;
            previousMousePosition = { x, y };
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            _strafeDir.crossVectors(camera.up, _moveDir).normalize();
            dolly.position.addScaledVector(_moveDir, -dy * MOUSE_SENSITIVITY);
            dolly.position.addScaledVector(_strafeDir, dx * MOUSE_SENSITIVITY);
        };
        window.addEventListener('mousedown', onDown); window.addEventListener('touchstart', onDown, {passive:false});
        window.addEventListener('mousemove', onMove); window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('mouseup', () => isMouseDown = false); window.addEventListener('touchend', () => isMouseDown = false);
    }

    // --- UPGRADED: HOLOGRAPHIC COMMAND DECK ---
    function createGazeUI() {
        gazeGroup = new THREE.Group();
        // Place it down and forward (Waist height relative to camera)
        gazeGroup.position.set(0, -0.6, -1.2); 
        gazeGroup.rotation.x = -0.4; // Tilted up
        dolly.add(gazeGroup);

        // 1. The Glass Dashboard (Curved Backing)
        // 
        const dashGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.4, 32, 1, true, Math.PI * 1.2, Math.PI * 0.6);
        // Rotate cylinder to face user correctly
        dashGeo.rotateY(Math.PI); 
        const dashMat = new THREE.MeshBasicMaterial({ color: 0x001122, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
        const dash = new THREE.Mesh(dashGeo, dashMat);
        dash.scale.set(1, 1, 0.5); // Flatten it a bit
        gazeGroup.add(dash);

        // Add Glowing Border
        const borderGeo = new THREE.EdgesGeometry(dashGeo);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 });
        gazeGroup.add(new THREE.LineSegments(borderGeo, borderMat));

        // 2. Buttons
        const makeBtn = (label, x, y, w, h, color) => {
            const geo = new THREE.PlaneGeometry(w, h);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side:THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, 0.05); // Float slightly above dash
            mesh.userData = { isGazeBtn: true, action: label };
            
            // Text Label (Simple Canvas Texture)
            const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=64;
            const c = cvs.getContext('2d'); c.fillStyle = "rgba(0,0,0,0)"; c.fillRect(0,0,128,64);
            c.fillStyle="#fff"; c.font="bold 30px Courier"; c.textAlign="center"; c.fillText(label, 64, 40);
            const tex = new THREE.CanvasTexture(cvs);
            const labelMesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h/2), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
            labelMesh.position.z = 0.01;
            mesh.add(labelMesh);

            gazeGroup.add(mesh);
            gazeButtons.push(mesh);
        };

        // Layout
        makeBtn("FWD",  0,     0.1,  0.3, 0.15, 0x00aa00);
        makeBtn("BACK", 0,    -0.1,  0.3, 0.15, 0xaa0000);
        makeBtn("<",   -0.4,   0,    0.2, 0.3,  0x00aaaa);
        makeBtn(">",    0.4,   0,    0.2, 0.3,  0x00aaaa);

        // 3. Reticle (The Eye Cursor)
        const rGeo = new THREE.RingGeometry(0.005, 0.01, 32);
        const rMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
        reticle = new THREE.Mesh(rGeo, rMat);
        reticle.position.z = -0.5;
        camera.add(reticle);
    }

    function handleGaze() {
        if (!gazeGroup) return;
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        
        // Only intersect buttons
        const intersects = raycaster.intersectObjects(gazeButtons, false);

        // Reset Styles
        gazeButtons.forEach(b => { 
            b.scale.setScalar(1); 
            b.material.color.setHex(b.userData.action === "FWD" ? 0x00aa00 : (b.userData.action === "BACK" ? 0xaa0000 : 0x00aaaa));
        });

        if (intersects.length > 0) {
            const btn = intersects[0].object;
            btn.scale.setScalar(1.1); // Pop Effect
            btn.material.color.setHex(0xffffff); // Highlight White

            // LOGIC
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            
            if (btn.userData.action === "FWD") dolly.position.addScaledVector(_moveDir, GAZE_SPEED);
            if (btn.userData.action === "BACK") dolly.position.addScaledVector(_moveDir, -GAZE_SPEED);
            if (btn.userData.action === "<") dolly.rotation.y += GAZE_ROTATE_SPEED;
            if (btn.userData.action === ">") dolly.rotation.y -= GAZE_ROTATE_SPEED;
        }
    }

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100); dolly.add(camera);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps = false; 
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
            vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas); hudTexture.minFilter = THREE.LinearFilter;
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        scene.add(new THREE.GridHelper(40, 40, 0x00ffff, 0x111111));
        const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(0, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 1));
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" }); 
        renderer.setPixelRatio(1); renderer.setSize(window.innerWidth, window.innerHeight); renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        initMouseControl();
        createGazeUI(); // <--- NEW COCKPIT

        const btn = VRButton.createButton(renderer);
        document.getElementById('vr-btn-container').appendChild(btn);
        renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

        createMenuSystem();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        animate();
    }

    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        menuGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; const w = 1024; const h = 1024;
        ctx.fillStyle = 'rgba(0, 10, 20, 0.9)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const sysOpts = [ { label: "[SAVE]", type: "sys" }, { label: "[LOAD]", type: "sys" }, { label: "[CLEAR]", type: "sys" }, { label: "[VOICE]", type: "sys" }, { label: "[SCAN]", type: "sys" }, { label: "[WIPE]", type: "sys" } ];
        const fullList = [...sysOpts, ...CUSTOM_DATABASE];
        ctx.textAlign = 'left'; ctx.font = '50px Courier New'; let listY = 180;
        
        for (let i = 0; i < MAX_MENU_VISIBLE; i++) {
            const idx = menuScrollIndex + i; if (idx >= fullList.length) break;
            const item = fullList[idx];
            if (idx === hoveredFileIndex) { ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 60, 60); ctx.fillStyle = '#fff'; } 
            else ctx.fillStyle = item.type === 'sys' ? '#ff0055' : '#00aaaa';
            ctx.fillText((idx === hoveredFileIndex ? "> " : "  ") + item.label, 80, listY);
            listY += 70;
        }
        if (sysMessage) { ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100); ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(sysMessage, w/2, h/2 + 15); }
        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(index) {
        if (index === 0) { saveMission(); return; } if (index === 1) { loadMission(); return; } if (index === 2) { clearMission(); return; }
        if (index === 3) { if(recognition) recognition.start(); isMenuOpen=false; menuGroup.visible=false; return; }
        if (index === 4) { performVisualScan(); isMenuOpen=false; menuGroup.visible=false; return; }
        if (index === 5) { wipeMemory(); return; }
        const item = (CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE)[index - 6];
        if (item) {
            const pos = camera.getWorldPosition(new THREE.Vector3()).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(3)); pos.y = 0;
            if (item.type === 'fbx' || item.type === 'glb') spawnModel(pos, item); else spawnScreen(pos, item);
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    function spawnModel(position, data, rotation = null, scale = null) {
        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        loader.load(data.src, (loaded) => {
            const model = data.type === 'fbx' ? loaded : loaded.scene;
            model.traverse(c => { if(c.isMesh) c.raycast = function(){}; }); // Optimization
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const s = 1.0 / (Math.max(size.x, size.y, size.z) || 1);
            model.scale.set(s,s,s); if (scale) model.scale.copy(scale);
            model.position.copy(position); if (rotation) model.rotation.copy(rotation);
            
            const hitBox = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent:true, opacity:0.3 }));
            hitBox.position.y = size.y/2; model.add(hitBox);
            
            model.userData = { isScreen: true, isModel: true, label: data.label, type: data.type, aiActive: true };
            scene.add(model); targets.push(model);
        });
    }

    function spawnScreen(position, data, rotation = null) {
        const geo = new THREE.PlaneGeometry(1, 1);
        const mat = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity:0.9 });
        const screen = new THREE.Mesh(geo, mat); screen.position.copy(position);
        if (rotation) screen.rotation.copy(rotation); else screen.lookAt(camera.position.x, screen.position.y, camera.position.z);
        screen.userData = { isScreen: true, label: data.label, type: data.type };
        
        if (data.type === 'image') { new THREE.TextureLoader().load(data.src, (t)=>{ screen.material.map = t; screen.scale.set(1.5, 1.5 * (t.image.height/t.image.width), 1); }); }
        scene.add(screen); targets.push(screen);
    }

    function deleteObject(obj) { scene.remove(obj); targets = targets.filter(t => t !== obj); }

    function handleInput() {
        const pads = navigator.getGamepads();
        let pad = pads[0] || pads[1] || pads[2] || pads[3]; 
        
        // 1. Gaze & Mouse Interaction
        handleGaze();

        // 2. Controller Interaction
        if (pad) {
            // ... (Your existing controller logic for grabbing/moving objects remains here if needed) ...
            if(pad.buttons[0].pressed && !lastBtn.x) { /* Grab Logic */ }
            lastBtn.x = pad.buttons[0].pressed;
        }
    }

    function updateHUD() {
        if(!hudContext) return;
        const ctx = hudContext; ctx.clearRect(0, 0, 1024, 1024);
        ctx.textAlign = 'left'; ctx.font = '30px Courier New'; ctx.fillStyle = '#00ffff';
        ctx.fillText(`AI: ${aiStatus}`, 40, 60);
        
        // Reticle
        const cx = 512; const cy = 512;
        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            updateHUD(); 
            renderer.render(scene, camera); 
        });
    }
</script>
</body>
</html>
