<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: LIVING ENTITY</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; }
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 30px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase;
        }
        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="restore-msg">‚ö†Ô∏è RESTORE POINT FOUND</div>
    <div class="status">
        [ ARTIFICIAL LIFE ]<br>
        Procedural Animation: ACTIVE<br>Autonomous Tracking: ACTIVE
    </div>

    <div class="btn-group">
        <button onclick="document.getElementById('intel-input').click()">üìÇ INJECT MODEL</button>
        <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [‚ñ°] MENU &nbsp;&nbsp; [X] SELECT &nbsp;&nbsp; [O] DELETE<br>
            [R-STICK] ROTATE/SCALE<br>
            The entity will follow you.
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import WebXRPolyfill from 'webxr-polyfill';

    const polyfill = new WebXRPolyfill();

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    
    // DATA & STATE
    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [
        { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' }
    ];
    let targets = []; 
    let activeObject = { obj: null, progress: 0 }; 
    let lastPageTurnTime = 0; const PAGE_DEBOUNCE = 300; 
    let pendingRestore = false; 

    // COMPANION AI STATE
    let companion = {
        model: null,
        bones: {},
        state: {
            velocity: new THREE.Vector3(),
            smoothSpeed: 0.0,
            walkAccumulator: 0.0,
            onGround: true,
            isFollowing: false
        },
        params: {
            followDistance: 2.0, // Stop 2 meters from player
            moveSpeed: 2.0,      // Walking speed
            lerpSpeed: 0.1       // Smoothing
        }
    };
    const clock = new THREE.Clock();

    // MENU
    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let sysMessage = "";

    // HARDWARE
    let torchCamId = null, wideCamId = null, activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false };
    
    const SPEED = 0.1; 
    const ROTATE_SPEED = 0.05; 
    const MOVE_SPEED = 0.05;
    const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();

    if (localStorage.getItem('helen_layout_v6')) {
        document.getElementById('restore-msg').style.display = 'block';
        pendingRestore = true;
    }

    // --- 1. FILE INPUT ---
    const input = document.getElementById('intel-input');
    const statusLabel = document.getElementById('file-status');

    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            statusLabel.innerText = "PROCESSING..."; statusLabel.style.display = 'block'; statusLabel.style.color = '#ffff00';

            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                let type = 'image'; 

                if (name.endsWith('.PDF')) type = 'pdf';
                else if (name.endsWith('.FBX')) type = 'fbx';
                else if (name.endsWith('.GLB') || name.endsWith('.GLTF') || name.endsWith('.VRM')) type = 'glb';
                else if (file.type.startsWith('video')) type = 'video';
                else if (file.type.startsWith('image')) type = 'image';
                
                if (type === 'pdf') {
                    const buffer = await file.arrayBuffer();
                    CUSTOM_DATABASE.push({ type: 'pdf', buffer: buffer, label: name });
                } 
                else if (type === 'fbx' || type === 'glb' || type === 'video' || type === 'image') {
                    CUSTOM_DATABASE.push({ type: type, src: URL.createObjectURL(file), label: name });
                }
            }
            statusLabel.innerText = `${CUSTOM_DATABASE.length} FILES READY`; statusLabel.style.color = '#00ff00';
            input.value = ''; 
        }
    });

    // --- 2. PERSISTENCE ---
    function saveMission() {
        const layout = targets.map(t => {
            let root = t;
            return {
                label: root.userData.label,
                pos: { x: root.position.x, y: root.position.y, z: root.position.z },
                rot: { x: root.rotation.x, y: root.rotation.y, z: root.rotation.z },
                scale: { x: root.scale.x, y: root.scale.y, z: root.scale.z },
                type: root.userData.type,
                isCompanion: root === companion.model // Flag if this is the active AI
            };
        });
        localStorage.setItem('helen_layout_v6', JSON.stringify(layout));
        sysMessage = "MISSION SAVED"; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function loadMission() {
        const raw = localStorage.getItem('helen_layout_v6');
        if (!raw) { sysMessage = "NO DATA FOUND"; updateMenuDisplay(); return; }
        const layout = JSON.parse(raw);
        let restoredCount = 0;
        layout.forEach(item => {
            const dbItem = CUSTOM_DATABASE.find(f => f.label === item.label) || DEFAULT_DATABASE[0];
            if (dbItem) {
                const pos = new THREE.Vector3(item.pos.x, item.pos.y, item.pos.z);
                const rot = new THREE.Euler(item.rot.x, item.rot.y, item.rot.z);
                const scale = item.scale ? new THREE.Vector3(item.scale.x, item.scale.y, item.scale.z) : null;
                
                if (dbItem.type === 'fbx' || dbItem.type === 'glb') spawnModel(pos, dbItem, rot, scale, item.isCompanion);
                else spawnScreen(pos, dbItem, rot);
                restoredCount++;
            }
        });
        sysMessage = `RESTORED ${restoredCount} UNITS`; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function clearMission() {
        localStorage.removeItem('helen_layout_v6');
        [...targets].forEach(t => deleteObject(t));
        sysMessage = "DATABASE WIPED"; updateMenuDisplay();
    }

    // --- 3. HARDWARE & ENGINE ---
    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front'));
        allBackCameras = cameras.map(c => c.deviceId);
        startCameraStream(allBackCameras[0]);
    }

    async function startCameraStream(preferredId) {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            const constraints = preferredId ? { video: { deviceId: { exact: preferredId } } } : { video: { facingMode: 'environment' } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            await video.play();
            currentStream = stream;
            videoTrack = stream.getVideoTracks()[0];
            activeCamId = preferredId;
            if (camMaterial) {
                camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
                camMaterial.uniforms.tDiffuse.value.colorSpace = THREE.SRGBColorSpace;
                camMaterial.uniforms.tDiffuse.value.generateMipmaps = false;
            }
        } catch (err) {}
    }

    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            if (uMode > 1.5) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            else if (uMode > 0.5) {
                float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                vec4 horizEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) + -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec4 vertEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) + -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
            } else gl_FragColor = color; 
        }
    `;

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100); dolly.add(camera);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps = false; 
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
            vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas); hudTexture.minFilter = THREE.LinearFilter;
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        scene.add(new THREE.GridHelper(40, 40, 0x00ffff, 0x111111));
        const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(0, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 1));
        
        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const btn = VRButton.createButton(renderer);
        btn.className = "primary"; btn.innerHTML = "ENTER VR";
        document.getElementById('vr-btn-container').appendChild(btn);
        
        renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

        createMenuSystem();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    }

    // --- 4. COMPANION SYSTEM ---
    function findBones(object) {
        const bones = {};
        object.traverse((child) => {
            if (child.isBone) {
                const name = child.name.toLowerCase();
                // Fuzzy matching for common bone names
                if (name.includes('hip')) bones.hips = child;
                else if (name.includes('spine')) bones.spine = child;
                else if (name.includes('head') || name.includes('neck')) bones.head = child;
                else if (name.includes('left') && (name.includes('upleg') || name.includes('thigh'))) bones.leftLeg = child;
                else if (name.includes('right') && (name.includes('upleg') || name.includes('thigh'))) bones.rightLeg = child;
                else if (name.includes('left') && (name.includes('arm') || name.includes('shoulder'))) bones.leftArm = child;
                else if (name.includes('right') && (name.includes('arm') || name.includes('shoulder'))) bones.rightArm = child;
            }
        });
        return bones;
    }

    function updateCompanion(delta) {
        if (!companion.model || !companion.bones.hips) return;

        // 1. AUTONOMOUS MOVEMENT AI 
        const playerPos = camera.getWorldPosition(new THREE.Vector3());
        const npcPos = companion.model.position.clone();
        
        // Ignore Y (height) for distance check
        const dist = new THREE.Vector2(playerPos.x - npcPos.x, playerPos.z - npcPos.z).length();
        const dir = new THREE.Vector3(playerPos.x - npcPos.x, 0, playerPos.z - npcPos.z).normalize();

        let desiredSpeed = 0;

        // "Follow" Logic
        if (dist > companion.params.followDistance + 0.5) {
            desiredSpeed = companion.params.moveSpeed;
        } else if (dist < companion.params.followDistance - 0.5) {
            // Too close, back up slightly? Or just stop
            desiredSpeed = 0;
        }

        // Smooth speed transition
        companion.state.smoothSpeed = THREE.MathUtils.lerp(companion.state.smoothSpeed, desiredSpeed, companion.params.lerpSpeed);
        
        // Apply Movement
        if (companion.state.smoothSpeed > 0.1) {
            companion.model.position.add(dir.multiplyScalar(companion.state.smoothSpeed * delta));
            // Rotate body to face movement
            const angle = Math.atan2(dir.x, dir.z);
            // Smooth rotation
            const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angle);
            companion.model.quaternion.slerp(q, 0.1);
        }

        // 2. PROCEDURAL ANIMATION ENGINE
        const speed = companion.state.smoothSpeed;
        const intensity = Math.min(speed / companion.params.moveSpeed, 1.0);
        
        companion.state.walkAccumulator += speed * delta * 5.0; // Walk frequency
        const wc = companion.state.walkAccumulator;
        
        // Idle Breathing
        const breath = Math.sin(clock.elapsedTime * 2.0) * 0.05;

        // Apply to Bones
        if (companion.bones.hips) {
            // Bobbing (Up/Down)
            companion.bones.hips.position.y = (Math.sin(wc * 2) * 0.05 * intensity); 
        }
        if (companion.bones.spine) {
            // Breathing + Walking sway
            companion.bones.spine.rotation.x = breath + (intensity * 0.2); // Lean forward when walking
            companion.bones.spine.rotation.y = Math.cos(wc) * (0.1 * intensity);
        }
        
        const runAmp = 0.5 * intensity;
        if (companion.bones.leftLeg) companion.bones.leftLeg.rotation.x = Math.sin(wc) * runAmp;
        if (companion.bones.rightLeg) companion.bones.rightLeg.rotation.x = Math.sin(wc + Math.PI) * runAmp;
        
        if (companion.bones.leftArm) companion.bones.leftArm.rotation.x = Math.sin(wc + Math.PI) * runAmp;
        if (companion.bones.rightArm) companion.bones.rightArm.rotation.x = Math.sin(wc) * runAmp;

        // 3. HEAD TRACKING (LookAt)
        if (companion.bones.head) {
            // Get local position of player relative to NPC
            const targetLocal = companion.model.worldToLocal(playerPos.clone());
            
            // Calculate Yaw/Pitch
            const yaw = Math.atan2(targetLocal.x, targetLocal.z);
            const pitch = Math.atan2(targetLocal.y, targetLocal.z); // Simple approximation
            
            // Clamp so head doesn't spin 180
            const clampedYaw = THREE.MathUtils.clamp(yaw, -1.0, 1.0);
            const clampedPitch = THREE.MathUtils.clamp(pitch, -0.5, 0.5);
            
            // Smoothly interpolate current head rotation to target
            // Note: Bone rotations are local. We just add this to the base rotation.
            // Resetting to 0 first is tricky without T-pose data, so we just set it.
            // A safer way is using rotateX/Y but resetting frame by frame.
            // For simplicity in this demo, we set rotation directly assuming roughly upright bones.
            companion.bones.head.rotation.y = THREE.MathUtils.lerp(companion.bones.head.rotation.y, clampedYaw, 0.1);
            companion.bones.head.rotation.x = THREE.MathUtils.lerp(companion.bones.head.rotation.x, -clampedPitch, 0.1);
        }
    }

    // --- 5. LOADING & SPAWNING ---
    function spawnModel(position, data, rotation = null, scale = null, isCompanion = false) {
        const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const boxMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
        const placeholder = new THREE.Mesh(boxGeo, boxMat);
        placeholder.position.copy(position);
        placeholder.userData = { isScreen: true, isModel: true, label: "LOADING...", type: data.type };
        scene.add(placeholder);
        targets.push(placeholder);

        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        
        loader.load(data.src, (loaded) => {
            scene.remove(placeholder);
            targets = targets.filter(t => t !== placeholder);

            const model = data.type === 'fbx' ? loaded : loaded.scene;
            
            // Normalize Scale
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z) || 1; 
            const scaleFactor = 1.0 / maxDim; 
            
            model.scale.set(scaleFactor, scaleFactor, scaleFactor);
            if (scale) model.scale.copy(scale);

            model.position.copy(position);
            if (rotation) model.rotation.copy(rotation);
            
            model.userData = { isScreen: true, isModel: true, label: data.label, type: data.type };
            const helper = new THREE.BoxHelper(model, 0x00ffff);
            helper.visible = false; // Hide box by default
            model.add(helper);

            scene.add(model);
            targets.push(model);
            
            // IF SELECTED AS COMPANION (FIRST MODEL LOADED OR SAVED AS SUCH)
            if (isCompanion || !companion.model) {
                companion.model = model;
                companion.bones = findBones(model);
                // Remove helper for the living entity to look cleaner
                helper.visible = false; 
                sysMessage = "COMPANION LINKED";
            } else {
                sysMessage = "MODEL DEPLOYED";
            }
            updateMenuDisplay();

        }, undefined, (error) => {
            console.error(error);
            placeholder.material.color.setHex(0xff0000);
            placeholder.userData.label = "ERROR";
            sysMessage = "LOAD ERROR"; updateMenuDisplay();
        });
    }

    // --- 6. MENU, HUD, RENDER (Standard) ---
    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        menuGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; const w = 1024; const h = 1024;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        ctx.fillStyle = 'rgba(0, 10, 20, 0.9)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const sysOpts = [" [SAVE MISSION]", " [LOAD MISSION]", " [CLEAR ALL]"];
        ctx.textAlign = 'left'; ctx.font = '50px Courier New';
        let listY = 180;
        
        for (let i=0; i<sysOpts.length; i++) {
             if (i === hoveredFileIndex) {
                ctx.fillStyle = '#ff0055'; ctx.fillRect(50, listY - 50, w - 100, 60);
                ctx.fillStyle = '#fff'; ctx.fillText(sysOpts[i], 80, listY);
            } else {
                ctx.fillStyle = '#ff0055'; ctx.fillText(sysOpts[i], 80, listY);
            }
            listY += 70;
        }

        ctx.fillStyle = '#00aaaa'; 
        const maxItems = 8;
        for (let i = 0; i < Math.min(db.length, maxItems); i++) {
            const menuIndex = i + sysOpts.length;
            if (menuIndex === hoveredFileIndex) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 100, 60);
                ctx.fillStyle = '#fff'; ctx.fillText(`> ${db[i].label}`, 80, listY);
            } else {
                ctx.fillStyle = '#00aaaa'; ctx.fillText(`  ${db[i].label}`, 80, listY);
            }
            ctx.fillStyle = '#666'; ctx.fillText(db[i].type.toUpperCase(), w - 200, listY);
            listY += 70;
        }

        if (sysMessage) {
            ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100);
            ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(sysMessage, w/2, h/2 + 15);
        }

        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(index) {
        if (index === 0) { saveMission(); return; }
        if (index === 1) { loadMission(); return; }
        if (index === 2) { clearMission(); return; }

        const fileIndex = index - 3;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        if (fileIndex >= 0 && fileIndex < db.length) {
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const pos = camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(3));
            
            const item = db[fileIndex];
            if (item.type === 'fbx' || item.type === 'glb') spawnModel(pos, item, null, null, true); // True = Set as Companion
            else spawnScreen(pos, item);
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    async function spawnScreen(position, data, rotation = null) {
        let width = 3, height = 1.8; 
        const geometry = new THREE.PlaneGeometry(3, 1.8);
        const screen = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }));
        screen.position.copy(position); 
        
        if (rotation) screen.rotation.copy(rotation);
        else {
            const pPos = camera.getWorldPosition(new THREE.Vector3());
            screen.lookAt(pPos.x, screen.position.y, pPos.z);
        }
        
        screen.userData = { isScreen: true, label: data.label, type: data.type };

        if (data.type === 'pdf') {
            const clonedBuffer = data.buffer.slice(0);
            const pdf = await pdfjsLib.getDocument(clonedBuffer).promise;
            screen.userData.pdfDoc = pdf; screen.userData.pageNum = 1; screen.userData.totalPages = pdf.numPages;
            renderPdfPageToTexture(screen, 1);
            screen.scale.set(0.8, 1.4, 1); 
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0xffff00 })));
        } else if (data.type === 'video') {
            const videoElem = document.createElement('video'); videoElem.src = data.src; videoElem.crossOrigin = "anonymous"; videoElem.loop = true; videoElem.muted = true; 
            videoElem.play().then(() => { videoElem.muted = false; });
            const tex = new THREE.VideoTexture(videoElem); tex.colorSpace = THREE.SRGBColorSpace;
            screen.material.map = tex; screen.userData.videoElement = videoElem;
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        } else {
            const tex = new THREE.TextureLoader().load(data.src); tex.colorSpace = THREE.SRGBColorSpace;
            screen.material.map = tex;
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        }
        scene.add(screen); targets.push(screen);
    }

    async function renderPdfPageToTexture(mesh, pageNum) {
        if (!mesh.userData.pdfDoc) return;
        if (mesh.userData.isRendering) return; 
        mesh.userData.isRendering = true;
        try {
            const pdf = mesh.userData.pdfDoc;
            if (pageNum < 1) pageNum = 1; if (pageNum > pdf.numPages) pageNum = pdf.numPages;
            mesh.userData.pageNum = pageNum;
            const page = await pdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2.0 });
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.height = viewport.height; canvas.width = viewport.width;
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace;
            if (mesh.material.map) mesh.material.map.dispose(); 
            mesh.material.map = tex; mesh.material.needsUpdate = true;
        } catch(e) { console.error(e); }
        mesh.userData.isRendering = false;
    }

    function deleteObject(obj) {
        if (obj.userData.videoElement) {
            obj.userData.videoElement.pause(); obj.userData.videoElement.src = ""; obj.userData.videoElement.load();
        }
        if (obj.material && obj.material.map) obj.material.map.dispose();
        scene.remove(obj); targets = targets.filter(t => t !== obj);
        if (companion.model === obj) companion.model = null; // Unlink companion if deleted
    }

    function handleInput() {
        const pads = navigator.getGamepads(); if(!pads[0]) return;
        const pad = pads[0];
        
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        let activeTarget = null;
        
        if (isMenuOpen) {
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const worldPos = camera.getWorldPosition(new THREE.Vector3());
            const targetPos = worldPos.add(dir.multiplyScalar(2.5));
            menuGroup.position.copy(targetPos); menuGroup.lookAt(camera.getWorldPosition(new THREE.Vector3()));
            
            const intersects = raycaster.intersectObject(menuMesh);
            if (intersects.length > 0) {
                const uvY = intersects[0].uv.y;
                if (uvY < 0.82) {
                    const idx = Math.floor((0.82 - uvY) / 0.068);
                    const totalItems = 3 + (CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE.length : DEFAULT_DATABASE.length);
                    if (idx >= 0 && idx < totalItems && hoveredFileIndex !== idx) { hoveredFileIndex = idx; updateMenuDisplay(); }
                }
            } else { if(hoveredFileIndex !== -1) { hoveredFileIndex = -1; updateMenuDisplay(); } }
            if (pad.buttons[0].pressed && !lastBtn.x && hoveredFileIndex !== -1) spawnFromMenu(hoveredFileIndex);
            
        } else {
            const intersects = raycaster.intersectObjects(targets, true); 
            if (intersects.length > 0) {
                let hit = intersects[0].object;
                while(hit.parent && !hit.userData.isScreen && hit !== scene) { hit = hit.parent; }
                if (hit.userData.isScreen) { activeObject.obj = hit; activeTarget = hit; } 
                else { activeObject.obj = null; }

                if (activeTarget && pad.buttons[1].pressed && !lastBtn.circle) { 
                    deleteObject(activeTarget); activeObject.obj = null; activeTarget = null; 
                }
            } else { activeObject.obj = null; }
        }

        const leftStickX = pad.axes[0]; const leftStickY = pad.axes[1]; 
        const rightStickX = pad.axes[2]; const rightStickY = pad.axes[3]; 

        if (activeTarget) {
            if (Math.abs(rightStickX) > 0.1) activeTarget.rotation.y += rightStickX * ROTATE_SPEED;
            if (Math.abs(rightStickY) > 0.1) {
                if (activeTarget.userData.isModel) {
                     const s = 1 + (rightStickY * -SCALE_SPEED); 
                     activeTarget.scale.multiplyScalar(s);
                } else {
                     activeTarget.rotation.x += rightStickY * ROTATE_SPEED;
                }
            }
            if (activeTarget.userData.type === 'pdf') {
                if (Math.abs(leftStickX) > 0.5) {
                    const now = Date.now();
                    if (now - lastPageTurnTime > PAGE_DEBOUNCE) {
                        const dir = Math.sign(leftStickX); 
                        const newPage = activeTarget.userData.pageNum + dir;
                        if (newPage >= 1 && newPage <= activeTarget.userData.totalPages) {
                            renderPdfPageToTexture(activeTarget, newPage);
                            lastPageTurnTime = now;
                        }
                    }
                }
            } 
        } 
        
        if (!activeTarget || (activeTarget && activeTarget.userData.type !== 'pdf')) {
            if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -leftStickY * SPEED);
                dolly.position.addScaledVector(_strafeDir, leftStickX * SPEED);
            }
        }

        if (pad.buttons[2].pressed && !lastBtn.square) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; }
        lastBtn.square = pad.buttons[2].pressed;

        if (pad.buttons[3].pressed && !lastBtn.triangle) {
            visionMode = (visionMode + 1) % 3;
            if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
            if (visionMode === 1 && torchCamId) startCameraStream(torchCamId).then(()=>videoTrack?.applyConstraints({advanced:[{torch:true}]}));
            else { videoTrack?.applyConstraints({advanced:[{torch:false}]}); if(visionMode === 0 && wideCamId) setTimeout(()=>startCameraStream(wideCamId),300); }
        }
        
        if ((pad.buttons[4].pressed || pad.buttons[5].pressed) && !lastBtn.bumper && allBackCameras.length > 1) {
            const idx = (allBackCameras.indexOf(activeCamId) + 1) % allBackCameras.length;
            startCameraStream(allBackCameras[idx]);
        }
        
        lastBtn.triangle = pad.buttons[3].pressed;
        lastBtn.x = pad.buttons[0].pressed; 
        lastBtn.circle = pad.buttons[1].pressed;
        lastBtn.bumper = pad.buttons[4].pressed || pad.buttons[5].pressed;
    }

    function updateHUD() {
        if(!hudContext) return;
        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
        else if(visionMode === 2) { ctx.fillStyle = '#ff0000'; ctx.fillText("VISION: [VOID]", w-40, 60); }
        else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }

        const cx = w/2; const cy = h/2;
        if (isMenuOpen) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.fillText("MENU OPEN", cx, cy + 200);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10); ctx.stroke();
        } else if (activeObject.obj) {
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, 2*Math.PI); ctx.stroke();
            ctx.textAlign = 'center'; ctx.font = '20px Courier New'; ctx.fillStyle = '#fff'; 
            ctx.fillText(activeObject.obj.userData.label || "TARGET", cx, cy + 80); 
            ctx.font = '16px Courier New';
            
            if (activeObject.obj.userData.isModel) {
                 ctx.fillText("[R-STICK] ROTATE/SCALE", cx, cy + 120);
            } else {
                 ctx.fillText("[R-STICK] ROTATE/TILT", cx, cy + 120);
            }
            
            if (activeObject.obj.userData.type === 'pdf') {
                const page = activeObject.obj.userData.pageNum;
                const total = activeObject.obj.userData.totalPages;
                ctx.fillStyle = '#ffff00'; ctx.font = '20px Courier New';
                ctx.fillText(`PAGE ${page} / ${total}`, cx, cy + 160);
            }
        } else {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            const delta = Math.min(clock.getDelta(), 0.05); // Cap for safety
            handleInput(); 
            updateCompanion(delta); // Run AI logic
            updateHUD(); 
            renderer.render(scene, camera); 
        });
    }
</script>
</body>
</html>
