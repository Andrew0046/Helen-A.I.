<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: TACTICAL MENU</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 2px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<div id="flash"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    
    <div class="status" id="system-status">
        [ SYSTEM ONLINE ]<br>
        Look DOWN to Access Menu.<br>
        Activate Flight Mode to Move.
    </div>

    <div id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="btn-group" id="main-controls" style="display:none;">
        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD INTEL</button>
        <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [GAZE] LOOK AT FLOOR MENU<br>
            [L-CLICK] DRAG / [R-CLICK] MENU<br>
            [VR] HOLD TO WALK
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    
    // --- COCKPIT VARIABLES ---
    let reticle;
    let cockpitGroup;
    let flightModeActive = false; // TOGGLE STATE
    let floorMenuBtn = null;      // The "Menu" button
    let flightControls = [];      // The Arrows
    
    // SMOOTH MOVEMENT
    let currentSpeed = 0; let targetSpeed = 0;
    let currentRot = 0; let targetRot = 0;
    const MAX_SPEED = 0.08; const MAX_ROT = 0.04;

    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition; 
    let synth = window.speechSynthesis;
    let isListening = false;
    let isSpeaking = false;
    let aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try {
        const saved = localStorage.getItem('helen_chat_history');
        if(saved) chatHistory = JSON.parse(saved);
    } catch(e) {}

    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [ { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' } ];
    let targets = []; 
    
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 
    
    let lastPageTurnTime = 0; const PAGE_DEBOUNCE = 300; 
    let pendingRestore = false; 

    // --- INPUT VARIABLES ---
    let isMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    const MOUSE_SENSITIVITY = 0.02;
    const VR_WALK_SPEED = 0.05;

    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let menuScrollIndex = 0; 
    let lastMenuScrollTime = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";

    let torchCamId = null, wideCamId = null, activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false, dpadDown: false, dpadUp: false, dpadLeft: false, dpadRight: false };
    
    const SPEED = 0.1; 
    const ROTATE_SPEED = 0.05; 
    const MOVE_SPEED = 0.05;
    const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();

    const _camRight = new THREE.Vector3();
    const _camUp = new THREE.Vector3();

    const AI_FOLLOW_DIST = 2.5; 
    const AI_STOP_DIST = 1.5;
    const AI_BACKUP_DIST = 0.8;
    const AI_WALK_SPEED = 0.03;

    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else {
            alert("KEY TOO SHORT.");
        }
    };

    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key');
        localStorage.removeItem('helen_layout_ai');
        localStorage.removeItem('helen_chat_history'); 
        location.reload();
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Floor Menu Active.<br>Look DOWN to Access.`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ 
                    model: "gemini-2.5-flash",
                    systemInstruction: "You are HELEN, a tactical AI companion. Responses concise & robotic."
                });
                initVoice();
            } catch(e) {
                console.error("AI INIT FAILED", e);
            }
        }
    }

    function initVoice() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; if(aiStatus === "LISTENING...") aiStatus = "PROCESSING..."; updateHUD(); };
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                console.log("User said:", transcript);
                askGemini(transcript);
            };
        }
    }

    async function performVisualScan() {
        if (!model) return;
        aiStatus = "CAPTURING VISUALS..."; updateHUD();
        const flash = document.getElementById('flash');
        flash.style.opacity = 0.8;
        setTimeout(() => { flash.style.opacity = 0; }, 100);

        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('vision-canvas');
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        const base64Image = dataUrl.split(',')[1]; 

        aiStatus = "ANALYZING TARGET..."; updateHUD();
        try {
            const prompt = "Analyze this image tactically.";
            const imagePart = { inlineData: { data: base64Image, mimeType: "image/jpeg" } };
            const result = await model.generateContent([prompt, imagePart]);
            const response = await result.response;
            const text = response.text();
            speak(text);
        } catch (error) {
            aiStatus = "VISUAL ERROR";
            speak("Visual sensors malfunctioned.");
        }
    }

    async function askGemini(prompt) {
        aiStatus = "THINKING..."; updateHUD();
        try {
            const chat = model.startChat({
                history: chatHistory,
                generationConfig: { maxOutputTokens: 100 },
            });
            const result = await chat.sendMessage(prompt);
            const response = await result.response;
            const text = response.text();
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            if(chatHistory.length > 20) chatHistory = chatHistory.slice(chatHistory.length - 20);
            saveMemory();
            speak(text);
        } catch (error) {
            aiStatus = "ERR: NET";
            speak("System Error.");
        }
    }
    
    function saveMemory() { localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory)); }
    function wipeMemory() {
        chatHistory = [];
        localStorage.removeItem('helen_chat_history');
        sysMessage = "MEMORY WIPED";
        speak("Memory banks cleared.");
        updateMenuDisplay();
    }

    function speak(text) {
        if (synth.speaking) synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1; utterance.pitch = 1.0;
        const voices = synth.getVoices();
        const preferred = voices.find(v => v.name.includes("Google US English") || v.name.includes("Female"));
        if(preferred) utterance.voice = preferred;
        utterance.onstart = () => { isSpeaking = true; aiStatus = "SPEAKING"; updateHUD(); };
        utterance.onend = () => { isSpeaking = false; aiStatus = "STANDBY"; updateHUD(); };
        synth.speak(utterance);
    }
    
    if(GEMINI_KEY) checkAuth();

    if (localStorage.getItem('helen_layout_ai')) {
        document.getElementById('restore-msg').style.display = 'block';
        pendingRestore = true;
    }

    const input = document.getElementById('intel-input');
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                let type = 'image'; 
                if (name.endsWith('.PDF')) type = 'pdf';
                else if (name.endsWith('.FBX')) type = 'fbx';
                else if (name.endsWith('.GLB') || name.endsWith('.GLTF') || name.endsWith('.VRM')) type = 'glb';
                else if (file.type.startsWith('video')) type = 'video';
                else if (file.type.startsWith('image')) type = 'image';
                
                if (type === 'pdf') {
                    const buffer = await file.arrayBuffer();
                    CUSTOM_DATABASE.push({ type: 'pdf', buffer: buffer, label: name });
                } 
                else if (type === 'fbx' || type === 'glb' || type === 'video' || type === 'image') {
                    CUSTOM_DATABASE.push({ type: type, src: URL.createObjectURL(file), label: name });
                }
            }
            input.value = ''; 
        }
    });

    function saveMission() {
        const layout = targets.map(t => {
            let root = t;
            return {
                label: root.userData.label,
                pos: { x: root.position.x, y: root.position.y, z: root.position.z },
                rot: { x: root.rotation.x, y: root.rotation.y, z: root.rotation.z },
                scale: { x: root.scale.x, y: root.scale.y, z: root.scale.z },
                type: root.userData.type
            };
        });
        localStorage.setItem('helen_layout_ai', JSON.stringify(layout));
        sysMessage = "MISSION SAVED"; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function loadMission() {
        const raw = localStorage.getItem('helen_layout_ai');
        if (!raw) { sysMessage = "NO DATA FOUND"; updateMenuDisplay(); return; }
        const layout = JSON.parse(raw);
        let restoredCount = 0;
        layout.forEach(item => {
            const dbItem = CUSTOM_DATABASE.find(f => f.label === item.label) || DEFAULT_DATABASE[0];
            if (dbItem) {
                const pos = new THREE.Vector3(item.pos.x, item.pos.y, item.pos.z);
                const rot = new THREE.Euler(item.rot.x, item.rot.y, item.rot.z);
                const scale = item.scale ? new THREE.Vector3(item.scale.x, item.scale.y, item.scale.z) : null;
                
                if (dbItem.type === 'fbx' || dbItem.type === 'glb') spawnModel(pos, dbItem, rot, scale);
                else spawnScreen(pos, dbItem, rot);
                restoredCount++;
            }
        });
        sysMessage = `RESTORED ${restoredCount} UNITS`; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function clearMission() {
        localStorage.removeItem('helen_layout_ai');
        [...targets].forEach(t => deleteObject(t));
        sysMessage = "DATABASE WIPED"; updateMenuDisplay();
    }

    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front'));
        allBackCameras = cameras.map(c => c.deviceId);
        startCameraStream(allBackCameras[0]);
    }

    async function startCameraStream(preferredId) {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            const constraints = preferredId ? { video: { deviceId: { exact: preferredId } } } : { video: { facingMode: 'environment' } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            await video.play();
            currentStream = stream;
            videoTrack = stream.getVideoTracks()[0];
            activeCamId = preferredId;
            if (camMaterial) {
                camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
                camMaterial.uniforms.tDiffuse.value.colorSpace = THREE.SRGBColorSpace;
                camMaterial.uniforms.tDiffuse.value.generateMipmaps = false;
            }
        } catch (err) {}
    }

    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            if (uMode > 1.5) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            else if (uMode > 0.5) {
                float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                vec4 horizEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) + -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec4 vertEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) + -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
            } else gl_FragColor = color; 
        }
    `;
    
    function initMouseControl() {
        function getPos(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        window.addEventListener('contextmenu', (e) => { e.preventDefault(); });

        const onDown = (e) => {
            if (e.button === 2) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; return; }
            if (isMenuOpen) return;
            if (e.button === 0 || e.type === 'touchstart') {
                isMouseDown = true;
                const pos = getPos(e);
                previousMousePosition = pos;
            }
        };

        const onUp = () => { isMouseDown = false; };

        const onMove = (e) => {
            if (!isMouseDown || !dolly || isMenuOpen) return;
            if(e.preventDefault) e.preventDefault();
            if (!renderer.xr.isPresenting) {
                const pos = getPos(e);
                const deltaX = pos.x - previousMousePosition.x;
                const deltaY = pos.y - previousMousePosition.y;
                previousMousePosition = pos;
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -deltaY * MOUSE_SENSITIVITY);
                dolly.position.addScaledVector(_strafeDir, deltaX * MOUSE_SENSITIVITY);
            }
        };

        window.addEventListener('mousedown', onDown);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchmove', onMove, { passive: false });
    }

    // --- COCKPIT MK.III (TOGGLEABLE) ---
    function createCockpit() {
        cockpitGroup = new THREE.Group();
        cockpitGroup.position.set(0, -1.7, -1.0); 
        cockpitGroup.rotation.x = -Math.PI / 2; 
        dolly.add(cockpitGroup);

        const createLabel = (text, color='#00ffff') => {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128;
            const c = canvas.getContext('2d');
            c.strokeStyle = color; c.lineWidth = 10; c.strokeRect(5,5,246,118); 
            c.fillStyle = color; c.font = 'bold 40px Courier New'; c.textAlign = 'center';
            c.fillText(text, 128, 75);
            return new THREE.CanvasTexture(canvas);
        }

        const makePanel = (name, x, y, w, h, tex, groupToAdd) => {
            const geo = new THREE.PlaneGeometry(w, h);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.4, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            const panel = new THREE.Mesh(geo, mat);
            panel.position.set(x, y, 0); 
            panel.userData = { action: name };
            groupToAdd.push(panel);
            cockpitGroup.add(panel);
            return panel;
        }

        // 1. MENU BUTTON (Default State)
        // Positioned centrally
        floorMenuBtn = makePanel("OPEN_MENU", 0, 0.4, 0.8, 0.5, createLabel("[ MENU ]", '#00ff00'), []);
        
        // 2. FLIGHT CONTROLS (Hidden by default)
        const arrows = [];
        makePanel("FORWARD", 0, 0.4, 0.8, 0.5, createLabel("‚ñ≤ MOVE ‚ñ≤"), arrows);
        makePanel("LEFT", -0.9, 0, 0.6, 0.4, createLabel("‚óÑ TURN"), arrows);
        makePanel("RIGHT", 0.9, 0, 0.6, 0.4, createLabel("TURN ‚ñ∫"), arrows);
        
        // Add a small "Close" button to flight controls so user isn't trapped
        makePanel("EXIT_FLIGHT", 0, -0.4, 0.4, 0.2, createLabel("[ X ]", '#ff0055'), arrows);

        flightControls = arrows;
        
        // Initial Visibility State
        updateCockpitVisibility();

        // Reticle
        if(!reticle) {
            const ringGeo = new THREE.RingGeometry(0.015, 0.02, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(ringGeo, ringMat);
            reticle.position.z = -1;
            camera.add(reticle);
        }
    }

    function updateCockpitVisibility() {
        if (flightModeActive) {
            floorMenuBtn.visible = false;
            flightControls.forEach(p => p.visible = true);
        } else {
            floorMenuBtn.visible = true;
            flightControls.forEach(p => p.visible = false);
        }
    }

    function handleCockpit() {
        if (!cockpitGroup) return;

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        
        // Only intersect visible objects
        const interactiveObjects = flightModeActive ? flightControls : [floorMenuBtn];
        const intersects = raycaster.intersectObjects(interactiveObjects, false);

        targetSpeed = 0;
        targetRot = 0;
        
        interactiveObjects.forEach(p => {
            p.material.opacity = 0.4;
            p.scale.setScalar(1.0);
        });

        if (intersects.length > 0) {
            const p = intersects[0].object;
            p.material.opacity = 1.0;
            p.scale.setScalar(1.05);

            // LOGIC
            if (p.userData.action === "OPEN_MENU") {
                if (!isMenuOpen) {
                    isMenuOpen = true; 
                    menuGroup.visible = true;
                }
            }
            else if (p.userData.action === "EXIT_FLIGHT") {
                flightModeActive = false;
                updateCockpitVisibility();
            }
            else if (p.userData.action === "FORWARD") targetSpeed = MAX_SPEED;
            else if (p.userData.action === "LEFT") targetRot = MAX_ROT;
            else if (p.userData.action === "RIGHT") targetRot = -MAX_ROT;
        }

        // Apply Movement
        currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.1);
        currentRot = THREE.MathUtils.lerp(currentRot, targetRot, 0.1);

        if (Math.abs(currentSpeed) > 0.001) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, currentSpeed);
        }
        if (Math.abs(currentRot) > 0.001) {
            dolly.rotation.y += currentRot;
        }
    }

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100); dolly.add(camera);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps = false; 
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
            vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas); hudTexture.minFilter = THREE.LinearFilter;
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        scene.add(new THREE.GridHelper(40, 40, 0x00ffff, 0x111111));
        const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(0, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 1));
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" }); 
        renderer.setPixelRatio(1); 
        renderer.setSize(window.innerWidth, window.innerHeight); 
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        initMouseControl();
        createCockpit(); // <--- MK.III TOGGLEABLE COCKPIT

        const btn = VRButton.createButton(renderer);
        btn.className = "primary"; btn.innerHTML = "ENTER VR";
        document.getElementById('vr-btn-container').appendChild(btn);
        
        renderer.xr.addEventListener('sessionstart', () => { document.getElementById('overlay').style.display = 'none'; });

        createMenuSystem();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        
        window.addEventListener('keydown', (e) => {
            if(e.key === 'f') { 
                if (targets.length > 0 && targets[0].userData.isModel) {
                    targets[0].userData.isPaused = !targets[0].userData.isPaused;
                }
            }
        });

        animate();
    }

    function createMenuSystem() {
        menuGroup = new THREE.Group();
        const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024;
        menuCtx = canvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        menuGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; const w = 1024; const h = 1024;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        
        ctx.fillStyle = 'rgba(0, 10, 20, 0.9)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("TACTICAL INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const flightText = flightModeActive ? "[DEACTIVATE FLIGHT]" : "[ACTIVATE FLIGHT]";
        const flightColor = flightModeActive ? '#ff0055' : '#00ff00';

        const sysOpts = [
            { label: flightText, type: "sys", color: flightColor }, // DYNAMIC OPTION
            { label: "[SAVE MISSION]", type: "sys" },
            { label: "[LOAD MISSION]", type: "sys" },
            { label: "[CLEAR ALL]", type: "sys" },
            { label: "[VOICE COMMS]", type: "sys" },
            { label: "[VISUAL SCAN]", type: "sys" },
            { label: "[WIPE MEMORY]", type: "sys" }
        ];
        
        const fullList = [...sysOpts, ...db];
        const totalItems = fullList.length;
        
        ctx.textAlign = 'left'; ctx.font = '50px Courier New';
        let listY = 180;
        
        if (totalItems > MAX_MENU_VISIBLE) {
            const trackHeight = MAX_MENU_VISIBLE * 70;
            const scrollPercent = menuScrollIndex / (totalItems - MAX_MENU_VISIBLE);
            const thumbHeight = (MAX_MENU_VISIBLE / totalItems) * trackHeight;
            const thumbY = 130 + (scrollPercent * (trackHeight - thumbHeight));
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)'; ctx.fillRect(w - 30, 130, 10, trackHeight);
            ctx.fillStyle = '#00ffff'; ctx.fillRect(w - 30, thumbY, 10, thumbHeight);
        }

        for (let i = 0; i < MAX_MENU_VISIBLE; i++) {
            const realIndex = menuScrollIndex + i;
            if (realIndex >= totalItems) break;
            
            const item = fullList[realIndex];
            const isHovered = (realIndex === hoveredFileIndex);
            
            if (isHovered) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 60, 60);
                ctx.fillStyle = '#fff'; ctx.fillText(`> ${item.label}`, 80, listY);
            } else {
                ctx.fillStyle = item.color ? item.color : (item.type === 'sys' ? '#ff0055' : '#00aaaa');
                ctx.fillText(`  ${item.label}`, 80, listY);
            }
            
            if (item.type !== 'sys') {
                ctx.fillStyle = '#666'; ctx.fillText(item.type.toUpperCase(), w - 200, listY);
            }
            
            listY += 70;
        }

        if (sysMessage) {
            ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100);
            ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(sysMessage, w/2, h/2 + 15);
        }

        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(index) {
        if (index === 0) { 
            flightModeActive = !flightModeActive; 
            updateCockpitVisibility();
            sysMessage = flightModeActive ? "FLIGHT MODE ON" : "FLIGHT MODE OFF";
            updateMenuDisplay();
            setTimeout(()=>{ isMenuOpen=false; menuGroup.visible=false; }, 500);
            return; 
        }
        if (index === 1) { saveMission(); return; }
        if (index === 2) { loadMission(); return; }
        if (index === 3) { clearMission(); return; }
        if (index === 4) { 
            if(recognition) recognition.start(); 
            else sysMessage = "VOICE NOT READY"; 
            updateMenuDisplay();
            setTimeout(()=>{ isMenuOpen=false; menuGroup.visible=false; }, 500);
            return; 
        }
        if (index === 5) { performVisualScan(); updateMenuDisplay(); setTimeout(()=>{ isMenuOpen=false; menuGroup.visible=false; }, 500); return; }
        if (index === 6) { wipeMemory(); return; }

        const fileIndex = index - 7; 
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        
        if (fileIndex >= 0 && fileIndex < db.length) {
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const pos = camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(3));
            pos.y = 0; 
            
            const item = db[fileIndex];
            if (item.type === 'fbx' || item.type === 'glb') spawnModel(pos, item);
            else spawnScreen(pos, item);
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    function mapBones(model) {
        const skeleton = {
            hips: null, spine: null, head: null,
            leftLeg: null, rightLeg: null, 
            leftArm: null, rightArm: null 
        };
        
        model.traverse((o) => {
            if (o.isMesh) { 
                o.castShadow = false; o.receiveShadow = false;
                if (o.material) o.material.side = THREE.DoubleSide; 
            }
            if (!o.isBone) return;
            const n = o.name;

            if (n === 'J_Bip_L_UpperArm') skeleton.leftArm = o;
            if (n === 'J_Bip_R_UpperArm') skeleton.rightArm = o;
            if (n === 'J_Bip_C_Neck') skeleton.neck = o;
            if (n === 'J_Bip_C_Head') skeleton.head = o;
            if (n === 'J_Bip_C_Spine') skeleton.spine = o;
            if (n === 'J_Bip_L_UpperLeg') skeleton.leftLeg = o;
            if (n === 'J_Bip_R_UpperLeg') skeleton.rightLeg = o;
        });
        return skeleton;
    }

    function updateAI(model, dt) {
        if (!model.userData.skeleton) return;
        
        const skel = model.userData.skeleton;
        const playerPos = camera.getWorldPosition(new THREE.Vector3());
        const flatPlayerPos = new THREE.Vector3(playerPos.x, model.position.y, playerPos.z);
        const dist = model.position.distanceTo(flatPlayerPos);
        const time = Date.now() * 0.001;

        if (model.userData.enableHeadTracking !== false && !grabbedObject) { 
            model.lookAt(flatPlayerPos);
        }

        if (model.userData.isPaused) {
            if (skel.leftLeg) skel.leftLeg.rotation.x = THREE.MathUtils.lerp(skel.leftLeg.rotation.x, 0, 0.1);
            if (skel.rightLeg) skel.rightLeg.rotation.x = THREE.MathUtils.lerp(skel.rightLeg.rotation.x, 0, 0.1);
            if(skel.leftArm) { skel.leftArm.rotation.z = -1.2; skel.leftArm.rotation.x = 0; }
            if(skel.rightArm) { skel.rightArm.rotation.z = 1.2; skel.rightArm.rotation.x = 0; }
            if (skel.spine) {
                skel.spine.rotation.x = Math.sin(time * 2) * 0.05; 
                skel.spine.rotation.y = Math.sin(time * 1) * 0.02; 
            }
            return; 
        }

        if (dist < AI_BACKUP_DIST) {
            const dir = new THREE.Vector3().subVectors(model.position, flatPlayerPos).normalize();
            model.position.add(dir.multiplyScalar(AI_WALK_SPEED * 0.5));
        }
        else if (dist > AI_FOLLOW_DIST) {
            const dir = new THREE.Vector3().subVectors(flatPlayerPos, model.position).normalize();
            model.position.add(dir.multiplyScalar(AI_WALK_SPEED));
            
            if (skel.leftLeg && skel.rightLeg) {
                skel.leftLeg.rotation.x = Math.sin(time * 10) * 0.5;
                skel.rightLeg.rotation.x = -Math.sin(time * 10) * 0.5;
                if(skel.leftArm) skel.leftArm.rotation.z = -1.2; 
                if(skel.rightArm) skel.rightArm.rotation.z = 1.2; 
                if(skel.leftArm) skel.leftArm.rotation.x = Math.sin(time * 10 + Math.PI) * 0.2;
                if(skel.rightArm) skel.rightArm.rotation.x = Math.sin(time * 10) * 0.2;
            }
        }
        else {
            if (skel.leftLeg) skel.leftLeg.rotation.x = THREE.MathUtils.lerp(skel.leftLeg.rotation.x, 0, 0.1);
            if (skel.rightLeg) skel.rightLeg.rotation.x = THREE.MathUtils.lerp(skel.rightLeg.rotation.x, 0, 0.1);
            if(skel.leftArm) { skel.leftArm.rotation.z = -1.2; skel.leftArm.rotation.x = 0; }
            if(skel.rightArm) { skel.rightArm.rotation.z = 1.2; skel.rightArm.rotation.x = 0; }
            if (skel.spine) {
                skel.spine.rotation.x = Math.sin(time * 2) * 0.05; 
                skel.spine.rotation.y = Math.sin(time * 1) * 0.02; 
            }
        }
    }

    function spawnModel(position, data, rotation = null, scale = null) {
        const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const boxMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
        const placeholder = new THREE.Mesh(boxGeo, boxMat);
        placeholder.position.copy(position);
        placeholder.userData = { isScreen: true, isModel: true, label: "LOADING...", type: data.type };
        scene.add(placeholder);
        targets.push(placeholder);

        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        
        loader.load(data.src, (loaded) => {
            scene.remove(placeholder);
            targets = targets.filter(t => t !== placeholder);

            const model = data.type === 'fbx' ? loaded : loaded.scene;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    child.raycast = function() {}; 
                }
            });

            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z) || 1; 
            const scaleFactor = 1.0 / maxDim; 
            
            model.scale.set(scaleFactor, scaleFactor, scaleFactor);
            if (scale) model.scale.copy(scale);

            model.position.copy(position);
            if (rotation) model.rotation.copy(rotation);
            
            const helperGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const helperMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent:true, opacity:0.5 });
            const helperMesh = new THREE.Mesh(helperGeo, helperMat);
            helperMesh.position.y = size.y / 2; 
            helperMesh.raycast = THREE.Mesh.prototype.raycast;
            
            model.add(helperMesh); 
            
            const skel = mapBones(model);
            model.userData = { 
                isScreen: true, 
                isModel: true, 
                label: data.label, 
                type: data.type, 
                skeleton: skel, 
                aiActive: true,
                isPaused: false,
                enableHeadTracking: true 
            };
            
            scene.add(model);
            targets.push(model);
            sysMessage = "AI AGENT DEPLOYED"; updateMenuDisplay();
        }, undefined, (error) => {
            console.error(error);
            placeholder.material.color.setHex(0xff0000);
            placeholder.userData.label = "ERROR: LOAD FAILED";
            sysMessage = "LOAD ERROR"; updateMenuDisplay();
        });
    }

    async function spawnScreen(position, data, rotation = null) {
        // Init with 1x1 plane
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent:true, opacity:0.9 });
        const screen = new THREE.Mesh(geometry, material);
        screen.position.copy(position); 
        
        if (rotation) screen.rotation.copy(rotation);
        else {
            const pPos = camera.getWorldPosition(new THREE.Vector3());
            screen.lookAt(pPos.x, screen.position.y, pPos.z);
        }
        
        screen.userData = { isScreen: true, label: data.label, type: data.type };

        if (data.type === 'pdf') {
            const clonedBuffer = data.buffer.slice(0);
            const pdf = await pdfjsLib.getDocument(clonedBuffer).promise;
            screen.userData.pdfDoc = pdf; 
            screen.userData.pageNum = 1; 
            screen.userData.totalPages = pdf.numPages;
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0xffff00 })));
            await renderPdfPageToTexture(screen, 1);
            
        } else if (data.type === 'video') {
            const videoElem = document.createElement('video'); videoElem.src = data.src; videoElem.crossOrigin = "anonymous"; videoElem.loop = true; videoElem.muted = true; 
            videoElem.play().then(() => { videoElem.muted = false; });
            const tex = new THREE.VideoTexture(videoElem); tex.colorSpace = THREE.SRGBColorSpace;
            screen.material.map = tex; screen.userData.videoElement = videoElem;
            screen.scale.set(3, 1.8, 1); 
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        } else {
            const tex = new THREE.TextureLoader().load(data.src); 
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            screen.material.map = tex;
            
            const img = new Image();
            img.src = data.src;
            img.onload = () => {
                const aspect = img.width / img.height;
                screen.scale.set(1.8 * aspect, 1.8, 1); 
            }
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        }
        scene.add(screen); targets.push(screen);
    }
    
    async function renderPdfPageToTexture(mesh, pageNum) {
        if (!mesh.userData.pdfDoc) return;
        if (mesh.userData.isRendering) return; 
        mesh.userData.isRendering = true;
        try {
            const pdf = mesh.userData.pdfDoc;
            if (pageNum < 1) pageNum = 1; if (pageNum > pdf.numPages) pageNum = pdf.numPages;
            mesh.userData.pageNum = pageNum;
            const page = await pdf.getPage(pageNum);
            
            const viewport = page.getViewport({ scale: 3.0 });
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.height = viewport.height; canvas.width = viewport.width;
            
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            
            const tex = new THREE.CanvasTexture(canvas); 
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            if (mesh.material.map) mesh.material.map.dispose(); 
            mesh.material.map = tex; 
            mesh.material.needsUpdate = true;
            
            const aspectRatio = viewport.width / viewport.height;
            mesh.scale.set(1.8 * aspectRatio, 1.8, 1);
            
        } catch(e) { console.error(e); }
        mesh.userData.isRendering = false;
    }

    function deleteObject(obj) {
        if (obj.userData.videoElement) {
            obj.userData.videoElement.pause(); obj.userData.videoElement.src = ""; obj.userData.videoElement.load();
        }
        if (obj.material && obj.material.map) obj.material.map.dispose();
        scene.remove(obj); targets = targets.filter(t => t !== obj);
    }

    function handleInput() {
        if (renderer.xr.isPresenting && isMouseDown) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, VR_WALK_SPEED);
        }

        const pads = navigator.getGamepads();
        let pad = null;
        for (let i = 0; i < pads.length; i++) {
            if (pads[i] && pads[i].buttons.length > 0) {
                pad = pads[i];
                break; 
            }
        }
        
        if (!pad) return;

        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        let activeTarget = null;
        
        if (isMenuOpen) {
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const worldPos = camera.getWorldPosition(new THREE.Vector3());
            const targetPos = worldPos.add(dir.multiplyScalar(2.5));
            menuGroup.position.copy(targetPos); menuGroup.lookAt(camera.getWorldPosition(new THREE.Vector3()));
            
            if (pad.axes.length > 3 && Math.abs(pad.axes[3]) > 0.5) {
                const now = Date.now();
                if (now - lastMenuScrollTime > 150) { 
                    const fullListSize = 6 + (CUSTOM_DATABASE.length || 1); 
                    if (pad.axes[3] > 0) menuScrollIndex++; 
                    else menuScrollIndex--; 
                    
                    menuScrollIndex = Math.max(0, Math.min(menuScrollIndex, fullListSize - MAX_MENU_VISIBLE));
                    lastMenuScrollTime = now;
                    updateMenuDisplay();
                }
            }

            const intersects = raycaster.intersectObject(menuMesh);
            if (intersects.length > 0) {
                const uvY = intersects[0].uv.y;
                if (uvY < 0.82) {
                    const visualIdx = Math.floor((0.82 - uvY) / 0.068);
                    if (visualIdx >= 0 && visualIdx < MAX_MENU_VISIBLE) {
                        const realIdx = visualIdx + menuScrollIndex;
                        const fullListSize = 6 + (CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE.length : DEFAULT_DATABASE.length);
                        if (realIdx < fullListSize && hoveredFileIndex !== realIdx) { 
                            hoveredFileIndex = realIdx; 
                            updateMenuDisplay(); 
                        }
                    }
                }
            } else { if(hoveredFileIndex !== -1) { hoveredFileIndex = -1; updateMenuDisplay(); } }
            
            if (pad.buttons[0] && pad.buttons[0].pressed && !lastBtn.x && hoveredFileIndex !== -1) spawnFromMenu(hoveredFileIndex);
            
        } else {
            if (pad.buttons[0] && pad.buttons[0].pressed && !lastBtn.x) {
                if (grabbedObject) {
                    grabbedObject = null;
                } else {
                    const intersects = raycaster.intersectObjects(targets, true);
                    if (intersects.length > 0) {
                        let hit = intersects[0].object;
                        while(hit.parent && !hit.userData.isScreen && hit !== scene) { hit = hit.parent; }
                        if (hit.userData.isScreen || hit.userData.isModel) { 
                            grabbedObject = hit; 
                        } 
                    }
                }
            }
            
            if (grabbedObject) {
                activeObject.obj = grabbedObject;
                activeTarget = grabbedObject;
            } else {
                const intersects = raycaster.intersectObjects(targets, true); 
                if (intersects.length > 0) {
                    let hit = intersects[0].object;
                    while(hit.parent && !hit.userData.isScreen && hit !== scene) { hit = hit.parent; }
                    if (hit.userData.isScreen || hit.userData.isModel) { activeObject.obj = hit; activeTarget = hit; } 
                    else { activeObject.obj = null; }

                    if (activeTarget && pad.buttons[1] && pad.buttons[1].pressed && !lastBtn.circle) { 
                        deleteObject(activeTarget); activeObject.obj = null; activeTarget = null; 
                    }
                } else { activeObject.obj = null; }
            }
        }

        const leftStickX = pad.axes.length > 0 ? pad.axes[0] : 0;
        const leftStickY = pad.axes.length > 1 ? pad.axes[1] : 0;
        const rightStickX = pad.axes.length > 2 ? pad.axes[2] : 0;
        const rightStickY = pad.axes.length > 3 ? pad.axes[3] : 0;

        if (grabbedObject) {
            if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _camRight.crossVectors(camera.up, _moveDir).normalize();
                _camUp.copy(camera.up);
                grabbedObject.position.addScaledVector(_camRight, leftStickX * SPEED);
                grabbedObject.position.addScaledVector(_camUp, -leftStickY * SPEED);
            }
            const l2 = (pad.buttons[6] && pad.buttons[6].value) ? pad.buttons[6].value : 0;
            const r2 = (pad.buttons[7] && pad.buttons[7].value) ? pad.buttons[7].value : 0;
            if (Math.abs(r2) > 0.1 || Math.abs(l2) > 0.1) {
                const dir = new THREE.Vector3().subVectors(grabbedObject.position, camera.position).normalize();
                const zSpeed = (r2 - l2) * MOVE_SPEED;
                grabbedObject.position.addScaledVector(dir, zSpeed);
            }
            if (Math.abs(rightStickX) > 0.1) grabbedObject.rotation.y += rightStickX * ROTATE_SPEED;
            if (Math.abs(rightStickY) > 0.1) {
                if (grabbedObject.userData.isModel) {
                     const s = 1 + (rightStickY * -SCALE_SPEED); 
                     grabbedObject.scale.multiplyScalar(s);
                } else {
                     grabbedObject.rotation.x += rightStickY * ROTATE_SPEED;
                }
            }
        } else if (activeTarget) {
            if (Math.abs(rightStickX) > 0.1) activeTarget.rotation.y += rightStickX * ROTATE_SPEED;
            if (Math.abs(rightStickY) > 0.1) {
                if (activeTarget.userData.isModel) {
                     const s = 1 + (rightStickY * -SCALE_SPEED); 
                     activeTarget.scale.multiplyScalar(s);
                } else {
                     activeTarget.rotation.x += rightStickY * ROTATE_SPEED;
                }
            }
            if (activeTarget.userData.type === 'pdf' && Math.abs(leftStickX) > 0.5) {
                const now = Date.now();
                if (now - lastPageTurnTime > PAGE_DEBOUNCE) {
                    const dir = Math.sign(leftStickX); 
                    const newPage = activeTarget.userData.pageNum + dir;
                    if (newPage >= 1 && newPage <= activeTarget.userData.totalPages) {
                        renderPdfPageToTexture(activeTarget, newPage);
                        lastPageTurnTime = now;
                    }
                }
            } 
            if (activeTarget.userData.type !== 'pdf' || Math.abs(leftStickX) < 0.5) {
                 if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                    camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                    _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                    dolly.position.addScaledVector(_moveDir, -leftStickY * SPEED);
                    dolly.position.addScaledVector(_strafeDir, leftStickX * SPEED);
                }
            }
        } else {
            if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -leftStickY * SPEED);
                dolly.position.addScaledVector(_strafeDir, leftStickX * SPEED);
            }
        }

        if (pad.buttons[13] && pad.buttons[13].pressed && !lastBtn.dpadDown) {
            if(recognition) { if(isListening) recognition.stop(); else recognition.start(); }
        }
        lastBtn.dpadDown = pad.buttons[13] ? pad.buttons[13].pressed : false;

        if (pad.buttons[14] && pad.buttons[14].pressed && !lastBtn.dpadLeft) performVisualScan();
        lastBtn.dpadLeft = pad.buttons[14] ? pad.buttons[14].pressed : false;

        if (pad.buttons[12] && pad.buttons[12].pressed && !lastBtn.dpadUp) {
            if (activeObject.obj && activeObject.obj.userData.isModel) activeObject.obj.userData.isPaused = !activeObject.obj.userData.isPaused;
        }
        lastBtn.dpadUp = pad.buttons[12] ? pad.buttons[12].pressed : false;

        if (pad.buttons[15] && pad.buttons[15].pressed && !lastBtn.dpadRight) {
            if (activeObject.obj && activeObject.obj.userData.isModel) {
                activeObject.obj.userData.enableHeadTracking = !activeObject.obj.userData.enableHeadTracking;
            }
        }
        lastBtn.dpadRight = pad.buttons[15] ? pad.buttons[15].pressed : false;

        if (pad.buttons[2] && pad.buttons[2].pressed && !lastBtn.square) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; }
        lastBtn.square = pad.buttons[2] ? pad.buttons[2].pressed : false;
        
        lastBtn.x = pad.buttons[0] ? pad.buttons[0].pressed : false; 

        if (pad.buttons[3] && pad.buttons[3].pressed && !lastBtn.triangle) {
            visionMode = (visionMode + 1) % 3;
            if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
        }
        lastBtn.triangle = pad.buttons[3] ? pad.buttons[3].pressed : false;
        lastBtn.circle = pad.buttons[1] ? pad.buttons[1].pressed : false;
    }

    let lastHudState = ""; 
    function updateHUD() {
        if(!hudContext) return;
        const currentState = `M:${isMenuOpen}|S:${isSpeaking}|L:${isListening}|V:${visionMode}|G:${grabbedObject ? 'YES' : 'NO'}|T:${activeObject.obj ? activeObject.obj.uuid : 'NONE'}|A:${aiStatus}`;
        if (currentState === lastHudState) return;
        lastHudState = currentState; 

        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
        else if(visionMode === 2) { ctx.fillStyle = '#ff0000'; ctx.fillText("VISION: [VOID]", w-40, 60); }
        else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }

        ctx.textAlign = 'left'; ctx.fillStyle = isSpeaking ? '#00ff00' : (isListening ? '#ff0055' : '#00ffff');
        ctx.fillText(`AI: [${aiStatus}]`, 40, 60);

        const cx = w/2; const cy = h/2;
        if (isMenuOpen) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.fillText("MENU OPEN", cx, cy + 200);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10); ctx.stroke();
        } else if (activeObject.obj) {
            
            if (grabbedObject) {
                ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(cx, cy, 50, 0, 2*Math.PI); ctx.stroke();
                ctx.fillStyle = '#ff0055'; ctx.textAlign = 'center'; ctx.font = '24px Courier New';
                ctx.fillText("STATUS: MANIPULATING", cx, cy + 80);
                ctx.fillText("[RELEASE] TO DROP", cx, cy + 110);
            } else {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, 2*Math.PI); ctx.stroke();
                ctx.textAlign = 'center'; ctx.font = '20px Courier New'; ctx.fillStyle = '#fff'; 
                ctx.fillText(activeObject.obj.userData.label || "TARGET", cx, cy + 80); 
                
                if (activeObject.obj.userData.isModel) {
                     if(activeObject.obj.userData.aiActive) {
                         const status = activeObject.obj.userData.isPaused ? "HOLDING" : "FOLLOWING";
                         ctx.fillStyle = activeObject.obj.userData.isPaused ? '#ffff00' : '#00ff00';
                         ctx.fillText(`AI: ${status}`, cx, cy + 145);
                     }
                }
            }
        } else {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            handleCockpit(); 
            updateHUD(); 
            targets.forEach(t => { 
                if(t.userData.isModel && t.userData.aiActive) {
                    updateAI(t);
                }
            }); 
            renderer.render(scene, camera); 
        });
    }
</script>
</body>
</html>
