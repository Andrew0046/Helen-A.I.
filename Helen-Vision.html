<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: HARDWARE SCAN</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; }
        .log-box { 
            margin-top: 20px; padding: 10px; border: 1px solid #00ffff; 
            background: #001122; color: #00ffff; font-size: 11px; width: 85%; height: 150px;
            white-space: pre-wrap; text-align: left; overflow-y: auto;
            font-family: monospace;
        }
        button {
            margin-top: 20px; padding: 15px 30px; background: #00ffff; color: #000; 
            font-weight: bold; border: none; font-size: 16px; cursor: pointer; display: none;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>

<div id="overlay">
    <h1>HELEN: SCANNER</h1>
    <div class="status" id="status-text">INITIALIZING HARDWARE SEARCH...</div>
    <div class="log-box" id="debug-log"></div>
    <div id="xr-button-container"></div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import WebXRPolyfill from 'webxr-polyfill';

    const polyfill = new WebXRPolyfill();

    let scene, camera, renderer, dolly;
    let videoTrack; 
    let selectedDeviceId = null;
    
    let visionMode = 0; 
    let lastBtnState = false; 

    // --- LOGGING ---
    function log(msg) {
        console.log(msg);
        const el = document.getElementById('debug-log');
        el.innerText += `> ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }

    // --- STEP 1: FIND THE TORCH ---
    async function findTorchCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            log("Error: MediaDevices API missing.");
            return;
        }

        try {
            // 1. Get Permission first (generic)
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            stream.getTracks().forEach(t => t.stop()); // Close generic stream
            log("Permission granted. Scanning lenses...");

            // 2. List all cameras
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cameras = devices.filter(d => d.kind === 'videoinput');
            
            log(`Found ${cameras.length} cameras.`);

            // 3. Test each camera for Torch capability
            for (const cam of cameras) {
                log(`Testing: ${cam.label || 'Unknown Camera'}...`);
                
                try {
                    const testStream = await navigator.mediaDevices.getUserMedia({
                        video: { deviceId: { exact: cam.deviceId } }
                    });
                    const track = testStream.getVideoTracks()[0];
                    const capabilities = track.getCapabilities();

                    if (capabilities.torch) {
                        log(">>> TORCH FOUND! <<<");
                        selectedDeviceId = cam.deviceId;
                        track.stop(); // Stop testing
                        break; // Stop looking, we found it
                    } else {
                        log("No torch on this lens.");
                    }
                    track.stop();
                } catch (e) {
                    log(`Skip: ${e.name}`);
                }
            }

            if (selectedDeviceId) {
                startMainApp(selectedDeviceId);
            } else {
                log("FAILURE: No camera with torch found.");
                log("Falling back to default camera...");
                startMainApp(null); // Fallback
            }

        } catch (err) {
            log("CRITICAL ERROR: " + err.message);
        }
    }

    // --- STEP 2: START THE APP ---
    async function startMainApp(deviceId) {
        const constraints = {
            video: deviceId 
                ? { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }
                : { facingMode: 'environment' }
        };

        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            videoTrack = stream.getVideoTracks()[0];
            
            document.getElementById('status-text').innerText = "SYSTEM READY - ENTER VR";
            init3D();

        } catch (err) {
            log("Start Failed: " + err.message);
        }
    }

    async function toggleFlashlight(active) {
        if (!videoTrack) return;
        try {
            await videoTrack.applyConstraints({ advanced: [{ torch: active }] });
            log(`Torch: ${active ? 'ON' : 'OFF'}`);
        } catch (err) {
            log("Torch Error: " + err.message);
        }
    }

    // --- 3D ENGINE ---
    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        dolly.add(camera);

        // Video Background (Shader-Ready)
        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video);
        vidTex.colorSpace = THREE.SRGBColorSpace;
        vidTex.generateMipmaps = false;

        const material = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse: { value: vidTex },
                uMode: { value: 0.0 }, 
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; uniform float uMode; varying vec2 vUv; uniform vec2 uResolution;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    if (uMode > 0.5) {
                        float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                        vec4 h = -1.0*texture2D(tDiffuse,vUv+vec2(-x,-y)) -2.0*texture2D(tDiffuse,vUv+vec2(-x,0)) -1.0*texture2D(tDiffuse,vUv+vec2(-x,y)) +1.0*texture2D(tDiffuse,vUv+vec2(x,-y)) +2.0*texture2D(tDiffuse,vUv+vec2(x,0)) +1.0*texture2D(tDiffuse,vUv+vec2(x,y));
                        vec4 v = -1.0*texture2D(tDiffuse,vUv+vec2(-x,-y)) -2.0*texture2D(tDiffuse,vUv+vec2(0,-y)) -1.0*texture2D(tDiffuse,vUv+vec2(x,-y)) +1.0*texture2D(tDiffuse,vUv+vec2(-x,y)) +2.0*texture2D(tDiffuse,vUv+vec2(0,y)) +1.0*texture2D(tDiffuse,vUv+vec2(x,y));
                        float val = length(sqrt(h.rgb*h.rgb + v.rgb*v.rgb));
                        if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0;
                        else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0);
                    } else { gl_FragColor = color; }
                }
            `,
            depthTest: false, depthWrite: false
        });

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), material);
        plane.position.z = -20; camera.add(plane);
        
        // Add Floating UI
        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 512; hudCanvas.height = 128;
        const ctx = hudCanvas.getContext('2d');
        ctx.fillStyle = '#0ff'; ctx.font = '30px monospace'; ctx.fillText('SYSTEM READY', 20, 70);
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.25), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(hudCanvas), transparent: true }));
        hudMesh.position.set(0, -0.5, -1.5); camera.add(hudMesh);

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const btn = VRButton.createButton(renderer);
        document.getElementById('xr-button-container').appendChild(btn);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    }

    function handleInput() {
        const gamepads = navigator.getGamepads();
        const pad = gamepads[0];
        if (pad) {
            const btnState = pad.buttons[3].pressed; // Triangle
            if (btnState && !lastBtnState) {
                visionMode = visionMode === 0 ? 1 : 0;
                scene.children[0].children[0].children[0].material.uniforms.uMode.value = visionMode; // Access Plane Material
                toggleFlashlight(visionMode === 1);
            }
            lastBtnState = btnState;
            
            // Movement
             const x = Math.abs(pad.axes[0]) > 0.1 ? pad.axes[0] : 0;
             const z = Math.abs(pad.axes[1]) > 0.1 ? pad.axes[1] : 0;
             if (x !== 0 || z !== 0) {
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
                const right = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
                dolly.position.addScaledVector(dir, -z * 0.1);
                dolly.position.addScaledVector(right, x * 0.1);
             }
        }
    }

    function animate() {
        renderer.setAnimationLoop(() => {
            handleInput();
            renderer.render(scene, camera);
        });
    }

    // Start
    findTorchCamera();

</script>
</body>
</html>
