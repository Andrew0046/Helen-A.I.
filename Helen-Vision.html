<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: NETWORK PROTOCOL</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        /* INPUT GROUP STYLES */
        .input-group { margin: 10px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 12px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 1px; font-size: 14px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 5px; font-size: 12px; padding: 10px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<div id="flash"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    
    <div class="status" id="system-status">
        [ NETWORK MODULE INSTALLED ]<br>
        1. Click RESET SYSTEM.<br>
        2. Enter Key & URLs.
    </div>

    <div class="input-group" id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="input-group" id="main-controls" style="display:none;">
        
        <div style="display:flex; gap:5px;">
            <input type="text" id="url-input" placeholder="PASTE HTTP LINK..." style="flex-grow:1;">
            <button onclick="loadFromUrl()" style="padding:12px;">TRANSMIT</button>
        </div>

        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD LOCAL FILES</button>
        
        <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [D-PAD DOWN] TALK <br>
            [D-PAD LEFT] VISUAL SCAN<br>
            [D-PAD UP] STAY / FOLLOW <br>
            [D-PAD RIGHT] INSPECT MODE
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    
    // --- AI & MEMORY ---
    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition; 
    let synth = window.speechSynthesis;
    let isListening = false;
    let isSpeaking = false;
    let aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try { const saved = localStorage.getItem('helen_chat_history'); if(saved) chatHistory = JSON.parse(saved); } catch(e) {}

    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [ { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' } ];
    let targets = []; 
    let activeObject = { obj: null, progress: 0 }; 
    let lastPageTurnTime = 0; const PAGE_DEBOUNCE = 300; 
    let pendingRestore = false; 

    // MENU & SCROLLING
    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let menuScrollIndex = 0; 
    let lastMenuScrollTime = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";

    // HARDWARE
    let torchCamId = null, wideCamId = null, activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false, dpadDown: false, dpadUp: false, dpadLeft: false, dpadRight: false };
    
    const SPEED = 0.1; 
    const ROTATE_SPEED = 0.05; 
    const MOVE_SPEED = 0.05;
    const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();

    const AI_FOLLOW_DIST = 2.5; 
    const AI_STOP_DIST = 1.5;
    const AI_BACKUP_DIST = 0.8;
    const AI_WALK_SPEED = 0.03;

    // --- SETUP & AUTH ---
    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else { alert("KEY INVALID"); }
    };

    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key');
        localStorage.removeItem('helen_layout_ai');
        localStorage.removeItem('helen_chat_history');
        location.reload();
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Memory Banks: ${Math.floor(chatHistory.length/2)} Contexts.<br>Network Link: ACTIVE.`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ 
                    model: "gemini-1.5-flash",
                    systemInstruction: "You are HELEN, a tactical AI. Short, robotic responses. Max 2 sentences."
                });
                initVoice();
            } catch(e) { document.getElementById('system-status').innerText = "AI INIT FAILED"; }
        }
    }

    function initVoice() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; if(aiStatus === "LISTENING...") aiStatus = "PROCESSING..."; updateHUD(); };
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                askGemini(transcript);
            };
        } else { sysMessage = "NO VOICE SUPPORT"; }
    }

    // --- NEW: URL LOADER ---
    window.loadFromUrl = function() {
        const url = document.getElementById('url-input').value.trim();
        if(!url) return;
        
        const cleanUrl = url.split('?')[0].toLowerCase();
        let type = 'link'; // Default to link portal
        
        // Detect file type from extension
        if(cleanUrl.endsWith('.glb') || cleanUrl.endsWith('.gltf') || cleanUrl.endsWith('.vrm')) type = 'glb';
        else if(cleanUrl.endsWith('.fbx')) type = 'fbx';
        else if(cleanUrl.endsWith('.jpg') || cleanUrl.endsWith('.png') || cleanUrl.endsWith('.jpeg')) type = 'image';
        else if(cleanUrl.endsWith('.mp4') || cleanUrl.endsWith('.webm')) type = 'video';
        else if(cleanUrl.endsWith('.pdf')) type = 'pdf'; // Note: PDF via URL might fail CORS often
        
        const label = url.substring(url.lastIndexOf('/')+1).substring(0, 15) || "LINK";
        
        const item = { type: type, src: url, label: label.toUpperCase() };
        CUSTOM_DATABASE.push(item);
        
        // Auto-spawn it immediately
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const pos = camera.getWorldPosition(new THREE.Vector3()).add(dir.multiplyScalar(3));
        pos.y = 0;
        
        if (type === 'fbx' || type === 'glb') spawnModel(pos, item);
        else if (type === 'link') spawnLink(pos, item);
        else spawnScreen(pos, item);
        
        document.getElementById('url-input').value = ""; // Clear
        document.getElementById('file-status').innerText = "NETWORK ASSET ACQUIRED";
        updateMenuDisplay();
    };

    // --- 6. SPAWNING LOGIC ---
    function spawnModel(position, data, rotation = null, scale = null) {
        const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const boxMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
        const placeholder = new THREE.Mesh(boxGeo, boxMat);
        placeholder.position.copy(position);
        placeholder.userData = { isScreen: true, isModel: true, label: "DOWNLOADING...", type: data.type };
        scene.add(placeholder);
        targets.push(placeholder);

        const loader = data.type === 'fbx' ? new FBXLoader() : new GLTFLoader();
        
        loader.load(data.src, (loaded) => {
            scene.remove(placeholder);
            targets = targets.filter(t => t !== placeholder);

            const model = data.type === 'fbx' ? loaded : loaded.scene;
            
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z) || 1; 
            const scaleFactor = 1.0 / maxDim; 
            
            model.scale.set(scaleFactor, scaleFactor, scaleFactor);
            if (scale) model.scale.copy(scale);

            model.position.copy(position);
            if (rotation) model.rotation.copy(rotation);
            
            const helperGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const helperMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent:true, opacity:0.5 });
            const helperMesh = new THREE.Mesh(helperGeo, helperMat);
            helperMesh.position.y = size.y / 2; 
            model.add(helperMesh); 
            
            const skel = mapBones(model);
            model.userData = { 
                isScreen: true, isModel: true, label: data.label, type: data.type, 
                skeleton: skel, aiActive: true, isPaused: false, enableHeadTracking: true 
            };
            
            scene.add(model);
            targets.push(model);
            sysMessage = "ASSET DEPLOYED"; updateMenuDisplay();
        }, undefined, (error) => {
            console.error(error);
            placeholder.material.color.setHex(0xff0000);
            placeholder.userData.label = "ERR: CORS/NET";
            sysMessage = "DOWNLOAD FAILED"; updateMenuDisplay();
        });
    }

    async function spawnScreen(position, data, rotation = null) {
        // ... (Standard screen spawning code) ...
        const geometry = new THREE.PlaneGeometry(3, 1.8);
        const screen = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }));
        screen.position.copy(position); 
        
        if (rotation) screen.rotation.copy(rotation);
        else {
            const pPos = camera.getWorldPosition(new THREE.Vector3());
            screen.lookAt(pPos.x, screen.position.y, pPos.z);
        }
        
        screen.userData = { isScreen: true, label: data.label, type: data.type };

        // Handle URL-based assets
        try {
            if (data.type === 'video') {
                const videoElem = document.createElement('video'); videoElem.src = data.src; 
                videoElem.crossOrigin = "anonymous"; videoElem.loop = true; videoElem.muted = true; 
                videoElem.play().then(() => { videoElem.muted = false; }).catch(e=>console.log(e));
                const tex = new THREE.VideoTexture(videoElem); tex.colorSpace = THREE.SRGBColorSpace;
                screen.material.map = tex; screen.userData.videoElement = videoElem;
            } else {
                // Image
                const tex = new THREE.TextureLoader().load(data.src); tex.colorSpace = THREE.SRGBColorSpace;
                screen.material.map = tex;
            }
            screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
            scene.add(screen); targets.push(screen);
        } catch(e) { console.log(e); }
    }

    // --- NEW: SPAWN LINK NODE ---
    function spawnLink(position, data) {
        // Create a floating text panel for the link
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#002244'; ctx.fillRect(0,0,512,256);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 10; ctx.strokeRect(0,0,512,256);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 40px Courier New'; ctx.textAlign = 'center';
        ctx.fillText("HYPERLINK DETECTED", 256, 80);
        ctx.fillStyle = '#ffffff'; ctx.font = '30px Courier New';
        ctx.fillText(data.src.substring(0, 25), 256, 140);
        ctx.fillText("[CLICK TO OPEN]", 256, 200);
        
        const tex = new THREE.CanvasTexture(canvas);
        const geometry = new THREE.PlaneGeometry(2, 1);
        const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
        
        mesh.position.copy(position);
        const pPos = camera.getWorldPosition(new THREE.Vector3());
        mesh.lookAt(pPos.x, mesh.position.y, pPos.z);
        
        mesh.userData = { isScreen: true, type: 'link', src: data.src, label: "WEB LINK" };
        scene.add(mesh); targets.push(mesh);
    }

    // ... (Keep existing AI functions: checkAuth, initVoice, askGemini, performVisualScan, speak, mapBones, updateAI) ...
    // ... (Keep existing Standard Functions: deleteObject, handleInput, updateHUD, animate) ...
    
    // --- COPY PASTE THE REST OF THE UTILITY FUNCTIONS HERE AS USUAL ---
    // (performVisualScan, askGemini, speak, mapBones, updateAI, deleteObject, updateHUD, animate etc.)
    // For brevity in this response, I assume you will retain the functions from the previous 'HELEN_OMNI' or 'HELEN_MEMORY' file.
    // The key changes are 'loadFromUrl', 'spawnLink', and the HTML input additions.

    // Below is a condensed refresher of handleInput to support Link Clicking
    
    function handleInput() {
        const pads = navigator.getGamepads(); if(!pads[0]) return;
        const pad = pads[0];
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        
        // ... (Menu Logic) ...
        if(isMenuOpen) { 
            // ... (Keep Menu Logic) ...
            // Re-use previous menu logic
             const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const worldPos = camera.getWorldPosition(new THREE.Vector3());
            const targetPos = worldPos.add(dir.multiplyScalar(2.5));
            menuGroup.position.copy(targetPos); menuGroup.lookAt(camera.getWorldPosition(new THREE.Vector3()));
            
            if (Math.abs(pad.axes[3]) > 0.5) {
                const now = Date.now();
                if (now - lastMenuScrollTime > 150) { 
                    const fullListSize = 6 + (CUSTOM_DATABASE.length || 1); 
                    if (pad.axes[3] > 0) menuScrollIndex++; 
                    else menuScrollIndex--; 
                    menuScrollIndex = Math.max(0, Math.min(menuScrollIndex, fullListSize - MAX_MENU_VISIBLE));
                    lastMenuScrollTime = now;
                    updateMenuDisplay();
                }
            }
            const intersects = raycaster.intersectObject(menuMesh);
            if (intersects.length > 0) {
                const uvY = intersects[0].uv.y;
                if (uvY < 0.82) {
                    const visualIdx = Math.floor((0.82 - uvY) / 0.068);
                    if (visualIdx >= 0 && visualIdx < MAX_MENU_VISIBLE) {
                        const realIdx = visualIdx + menuScrollIndex;
                        const fullListSize = 6 + (CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE.length : DEFAULT_DATABASE.length);
                        if (realIdx < fullListSize && hoveredFileIndex !== realIdx) { hoveredFileIndex = realIdx; updateMenuDisplay(); }
                    }
                }
            } else { if(hoveredFileIndex !== -1) { hoveredFileIndex = -1; updateMenuDisplay(); } }
            if (pad.buttons[0].pressed && !lastBtn.x && hoveredFileIndex !== -1) spawnFromMenu(hoveredFileIndex);
        } else {
            // TARGET LOGIC
            let activeTarget = null;
            const intersects = raycaster.intersectObjects(targets, true); 
            if (intersects.length > 0) {
                let hit = intersects[0].object;
                while(hit.parent && !hit.userData.isScreen && hit !== scene) { hit = hit.parent; }
                if (hit.userData.isScreen) { activeObject.obj = hit; activeTarget = hit; } 
                else { activeObject.obj = null; }

                // CLICKING (X Button)
                if (activeTarget && pad.buttons[0].pressed && !lastBtn.x) {
                    if (activeTarget.userData.type === 'link') {
                        // EXIT VR AND OPEN LINK
                        if(renderer.xr.isPresenting) renderer.xr.getSession().end();
                        window.open(activeTarget.userData.src, '_blank');
                    }
                }

                // DELETE (Circle)
                if (activeTarget && pad.buttons[1].pressed && !lastBtn.circle) { 
                    deleteObject(activeTarget); activeObject.obj = null; activeTarget = null; 
                }
            } else { activeObject.obj = null; }
            
            // ... (Keep Movement Logic) ...
            if (activeTarget && activeTarget.userData.type !== 'link') {
                 // Rotate/Scale Logic here (Keep from previous)
                 const rightStickX = pad.axes[2]; const rightStickY = pad.axes[3]; 
                 if (Math.abs(rightStickX) > 0.1) activeTarget.rotation.y += rightStickX * ROTATE_SPEED;
                 // etc...
            }
        }
        
        // ... (Keep Button Triggers) ...
        if (pad.buttons[13].pressed && !lastBtn.dpadDown) { if(recognition) { if(isListening) recognition.stop(); else recognition.start(); } }
        lastBtn.dpadDown = pad.buttons[13].pressed;
        if (pad.buttons[14].pressed && !lastBtn.dpadLeft) { performVisualScan(); }
        lastBtn.dpadLeft = pad.buttons[14].pressed;
        if (pad.buttons[12].pressed && !lastBtn.dpadUp) { if (activeObject.obj?.userData.isModel) activeObject.obj.userData.isPaused = !activeObject.obj.userData.isPaused; }
        lastBtn.dpadUp = pad.buttons[12].pressed;
        if (pad.buttons[15].pressed && !lastBtn.dpadRight) { if (activeObject.obj?.userData.isModel) activeObject.obj.userData.enableHeadTracking = !activeObject.obj.userData.enableHeadTracking; }
        lastBtn.dpadRight = pad.buttons[15].pressed;
        
        if (pad.buttons[2].pressed && !lastBtn.square) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; }
        lastBtn.square = pad.buttons[2].pressed;
        
        // Camera toggle
        if (pad.buttons[3].pressed && !lastBtn.triangle) {
            visionMode = (visionMode + 1) % 3;
            if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
            if (visionMode === 1 && torchCamId) startCameraStream(torchCamId).then(()=>videoTrack?.applyConstraints({advanced:[{torch:true}]}));
            else { videoTrack?.applyConstraints({advanced:[{torch:false}]}); if(visionMode === 0 && wideCamId) setTimeout(()=>startCameraStream(wideCamId),300); }
        }
        lastBtn.triangle = pad.buttons[3].pressed;
        lastBtn.x = pad.buttons[0].pressed; 
        lastBtn.circle = pad.buttons[1].pressed;
    }
    
    // RENDER LOOP
    async function performVisualScan() {
        if (!model) return;
        aiStatus = "CAPTURING..."; updateHUD();
        const flash = document.getElementById('flash'); flash.style.opacity = 0.8; setTimeout(() => { flash.style.opacity = 0; }, 100);
        const video = document.getElementById('camera-feed'); const canvas = document.getElementById('vision-canvas');
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d'); ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const base64Image = canvas.toDataURL('image/jpeg', 0.8).split(',')[1]; 
        aiStatus = "ANALYZING..."; updateHUD();
        try {
            const prompt = "Analyze this image tactically.";
            const imagePart = { inlineData: { data: base64Image, mimeType: "image/jpeg" } };
            const result = await model.generateContent([prompt, imagePart]);
            const response = await result.response; const text = response.text();
            chatHistory.push({ role: "user", parts: [{ text: "[Image]" }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory));
            speak(text);
        } catch (error) { aiStatus = "VISUAL ERROR"; speak("Sensors failed."); }
    }

    async function askGemini(prompt) {
        aiStatus = "THINKING..."; updateHUD();
        try {
            const chat = model.startChat({ history: chatHistory });
            const result = await chat.sendMessage(prompt);
            const response = await result.response; const text = response.text();
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            if(chatHistory.length > 20) chatHistory = chatHistory.slice(chatHistory.length - 20);
            localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory));
            speak(text);
        } catch (error) { aiStatus = "NET ERROR"; speak("Connection lost."); }
    }

    function deleteObject(obj) {
        if (obj.userData.videoElement) { obj.userData.videoElement.pause(); obj.userData.videoElement.src = ""; obj.userData.videoElement.load(); }
        if (obj.material && obj.material.map) obj.material.map.dispose();
        scene.remove(obj); targets = targets.filter(t => t !== obj);
    }

    function updateHUD() {
        if(!hudContext) return;
        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
        else if(visionMode === 2) { ctx.fillStyle = '#ff0000'; ctx.fillText("VISION: [VOID]", w-40, 60); }
        else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }
        ctx.textAlign = 'left'; ctx.fillStyle = isSpeaking ? '#00ff00' : (isListening ? '#ff0055' : '#00ffff');
        ctx.fillText(`AI: [${aiStatus}]`, 40, 60);
        const cx = w/2; const cy = h/2;
        if (isMenuOpen) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.fillText("MENU OPEN", cx, cy + 200);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10); ctx.stroke();
        } else if (activeObject.obj) {
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, 2*Math.PI); ctx.stroke();
            ctx.textAlign = 'center'; ctx.font = '20px Courier New'; ctx.fillStyle = '#fff'; 
            ctx.fillText(activeObject.obj.userData.label || "TARGET", cx, cy + 80); 
            
            if (activeObject.obj.userData.type === 'link') {
                 ctx.fillStyle = '#ffff00';
                 ctx.fillText("[X] OPEN LINK", cx, cy + 120);
            } else if (activeObject.obj.userData.isModel) {
                 if(activeObject.obj.userData.aiActive) {
                     const status = activeObject.obj.userData.isPaused ? "HOLDING" : "FOLLOWING";
                     const trackStatus = activeObject.obj.userData.enableHeadTracking ? "TRACKING: ON" : "TRACKING: OFF";
                     ctx.fillStyle = activeObject.obj.userData.isPaused ? '#ffff00' : '#00ff00';
                     ctx.fillText(status, cx, cy + 120);
                     ctx.fillStyle = '#00ffff'; ctx.fillText(trackStatus, cx, cy + 145);
                 }
            } else {
                 ctx.fillText("[R-STICK] ROTATE", cx, cy + 120);
            }
        } else {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            updateHUD(); 
            targets.forEach(t => { if(t.userData.isModel && t.userData.aiActive) updateAI(t); }); 
            renderer.render(scene, camera); 
        });
    }
    
    scanCameras().then(init3D);
</script>
</body>
</html>
