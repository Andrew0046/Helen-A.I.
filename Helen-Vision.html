<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: ARCHITECT</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; }
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 30px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase;
        }
        button.primary { background: #00ffff; color: #000; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        .save-alert { color: #00ff00; font-weight:bold; margin-bottom: 10px; display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<input type="file" id="intel-input" multiple accept="image/*,video/*,application/pdf" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="save-found-msg" class="save-alert">‚ö†Ô∏è ARCHITECT DATA FOUND</div>
    <div class="status">
        [ ARCHITECT MODE ]<br>
        Precision Placement & Editing.
    </div>

    <div class="btn-group">
        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD DATABASE</button>
        <button id="restore-btn" style="display:none; border-color:#00ff00; color:#00ff00;" onclick="restoreMission()">‚Ü∫ RESTORE LAYOUT</button>
        <div id="file-status" style="color:#00ff00; font-size:12px; display:none; text-align:right;"></div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [‚ñ°] MENU &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [X] SELECT / PLACE<br>
            [O] CANCEL &nbsp;&nbsp;&nbsp;&nbsp; [L1/R1] ROTATE / LENS
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import WebXRPolyfill from 'webxr-polyfill';

    const polyfill = new WebXRPolyfill();

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    
    // DATA
    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [
        { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'MONA_LISA.JPG' },
        { type: 'video', src: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4', label: 'BUNNY.MP4' }
    ];

    let targets = []; 
    let activeObject = { obj: null, progress: 0 }; 
    
    // GHOST / PLACEMENT SYSTEM
    let ghostMesh = null;
    let placementData = null; // Data of object being placed
    let placementDist = 2.5; // Default distance
    let holdTimer = 0; // For "Hold X to Move"

    // MENU
    let menuGroup, menuMesh, menuCanvas, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let systemMessage = "";

    // HARDWARE
    let torchCamId = null, wideCamId = null, activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false };
    const SPEED = 0.1; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();

    // --- 0. PERSISTENCE ---
    const savedData = localStorage.getItem('helen_architect_save');
    if (savedData) {
        document.getElementById('save-found-msg').style.display = 'block';
        document.getElementById('restore-btn').style.display = 'block';
    }

    window.restoreMission = function() {
        window.shouldRestore = true;
        document.getElementById('restore-btn').innerText = ">> RESTORE ARMED <<";
        document.getElementById('restore-btn').style.background = "#003300";
    };

    // --- 1. FILE PROCESSING ---
    const input = document.getElementById('intel-input');
    const statusLabel = document.getElementById('file-status');

    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            statusLabel.innerText = "PROCESSING..."; statusLabel.style.display = 'block';
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                if(name.length > 15) name = name.substring(0,12) + "...";
                
                const reader = new FileReader();
                const base64Promise = new Promise(resolve => { reader.onload = e => resolve(e.target.result); reader.readAsDataURL(file); });
                const base64 = await base64Promise;

                if (file.type === 'application/pdf') {
                    try {
                        const pdfData = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument(pdfData).promise;
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 2.0 });
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.height = viewport.height; canvas.width = viewport.width;
                        await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                        CUSTOM_DATABASE.push({ type: 'pdf', src: canvas.toDataURL('image/png'), label: name, ratio: viewport.width / viewport.height });
                    } catch (err) {}
                } 
                else if (file.type.startsWith('video')) {
                    CUSTOM_DATABASE.push({ type: 'video', src: URL.createObjectURL(file), label: name, isBlob: true });
                } 
                else {
                    CUSTOM_DATABASE.push({ type: 'image', src: base64, label: name });
                }
            }
            statusLabel.innerText = `${CUSTOM_DATABASE.length} FILES READY`;
        }
    });

    // --- 2. HARDWARE ---
    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front'));
        allBackCameras = cameras.map(c => c.deviceId);
        
        for (const cam of cameras) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: cam.deviceId } } });
                const track = stream.getVideoTracks()[0];
                if (track.getCapabilities().torch) torchCamId = cam.deviceId;
                track.stop();
            } catch(e) {}
        }
        if (torchCamId) {
            const other = cameras.find(c => c.deviceId !== torchCamId);
            if (other) wideCamId = other.deviceId;
        } else if (cameras.length > 0) {
            torchCamId = cameras[0].deviceId;
            if(cameras.length > 1) wideCamId = cameras[1].deviceId;
        }
        startCameraStream(wideCamId || torchCamId);
    }

    async function startCameraStream(preferredId) {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            const constraints = preferredId ? { video: { deviceId: { exact: preferredId } } } : { video: { facingMode: 'environment' } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            await video.play();
            currentStream = stream;
            videoTrack = stream.getVideoTracks()[0];
            activeCamId = preferredId;
            if (camMaterial) {
                camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
                camMaterial.uniforms.tDiffuse.value.colorSpace = THREE.SRGBColorSpace;
                camMaterial.uniforms.tDiffuse.value.generateMipmaps = false;
            }
        } catch (err) {}
    }

    // --- 3. 3D ENGINE ---
    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            if (uMode > 1.5) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            else if (uMode > 0.5) {
                float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                vec4 horizEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) + -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec4 vertEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) + -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
            } else gl_FragColor = color; 
        }
    `;

    function init3D() {
        scene = new THREE.Scene();
        dolly = new THREE.Group(); dolly.position.set(0, 0, 5); scene.add(dolly);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100); dolly.add(camera);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video); vidTex.colorSpace = THREE.SRGBColorSpace; vidTex.generateMipmaps = false; 
        camMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: vidTex }, uMode: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } },
            vertexShader: vertexShader, fragmentShader: fragmentShader, depthTest: false, depthWrite: false
        });
        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial); camPlane.position.z = -20; camera.add(camPlane); 

        const hudCanvas = document.createElement('canvas'); hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d'); hudTexture = new THREE.CanvasTexture(hudCanvas); hudTexture.minFilter = THREE.LinearFilter;
        const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, opacity: 0.9, depthTest: false }));
        hudMesh.position.set(0, 0, -1.5); camera.add(hudMesh);

        scene.add(new THREE.GridHelper(40, 40, 0x00ffff, 0x111111));
        const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(0, 5, 5); scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 1));
        
        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const btn = VRButton.createButton(renderer);
        btn.className = "primary"; btn.innerHTML = "ENTER VR";
        document.getElementById('vr-btn-container').appendChild(btn);
        
        renderer.xr.addEventListener('sessionstart', () => {
            document.getElementById('overlay').style.display = 'none';
            if (window.shouldRestore) applySaveData();
        });

        createMenuSystem();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    }

    // --- 4. GHOST PLACEMENT SYSTEM ---
    function startPlacement(data) {
        // Clear previous ghost if any
        if (ghostMesh) { scene.remove(ghostMesh); ghostMesh = null; }

        placementData = data;
        placementDist = 2.5; // Reset distance
        
        // Create Visual Ghost
        let width = 3, height = 1.8;
        if (data.type === 'pdf' && data.ratio) { height = 2.5; width = height * data.ratio; }
        
        const geo = new THREE.PlaneGeometry(width, height);
        // Use texture if available, but transparent
        let tex = null;
        if (data.type !== 'video') { // Don't preload video for ghost, just use color
             tex = new THREE.TextureLoader().load(data.src);
        }
        
        const mat = new THREE.MeshBasicMaterial({ 
            map: tex, color: tex ? 0xffffff : 0x00ffff, 
            transparent: true, opacity: 0.5, side: THREE.DoubleSide, wireframe: false 
        });
        
        ghostMesh = new THREE.Mesh(geo, mat);
        // Add wireframe
        ghostMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x00ff00 })));
        
        scene.add(ghostMesh);
    }

    function confirmPlacement() {
        if (!ghostMesh) return;
        
        // Spawn Real Object at Ghost Transform
        spawnDecryptedScreen(ghostMesh.position, placementData, ghostMesh.rotation);
        
        // Cleanup
        scene.remove(ghostMesh);
        ghostMesh = null;
        placementData = null;
    }

    function cancelPlacement() {
        if (ghostMesh) { scene.remove(ghostMesh); ghostMesh = null; }
        placementData = null;
    }

    function updateGhost(pad) {
        if (!ghostMesh) return;
        
        // 1. Position: Locked to Camera + Distance
        const dir = new THREE.Vector3(); 
        camera.getWorldDirection(dir);
        // Add "Look Offset" - if we look up, ghost goes up.
        // We calculate position directly
        const targetPos = camera.position.clone().add(dir.multiplyScalar(placementDist));
        
        // Smooth lerp for visual comfort
        ghostMesh.position.lerp(targetPos, 0.2);
        
        // 2. Rotation: Face Camera by default, but allow manual override
        // If we haven't manually rotated much, keep facing camera
        // For simplicity, let's make it always LookAt camera Y-axis only?
        // Let's implement MANUAL Rotation via Bumpers
        
        if (pad.buttons[4].pressed) ghostMesh.rotation.y += 0.05; // L1
        if (pad.buttons[5].pressed) ghostMesh.rotation.y -= 0.05; // R1
        
        // Ensure it stays upright
        ghostMesh.rotation.x = 0;
        ghostMesh.rotation.z = 0;
    }

    function pickupObject(obj) {
        // Convert existing object back to data
        const data = obj.userData.data;
        // Delete existing
        deleteObject(obj);
        // Start placement with data
        startPlacement(data);
    }

    // --- 5. SAVING ---
    function saveMission() {
        const objectsToSave = [];
        targets.forEach(t => {
            objectsToSave.push({
                x: t.position.x, y: t.position.y, z: t.position.z,
                rx: t.rotation.x, ry: t.rotation.y, rz: t.rotation.z,
                data: t.userData.data
            });
        });
        try {
            localStorage.setItem('helen_architect_save', JSON.stringify(objectsToSave));
            showSystemMessage("LAYOUT SAVED");
        } catch(e) { showSystemMessage("SAVE FAILED (FULL)"); }
    }

    function applySaveData() {
        const data = localStorage.getItem('helen_architect_save');
        if (!data) return;
        JSON.parse(data).forEach(obj => {
            const pos = new THREE.Vector3(obj.x, obj.y, obj.z);
            const rot = new THREE.Euler(obj.rx, obj.ry, obj.rz);
            spawnDecryptedScreen(pos, obj.data, rot);
        });
        showSystemMessage("LAYOUT RESTORED");
    }

    function showSystemMessage(msg) {
        systemMessage = msg; updateMenuDisplay();
        setTimeout(() => { systemMessage = ""; updateMenuDisplay(); }, 3000);
    }

    // --- 6. MENU ---
    function createMenuSystem() {
        menuGroup = new THREE.Group();
        menuCanvas = document.createElement('canvas'); menuCanvas.width = 1024; menuCanvas.height = 1024;
        menuCtx = menuCanvas.getContext('2d'); menuTexture = new THREE.CanvasTexture(menuCanvas);
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: menuTexture, transparent: true, side: THREE.DoubleSide });
        menuMesh = new THREE.Mesh(geometry, material); menuGroup.add(menuMesh);
        menuGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x00ffff })));
        scene.add(menuGroup); menuGroup.visible = false;
    }

    function updateMenuDisplay() {
        const ctx = menuCtx; const w = 1024; const h = 1024;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        ctx.fillStyle = 'rgba(0, 10, 20, 0.9)'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 60px Courier New'; ctx.textAlign = 'center'; ctx.fillText("ARCHITECT INVENTORY", w/2, 80);
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(50, 100); ctx.lineTo(w-50, 100); ctx.stroke();
        
        const sysOpts = [" [SAVE LAYOUT]", " [WIPE DATA]"];
        ctx.textAlign = 'left'; ctx.font = '50px Courier New';
        let listY = 180;
        for (let i=0; i<sysOpts.length; i++) {
             if (i === hoveredFileIndex) { ctx.fillStyle = '#ff0055'; ctx.fillRect(50, listY - 50, w - 100, 60); ctx.fillStyle = '#fff'; ctx.fillText(sysOpts[i], 80, listY); } 
             else { ctx.fillStyle = '#ff0055'; ctx.fillText(sysOpts[i], 80, listY); }
            listY += 70;
        }

        ctx.fillStyle = '#00aaaa'; 
        for (let i = 0; i < Math.min(db.length, 8); i++) {
            const menuIndex = i + sysOpts.length;
            if (menuIndex === hoveredFileIndex) { ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(50, listY - 50, w - 100, 60); ctx.fillStyle = '#fff'; ctx.fillText(`> ${db[i].label}`, 80, listY); } 
            else { ctx.fillStyle = '#00aaaa'; ctx.fillText(`  ${db[i].label}`, 80, listY); }
            ctx.fillStyle = '#666'; ctx.fillText(db[i].type.toUpperCase(), w - 200, listY);
            listY += 70;
        }
        if (systemMessage) { ctx.fillStyle = '#00ff00'; ctx.fillRect(100, h/2 - 50, w-200, 100); ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.fillText(systemMessage, w/2, h/2 + 15); }
        menuTexture.needsUpdate = true;
    }

    function spawnFromMenu(index) {
        if (index === 0) { saveMission(); return; }
        if (index === 1) { localStorage.removeItem('helen_architect_save'); showSystemMessage("WIPED"); return; }
        
        const fileIndex = index - 2;
        const db = CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE : DEFAULT_DATABASE;
        if (fileIndex >= 0 && fileIndex < db.length) {
            // ENTER GHOST MODE
            startPlacement(db[fileIndex]);
            isMenuOpen = false; menuGroup.visible = false;
        }
    }

    function spawnDecryptedScreen(position, data, rotation = null) {
        let width = 3, height = 1.8; 
        let material, videoElem = null;
        if (data.type === 'pdf') {
            if (data.ratio) { height = 2.5; width = height * data.ratio; }
            const tex = new THREE.TextureLoader().load(data.src); tex.colorSpace = THREE.SRGBColorSpace;
            material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        } else if (data.type === 'video') {
            videoElem = document.createElement('video'); videoElem.src = data.src; videoElem.crossOrigin = "anonymous"; videoElem.loop = true; videoElem.muted = true; 
            videoElem.play().then(() => { videoElem.muted = false; });
            const tex = new THREE.VideoTexture(videoElem); tex.colorSpace = THREE.SRGBColorSpace;
            material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        } else {
            const tex = new THREE.TextureLoader().load(data.src); tex.colorSpace = THREE.SRGBColorSpace;
            material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        }
        const geometry = new THREE.PlaneGeometry(width, height);
        const screen = new THREE.Mesh(geometry, material);
        screen.position.copy(position); 
        if (rotation) screen.rotation.copy(rotation); else { screen.lookAt(camera.position); screen.rotation.z = 0; screen.rotation.x = 0; }
        screen.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: data.type === 'pdf' ? 0xffff00 : 0x00ffff })));
        screen.userData = { isScreen: true, label: data.label, videoElement: videoElem, data: data };
        scene.add(screen); targets.push(screen);
    }

    function deleteObject(obj) {
        if (obj.userData.videoElement) { obj.userData.videoElement.pause(); obj.userData.videoElement.src = ""; obj.userData.videoElement.load(); }
        if (obj.material.map) obj.material.map.dispose();
        obj.material.dispose(); obj.geometry.dispose();
        scene.remove(obj); targets = targets.filter(t => t !== obj);
    }

    // --- INPUT LOOP ---
    function handleInput() {
        const pads = navigator.getGamepads(); if(!pads[0]) return;
        const pad = pads[0];
        
        // MOVEMENT
        const x = Math.abs(pad.axes[0]) > 0.1 ? pad.axes[0] : 0; const z = Math.abs(pad.axes[1]) > 0.1 ? pad.axes[1] : 0;
        if (x !== 0 || z !== 0) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize(); _strafeDir.crossVectors(camera.up, _moveDir).normalize();
            dolly.position.addScaledVector(_moveDir, -z * SPEED); dolly.position.addScaledVector(_strafeDir, x * SPEED);
        }
        
        // SQUARE: MENU (Only if not placing)
        if (pad.buttons[2].pressed && !lastBtn.square && !ghostMesh) {
            isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen;
            if (isMenuOpen) {
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                menuGroup.position.copy(camera.position.clone().add(dir.multiplyScalar(2.5)));
                menuGroup.lookAt(camera.position); updateMenuDisplay();
            }
        }
        lastBtn.square = pad.buttons[2].pressed;

        // GHOST MODE LOGIC
        if (ghostMesh) {
            updateGhost(pad);
            // X: PLACE
            if (pad.buttons[0].pressed && !lastBtn.x) confirmPlacement();
            // CIRCLE: CANCEL
            if (pad.buttons[1].pressed && !lastBtn.circle) cancelPlacement();
        } 
        else {
            // NORMAL MODE
            
            // TRIANGLE: VISION
            if (pad.buttons[3].pressed && !lastBtn.triangle) {
                visionMode = (visionMode + 1) % 3;
                if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
                if (visionMode === 1 && torchCamId) startCameraStream(torchCamId).then(()=>videoTrack?.applyConstraints({advanced:[{torch:true}]}));
                else { videoTrack?.applyConstraints({advanced:[{torch:false}]}); if(visionMode === 0 && wideCamId) setTimeout(()=>startCameraStream(wideCamId),300); }
            }
            lastBtn.triangle = pad.buttons[3].pressed;

            // BUMPER: CYCLE LENS (Only if not ghost)
            if ((pad.buttons[4].pressed || pad.buttons[5].pressed) && !lastBtn.bumper && allBackCameras.length > 1) {
                const idx = (allBackCameras.indexOf(activeCamId) + 1) % allBackCameras.length;
                startCameraStream(allBackCameras[idx]);
            }
            lastBtn.bumper = pad.buttons[4].pressed || pad.buttons[5].pressed;

            // INTERACTION
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            if (isMenuOpen) {
                const intersects = raycaster.intersectObject(menuMesh);
                if (intersects.length > 0) {
                    const uvY = intersects[0].uv.y;
                    if (uvY < 0.82) {
                        const idx = Math.floor((0.82 - uvY) / 0.068);
                        if (idx >= 0 && idx < 20 && hoveredFileIndex !== idx) { hoveredFileIndex = idx; updateMenuDisplay(); }
                    }
                } else hoveredFileIndex = -1; 
                if (pad.buttons[0].pressed && !lastBtn.x && hoveredFileIndex !== -1) spawnFromMenu(hoveredFileIndex);
            } 
            else {
                const intersects = raycaster.intersectObjects(targets);
                if (intersects.length > 0) {
                    activeObject.obj = intersects[0].object;
                    // CIRCLE: DELETE
                    if (pad.buttons[1].pressed && !lastBtn.circle) { deleteObject(activeObject.obj); activeObject.obj = null; }
                    
                    // HOLD X: PICK UP (Move)
                    if (pad.buttons[0].pressed) {
                        holdTimer++;
                        if (holdTimer > 20) { // Approx 0.3s
                            pickupObject(activeObject.obj);
                            holdTimer = 0;
                        }
                    } else { holdTimer = 0; }

                } else { activeObject.obj = null; holdTimer = 0; }
            }
        }
        
        lastBtn.x = pad.buttons[0].pressed; lastBtn.circle = pad.buttons[1].pressed;
    }

    function updateHUD() {
        if(!hudContext) return;
        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
        else if(visionMode === 2) { ctx.fillStyle = '#ff0000'; ctx.fillText("VISION: [VOID]", w-40, 60); }
        else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }

        const cx = w/2; const cy = h/2;
        
        if (ghostMesh) {
             ctx.fillStyle = '#00ff00'; ctx.textAlign = 'center'; 
             ctx.fillText("PLACEMENT MODE", cx, cy + 150);
             ctx.font = '20px Courier New'; ctx.fillStyle = '#fff';
             ctx.fillText("[L1/R1] ROTATE   [X] CONFIRM   [O] CANCEL", cx, cy + 190);
             // Ghost Crosshair
             ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath();
             ctx.moveTo(cx - 40, cy); ctx.lineTo(cx + 40, cy); ctx.moveTo(cx, cy - 40); ctx.lineTo(cx, cy + 40); ctx.stroke();

        } else if (isMenuOpen) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.fillText("MENU OPEN", cx, cy + 200);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10); ctx.stroke();
        } else if (activeObject.obj) {
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, 2*Math.PI); ctx.stroke();
            ctx.textAlign = 'center'; ctx.font = '20px Courier New'; ctx.fillStyle = '#fff'; 
            ctx.fillText(activeObject.obj.userData.label, cx, cy + 80); 
            ctx.fillText("[O] DELETE", cx, cy + 120);
            
            // Show Hold Progress
            if (holdTimer > 0) {
                 ctx.fillStyle = '#00ff00'; ctx.fillRect(cx-50, cy+140, holdTimer * 5, 10);
                 ctx.fillText("HOLD TO MOVE", cx, cy + 170); 
            }
        } else {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { handleInput(); updateHUD(); renderer.render(scene, camera); });
    }
</script>
</body>
</html>
