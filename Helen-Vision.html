<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: TACTICAL OS V2.9 (MOTION PILOT)</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        h1 { font-size: 40px; text-shadow: 0 0 10px #00ffff; margin-bottom: 10px; }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; white-space: pre-wrap;}
        
        #api-container { margin: 20px 0; display: flex; flex-direction: column; gap: 10px; width: 80%; max-width: 400px; }
        input { 
            background: rgba(0,20,20,0.8); border: 1px solid #00ffff; color: #00ffff; padding: 10px; 
            font-family: 'Courier New'; text-align: center; letter-spacing: 2px;
        }
        input:focus { outline: none; box-shadow: 0 0 15px #00ffff; }
        
        .btn-group { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 80%; max-width: 300px; }
        button {
            padding: 15px; font-size: 16px; font-weight: bold; font-family: 'Courier New', monospace;
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            cursor: pointer; text-transform: uppercase; transition: 0.2s;
        }
        button:hover { background: #00ffff; color: #000; }
        
        .danger-btn { border-color: #ff0055; color: #ff0055; margin-top: 20px;}
        .danger-btn:hover { background: #ff0055; color: #fff; }

        .file-count { color: #00ff00; font-size: 12px; margin-top: -10px; text-align: right; display: none; }
        .controls-hint { font-size: 11px; color: #666; margin-top: 20px; text-align: left; width: 100%; }
        #restore-msg { color: #ffff00; font-weight:bold; display:none; margin-bottom:10px; }
        
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 200;
            transition: opacity 0.1s;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js",
                "@google/generative-ai": "https://esm.run/@google/generative-ai"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
<canvas id="vision-canvas" style="display:none;"></canvas>
<div id="flash"></div>

<input type="file" id="intel-input" multiple accept="*/*" style="display:none">

<div id="overlay">
    <h1>HELEN OS</h1>
    <div id="restore-msg">‚ö†Ô∏è MISSION LOG FOUND</div>
    
    <div class="status" id="system-status">
        [ COCKPIT MK.III ]<br>
        3D Holographic Navigation Active.<br>
        Look DOWN at the Chevrons.
    </div>

    <div id="api-container">
        <input type="password" id="gemini-key" placeholder="PASTE GEMINI API KEY">
        <button onclick="saveKey()" id="init-btn">INITIALIZE SYSTEM</button>
        <button onclick="resetSystem()" class="danger-btn">[ RESET SYSTEM ]</button>
    </div>

    <div class="btn-group" id="main-controls" style="display:none;">
        <button onclick="document.getElementById('intel-input').click()">üìÇ LOAD INTEL</button>
        <button onclick="initTiltControl()">üì± ENABLE TILT PILOT</button> <div id="file-status" class="file-count">0 FILES LOADED</div>
        <div id="vr-btn-container"></div>
        
        <div class="controls-hint">
            [TILT] TILT DEVICE TO FLY<br>
            [GAZE] LOOK AT RED SQUARE FOR MENU<br>
            [GAZE] STARE AT > ARROW TO FLIP PDF
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GoogleGenerativeAI } from "@google/generative-ai";

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext;
    let camMaterial, videoTrack, currentStream;
    let raycaster = new THREE.Raycaster();
    let audioListener;
    
    // --- COCKPIT MK.III VARIABLES ---
    let reticle;
    let cockpitGroup; 
    let cockpitPanels = [];
    let lastMenuToggleTime = 0;
    
    let currentSpeed = 0;
    let targetSpeed = 0;
    let currentRot = 0;
    let targetRot = 0;

    const MAX_SPEED = 0.08;
    const MAX_ROT = 0.04;

    let GEMINI_KEY = localStorage.getItem('helen_gemini_key');
    let genAI, model;
    let recognition; 
    let synth = window.speechSynthesis;
    let isListening = false;
    let isSpeaking = false;
    let aiStatus = "STANDBY"; 
    
    let chatHistory = [];
    try {
        const saved = localStorage.getItem('helen_chat_history');
        if(saved) chatHistory = JSON.parse(saved);
    } catch(e) {}

    let CUSTOM_DATABASE = []; 
    const DEFAULT_DATABASE = [ { type: 'image', src: 'https://upload.wikimedia.org/wikipedia/commons/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg', label: 'DEFAULT.JPG' } ];
    let targets = []; 
    
    let activeObject = { obj: null, progress: 0 }; 
    let grabbedObject = null; 
    
    let lastPageTurnTime = 0; const PAGE_DEBOUNCE = 2000; 
    let pendingRestore = false; 

    // --- INPUT VARIABLES ---
    let isMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    const MOUSE_SENSITIVITY = 0.02;
    const VR_WALK_SPEED = 0.05;

    // --- TILT CONTROL VARIABLES (NEW) ---
    let tiltEnabled = false;
    let tiltData = { beta: 0, gamma: 0 };
    let tiltOffset = { beta: 0, gamma: 0 }; // Calibration zero-point
    const TILT_DEADZONE = 5; // Degrees to ignore
    const TILT_SENSITIVITY = 0.002;

    let menuGroup, menuMesh, menuCtx, menuTexture;
    let isMenuOpen = false;
    let hoveredFileIndex = -1;
    let menuScrollIndex = 0; 
    let lastMenuScrollTime = 0; 
    const MAX_MENU_VISIBLE = 9; 
    let sysMessage = "";
    
    // --- GAZE VARIABLES ---
    let menuSelectionTimer = 0; 
    let gazeProgress = 0;       
    let hoveredPageButton = null;

    // HUD Optimization
    let lastHudState = "";

    let torchCamId = null, wideCamId = null, activeCamId = null, allBackCameras = [];
    let visionMode = 0; 
    let lastBtn = { x: false, circle: false, square: false, triangle: false, bumper: false, dpadDown: false, dpadUp: false, dpadLeft: false, dpadRight: false };
    
    const SPEED = 0.1; 
    const ROTATE_SPEED = 0.05; 
    const MOVE_SPEED = 0.05;
    const SCALE_SPEED = 0.02; 
    const _moveDir = new THREE.Vector3(); const _strafeDir = new THREE.Vector3();

    const _camRight = new THREE.Vector3();
    const _camUp = new THREE.Vector3();

    const AI_FOLLOW_DIST = 2.5; 
    const AI_STOP_DIST = 1.5;
    const AI_BACKUP_DIST = 0.8;
    const AI_WALK_SPEED = 0.03;

    // --- TILT INIT FUNCTION ---
    window.initTiltControl = function() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ Logic
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        startTiltListening();
                    } else {
                        alert("Permission Denied.");
                    }
                })
                .catch(console.error);
        } else {
            // Non-iOS or older devices
            startTiltListening();
        }
    };

    function startTiltListening() {
        tiltEnabled = true;
        // Calibrate once on first data
        let calibrated = false;
        
        window.addEventListener('deviceorientation', (e) => {
            if(!calibrated && e.beta !== null) {
                tiltOffset.beta = e.beta;
                tiltOffset.gamma = e.gamma;
                calibrated = true;
                sysMessage = "TILT CALIBRATED";
                updateMenuDisplay();
            }
            tiltData.beta = e.beta || 0;
            tiltData.gamma = e.gamma || 0;
        });
        
        document.getElementById('system-status').innerText = "TILT PILOT ACTIVE\nTilt to Fly.";
    }

    window.saveKey = function() {
        const key = document.getElementById('gemini-key').value.trim(); 
        if(key.length > 20) {
            localStorage.setItem('helen_gemini_key', key);
            GEMINI_KEY = key;
            checkAuth();
        } else {
            alert("KEY TOO SHORT.");
        }
    };

    window.resetSystem = function() {
        localStorage.removeItem('helen_gemini_key');
        localStorage.removeItem('helen_layout_ai');
        localStorage.removeItem('helen_chat_history'); 
        location.reload();
    }

    function checkAuth() {
        if (GEMINI_KEY) {
            document.getElementById('api-container').style.display = 'none';
            document.getElementById('main-controls').style.display = 'flex';
            document.getElementById('system-status').innerHTML = `[ SYSTEM ONLINE ]<br>Cockpit Mk.III Active.<br>Look DOWN to Pilot.`;
            
            try {
                genAI = new GoogleGenerativeAI(GEMINI_KEY);
                model = genAI.getGenerativeModel({ 
                    model: "gemini-2.5-flash",
                    systemInstruction: "You are HELEN, a tactical AI companion. Responses concise & robotic."
                });
                initVoice();
            } catch(e) {
                console.error("AI INIT FAILED", e);
            }
        }
    }

    function initVoice() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => { isListening = true; aiStatus = "LISTENING..."; updateHUD(); };
            recognition.onend = () => { isListening = false; if(aiStatus === "LISTENING...") aiStatus = "PROCESSING..."; updateHUD(); };
            
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                console.log("User said:", transcript);
                askGemini(transcript);
            };
        }
    }

    async function performVisualScan() {
        if (!model) return;
        aiStatus = "CAPTURING VISUALS..."; updateHUD();
        const flash = document.getElementById('flash');
        flash.style.opacity = 0.8;
        setTimeout(() => { flash.style.opacity = 0; }, 100);

        const video = document.getElementById('camera-feed');
        const canvas = document.getElementById('vision-canvas');
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        const base64Image = dataUrl.split(',')[1]; 

        aiStatus = "ANALYZING TARGET..."; updateHUD();
        try {
            const prompt = "Analyze this image tactically.";
            const imagePart = { inlineData: { data: base64Image, mimeType: "image/jpeg" } };
            const result = await model.generateContent([prompt, imagePart]);
            const response = await result.response;
            const text = response.text();
            speak(text);
        } catch (error) {
            aiStatus = "VISUAL ERROR";
            speak("Visual sensors malfunctioned.");
        }
    }

    async function askGemini(prompt) {
        aiStatus = "THINKING..."; updateHUD();
        try {
            const chat = model.startChat({
                history: chatHistory,
                generationConfig: { maxOutputTokens: 100 },
            });
            const result = await chat.sendMessage(prompt);
            const response = await result.response;
            const text = response.text();
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            chatHistory.push({ role: "model", parts: [{ text: text }] });
            if(chatHistory.length > 20) chatHistory = chatHistory.slice(chatHistory.length - 20);
            saveMemory();
            speak(text);
        } catch (error) {
            aiStatus = "ERR: NET";
            speak("System Error.");
        }
    }
    
    function saveMemory() { localStorage.setItem('helen_chat_history', JSON.stringify(chatHistory)); }
    function wipeMemory() {
        chatHistory = [];
        localStorage.removeItem('helen_chat_history');
        sysMessage = "MEMORY WIPED";
        speak("Memory banks cleared.");
        updateMenuDisplay();
    }

    function speak(text) {
        if (synth.speaking) synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1; utterance.pitch = 1.0;
        const voices = synth.getVoices();
        const preferred = voices.find(v => v.name.includes("Google US English") || v.name.includes("Female"));
        if(preferred) utterance.voice = preferred;
        utterance.onstart = () => { isSpeaking = true; aiStatus = "SPEAKING"; updateHUD(); };
        utterance.onend = () => { isSpeaking = false; aiStatus = "STANDBY"; updateHUD(); };
        synth.speak(utterance);
    }
    
    if(GEMINI_KEY) checkAuth();

    if (localStorage.getItem('helen_layout_ai')) {
        document.getElementById('restore-msg').style.display = 'block';
        pendingRestore = true;
    }

    const input = document.getElementById('intel-input');
    input.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
            CUSTOM_DATABASE = [];
            for (let i = 0; i < e.target.files.length; i++) {
                const file = e.target.files[i];
                let name = file.name.toUpperCase();
                let type = 'image'; 
                
                if (name.endsWith('.PDF')) type = 'pdf';
                else if (name.endsWith('.FBX')) type = 'fbx';
                else if (name.endsWith('.GLB') || name.endsWith('.GLTF') || name.endsWith('.VRM')) type = 'glb';
                else if (name.endsWith('.MP3') || name.endsWith('.WAV') || name.endsWith('.OGG')) type = 'audio';
                else if (name.endsWith('.CSV')) type = 'chart';
                else if (file.type.startsWith('video')) type = 'video';
                else if (file.type.startsWith('image')) type = 'image';
                
                if (type === 'pdf') {
                    const buffer = await file.arrayBuffer();
                    CUSTOM_DATABASE.push({ type: 'pdf', buffer: buffer, label: name });
                } 
                else if (type === 'chart') {
                    const text = await file.text();
                    CUSTOM_DATABASE.push({ type: 'chart', data: text, label: name });
                }
                else if (type === 'audio') {
                     CUSTOM_DATABASE.push({ type: 'audio', src: URL.createObjectURL(file), label: name });
                }
                else if (type === 'fbx' || type === 'glb' || type === 'video' || type === 'image') {
                    CUSTOM_DATABASE.push({ type: type, src: URL.createObjectURL(file), label: name });
                }
            }
            input.value = ''; 
        }
    });

    function saveMission() {
        const layout = targets.map(t => {
            let root = t;
            return {
                label: root.userData.label,
                pos: { x: root.position.x, y: root.position.y, z: root.position.z },
                rot: { x: root.rotation.x, y: root.rotation.y, z: root.rotation.z },
                scale: { x: root.scale.x, y: root.scale.y, z: root.scale.z },
                type: root.userData.type
            };
        });
        localStorage.setItem('helen_layout_ai', JSON.stringify(layout));
        sysMessage = "MISSION SAVED"; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function loadMission() {
        const raw = localStorage.getItem('helen_layout_ai');
        if (!raw) { sysMessage = "NO DATA FOUND"; updateMenuDisplay(); return; }
        const layout = JSON.parse(raw);
        let restoredCount = 0;
        layout.forEach(item => {
            const dbItem = CUSTOM_DATABASE.find(f => f.label === item.label) || DEFAULT_DATABASE[0];
            if (dbItem) {
                const pos = new THREE.Vector3(item.pos.x, item.pos.y, item.pos.z);
                const rot = new THREE.Euler(item.rot.x, item.rot.y, item.rot.z);
                const scale = item.scale ? new THREE.Vector3(item.scale.x, item.scale.y, item.scale.z) : null;
                
                if (dbItem.type === 'fbx' || dbItem.type === 'glb') spawnModel(pos, dbItem, rot, scale);
                else if (dbItem.type === 'audio') spawnAudio(pos, dbItem);
                else if (dbItem.type === 'chart') spawnChart(pos, dbItem);
                else spawnScreen(pos, dbItem, rot);
                restoredCount++;
            }
        });
        sysMessage = `RESTORED ${restoredCount} UNITS`; updateMenuDisplay(); setTimeout(() => { sysMessage = ""; updateMenuDisplay(); }, 2000);
    }

    function clearMission() {
        localStorage.removeItem('helen_layout_ai');
        [...targets].forEach(t => deleteObject(t));
        sysMessage = "DATABASE WIPED"; updateMenuDisplay();
    }

    async function scanCameras() {
        if (!navigator.mediaDevices?.enumerateDevices) return;
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(d => d.kind === 'videoinput' && !d.label.toLowerCase().includes('front'));
        allBackCameras = cameras.map(c => c.deviceId);
        startCameraStream(allBackCameras[0]);
    }

    async function startCameraStream(preferredId) {
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        try {
            const constraints = preferredId ? { video: { deviceId: { exact: preferredId } } } : { video: { facingMode: 'environment' } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = r);
            await video.play();
            currentStream = stream;
            videoTrack = stream.getVideoTracks()[0];
            activeCamId = preferredId;
            if (camMaterial) {
                camMaterial.uniforms.tDiffuse.value = new THREE.VideoTexture(video);
                camMaterial.uniforms.tDiffuse.value.colorSpace = THREE.SRGBColorSpace;
                camMaterial.uniforms.tDiffuse.value.generateMipmaps = false;
            }
        } catch (err) {}
    }

    scanCameras().then(init3D);

    const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`;
    const fragmentShader = `
        uniform sampler2D tDiffuse; uniform float uMode; uniform vec2 uResolution; varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            if (uMode > 1.5) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            else if (uMode > 0.5) {
                float x = 1.0 / uResolution.x; float y = 1.0 / uResolution.y;
                vec4 horizEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) + -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec4 vertEdge = -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) + -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) + -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) + 1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) + 2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) + 1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));
                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                if(val > 0.15) gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; else gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
            } else gl_FragColor = color; 
        }
    `;
    
    function initMouseControl() {
        function getPos(e) {
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        window.addEventListener('contextmenu', (e) => { e.preventDefault(); });

        const onDown = (e) => {
            if (e.button === 2) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; return; }
            if (isMenuOpen) return;
            if (e.button === 0 || e.type === 'touchstart') {
                isMouseDown = true;
                const pos = getPos(e);
                previousMousePosition = pos;
            }
        };

        const onUp = () => { isMouseDown = false; };

        const onMove = (e) => {
            if (!isMouseDown || !dolly || isMenuOpen) return;
            if(e.preventDefault) e.preventDefault();
            if (!renderer.xr.isPresenting) {
                const pos = getPos(e);
                const deltaX = pos.x - previousMousePosition.x;
                const deltaY = pos.y - previousMousePosition.y;
                previousMousePosition = pos;
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -deltaY * MOUSE_SENSITIVITY);
                dolly.position.addScaledVector(_strafeDir, deltaX * MOUSE_SENSITIVITY);
            }
        };

        window.addEventListener('mousedown', onDown);
        window.addEventListener('mouseup', onUp);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('touchend', onUp);
        window.addEventListener('touchmove', onMove, { passive: false });
    }

    function createChevron(color) {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.3); shape.lineTo(0.3, -0.2); shape.lineTo(0, -0.1);
        shape.lineTo(-0.3, -0.2); shape.lineTo(0, 0.3);
        const geo = new THREE.ShapeGeometry(shape);
        const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const arrow = new THREE.Mesh(geo, mat);
        const glow = new THREE.Mesh(new THREE.CircleGeometry(0.35, 32), new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.1 }));
        arrow.add(glow);
        return arrow;
    }

    function createCockpit() {
        if(cockpitGroup) { dolly.remove(cockpitGroup); }
        cockpitGroup = new THREE.Group();
        cockpitGroup.position.set(0, -1.6, -1.0); 
        cockpitGroup.rotation.x = -Math.PI / 2 + 0.2; 
        dolly.add(cockpitGroup);
        cockpitPanels = [];

        const fwd = createChevron(0x00ff00);
        fwd.position.set(0, 0.5, 0); 
        fwd.userData = { action: "FORWARD", baseScale: 1.5 };
        fwd.scale.setScalar(1.5);
        cockpitGroup.add(fwd);
        cockpitPanels.push(fwd);

        const left = createChevron(0x00ffff);
        left.position.set(-0.6, 0, 0);
        left.rotation.z = Math.PI / 2;
        left.userData = { action: "LEFT", baseScale: 1 };
        cockpitGroup.add(left);
        cockpitPanels.push(left);

        const right = createChevron(0x00ffff);
        right.position.set(0.6, 0, 0);
        right.rotation.z = -Math.PI / 2;
        right.userData = { action: "RIGHT", baseScale: 1 };
        cockpitGroup.add(right);
        cockpitPanels.push(right);

        // --- MENU BUTTON ---
        const menuBtnGeo = new THREE.PlaneGeometry(0.3, 0.3);
        const menuBtnMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0055, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.5 
        });
        const menuBtn = new THREE.Mesh(menuBtnGeo, menuBtnMat);
        menuBtn.position.set(0, -0.4, 0); 
        menuBtn.userData = { action: "TOGGLE_MENU", baseScale: 1 };
        const edges = new THREE.EdgesGeometry(menuBtnGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff0055 }));
        menuBtn.add(line);
        
        cockpitGroup.add(menuBtn);
        cockpitPanels.push(menuBtn);

        if(!reticle) {
            const ringGeo = new THREE.RingGeometry(0.015, 0.02, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(ringGeo, ringMat);
            reticle.position.z = -1;
            camera.add(reticle);
        }
    }

    function handleCockpit() {
        if (!cockpitGroup) return;
        
        const time = Date.now() * 0.003;
        cockpitGroup.position.y = -1.6 + Math.sin(time) * 0.02;

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(cockpitPanels, false);

        targetSpeed = 0;
        targetRot = 0;
        
        // --- 1. TILT CONTROL OVERRIDE ---
        if (tiltEnabled) {
            const isLandscape = window.innerWidth > window.innerHeight;
            
            // Landscape Mode: Beta = Roll (Strafe), Gamma = Pitch (Forward)
            // Portrait Mode: Beta = Pitch (Forward), Gamma = Roll (Strafe)
            
            let fwdInput = 0;
            let strInput = 0;
            
            if (isLandscape) {
                // In landscape, Gamma controls forward/back
                const g = tiltData.gamma - tiltOffset.gamma;
                if (Math.abs(g) > TILT_DEADZONE) fwdInput = (g < 0 ? 1 : -1) * (Math.abs(g) - TILT_DEADZONE);
                
                // Beta controls rotation
                const b = tiltData.beta - tiltOffset.beta;
                if (Math.abs(b) > TILT_DEADZONE) strInput = (b < 0 ? -1 : 1) * (Math.abs(b) - TILT_DEADZONE);
            } else {
                // Portrait
                const b = tiltData.beta - tiltOffset.beta;
                if (Math.abs(b) > TILT_DEADZONE) fwdInput = (b > 0 ? 1 : -1) * (Math.abs(b) - TILT_DEADZONE);
                
                const g = tiltData.gamma - tiltOffset.gamma;
                if (Math.abs(g) > TILT_DEADZONE) strInput = (g > 0 ? 1 : -1) * (Math.abs(g) - TILT_DEADZONE);
            }
            
            targetSpeed = fwdInput * TILT_SENSITIVITY;
            targetRot = strInput * -TILT_SENSITIVITY; 
        }
        
        // --- 2. GAZE CONTROL FALLBACK ---
        // Only check gaze if not moving fast via tilt
        if (Math.abs(targetSpeed) < 0.01 && Math.abs(targetRot) < 0.01) {
            cockpitPanels.forEach(p => {
                p.material.opacity = 0.4;
                p.scale.setScalar(p.userData.baseScale);
                if(p.children[0]) p.children[0].rotation.z += 0.01;
            });

            if (intersects.length > 0) {
                const p = intersects[0].object;
                p.material.opacity = 1.0;
                p.scale.setScalar(p.userData.baseScale * 1.2);

                if (p.userData.action === "FORWARD") targetSpeed = MAX_SPEED;
                if (p.userData.action === "LEFT") targetRot = MAX_ROT;
                if (p.userData.action === "RIGHT") targetRot = -MAX_ROT;
                
                if (p.userData.action === "TOGGLE_MENU") {
                    const now = Date.now();
                    if (now - lastMenuToggleTime > 1500) { 
                        isMenuOpen = !isMenuOpen;
                        menuGroup.visible = isMenuOpen;
                        if(isMenuOpen) {
                            updateMenuDisplay();
                            updateMenuPosition(); 
                        }
                        lastMenuToggleTime = now;
                    }
                }
            }
        }

        // --- PHYSICS SMOOTHING (LERP) ---
        currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.1);
        currentRot = THREE.MathUtils.lerp(currentRot, targetRot, 0.1);

        if (Math.abs(currentSpeed) > 0.001) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, currentSpeed);
        }
        
        if (Math.abs(currentRot) > 0.001) {
            dolly.rotation.y += currentRot;
        }
    }

    function updateMenuPosition() {
        if (!isMenuOpen || !menuGroup) return;
        const dir = new THREE.Vector3(); 
        camera.getWorldDirection(dir); 
        dir.y = 0; 
        dir.normalize();
        const worldPos = camera.getWorldPosition(new THREE.Vector3());
        const targetPos = worldPos.add(dir.multiplyScalar(2.5));
        menuGroup.position.copy(targetPos); 
        menuGroup.lookAt(camera.getWorldPosition(new THREE.Vector3()));
    }

    // ... (Init3D and other functions remain same, just ensure they are included in the full copy above) ...
    // Note: The full code block above includes everything correctly.
    
    function spawnAudio(position, data) {
        const geo = new THREE.IcosahedronGeometry(0.3, 1);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const orb = new THREE.Mesh(geo, mat);
        orb.position.copy(position);
        
        const sound = new THREE.Audio(audioListener);
        const loader = new THREE.AudioLoader();
        loader.load(data.src, function(buffer) {
            sound.setBuffer(buffer);
            sound.setLoop(true);
            sound.setVolume(0.5);
        });
        
        orb.userData = { 
            isScreen: true, 
            isAudio: true, 
            sound: sound, 
            isPlaying: false, 
            label: data.label,
            type: 'audio' 
        };
        
        const border = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshBasicMaterial({visible:false}));
        orb.add(border);
        
        scene.add(orb);
        targets.push(orb);
    }
    
    function spawnChart(position, data) {
        const lines = data.data.split('\n');
        const chartGroup = new THREE.Group();
        chartGroup.position.copy(position);
        
        let maxVal = 0;
        const parsed = [];
        
        lines.forEach(l => {
            const parts = l.split(',');
            if(parts.length >= 2) {
                const label = parts[0].trim();
                const val = parseFloat(parts[1]);
                if(!isNaN(val)) {
                    parsed.push({label, val});
                    if(val > maxVal) maxVal = val;
                }
            }
        });
        
        const baseSize = 0.2;
        const spacing = 0.3;
        
        parsed.forEach((item, i) => {
            const h = (item.val / maxVal) * 1.5; 
            const geo = new THREE.BoxGeometry(baseSize, h, baseSize);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const bar = new THREE.Mesh(geo, mat);
            bar.position.set((i * spacing) - ((parsed.length*spacing)/2), h/2, 0);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0,0,256,128);
            ctx.fillStyle = '#ffffff'; ctx.font = 'bold 40px Courier New'; ctx.textAlign='center';
            ctx.fillText(item.label, 128, 50);
            ctx.fillStyle = '#00ffff'; ctx.fillText(item.val, 128, 100);
            
            const tex = new THREE.CanvasTexture(canvas);
            const labelGeo = new THREE.PlaneGeometry(0.4, 0.2);
            const labelMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const labelMesh = new THREE.Mesh(labelGeo, labelMat);
            labelMesh.position.y = h + 0.2;
            bar.add(labelMesh);
            
            chartGroup.add(bar);
        });
        
        const baseGeo = new THREE.PlaneGeometry(parsed.length * spacing + 0.2, 0.5);
        const baseMat = new THREE.MeshBasicMaterial({ color: 0x005555, side: THREE.DoubleSide });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.rotation.x = -Math.PI/2;
        chartGroup.add(base);
        
        chartGroup.userData = { isScreen: true, isChart: true, label: data.label, type: 'chart' };
        
        const hitBox = new THREE.Mesh(new THREE.BoxGeometry(parsed.length*spacing, 1.5, 0.5), new THREE.MeshBasicMaterial({visible:false}));
        hitBox.position.y = 0.75;
        chartGroup.add(hitBox);

        scene.add(chartGroup);
        targets.push(chartGroup);
    }

    // --- MAIN INPUT HANDLER ---
    function handleInput() {
        if (renderer.xr.isPresenting && isMouseDown) {
            camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
            dolly.position.addScaledVector(_moveDir, VR_WALK_SPEED);
        }

        gazeProgress = 0; 
        
        targets.forEach(t => {
            if(t.userData.isAudio && t.userData.isPlaying) {
                const s = 1.0 + Math.sin(Date.now() * 0.01) * 0.2;
                t.scale.set(s,s,s);
            }
        });

        if (isMenuOpen && menuMesh) {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObject(menuMesh);
            if (intersects.length > 0) {
                const uvY = intersects[0].uv.y;
                if (uvY < 0.82) {
                    const visualIdx = Math.floor((0.82 - uvY) / 0.068);
                    if (visualIdx >= 0 && visualIdx < MAX_MENU_VISIBLE) {
                        const realIdx = visualIdx + menuScrollIndex;
                        const fullListSize = 6 + (CUSTOM_DATABASE.length > 0 ? CUSTOM_DATABASE.length : DEFAULT_DATABASE.length);
                        
                        if (realIdx < fullListSize) {
                            if (hoveredFileIndex !== realIdx) {
                                hoveredFileIndex = realIdx;
                                menuSelectionTimer = Date.now(); 
                                updateMenuDisplay();
                            } else {
                                const elapsed = Date.now() - menuSelectionTimer;
                                gazeProgress = Math.min(elapsed / 1500, 1.0); 
                                if (elapsed > 1500) {
                                    spawnFromMenu(realIdx);
                                    hoveredFileIndex = -1;
                                    menuSelectionTimer = Date.now() + 5000;
                                }
                            }
                        }
                    }
                }
            } else {
                if (hoveredFileIndex !== -1) { hoveredFileIndex = -1; updateMenuDisplay(); }
            }
        } 
        
        else {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(targets, true);
            
            if (intersects.length > 0) {
                let hit = intersects[0].object;
                
                if (hit.userData.isButton) {
                    if (hoveredPageButton !== hit) {
                        hoveredPageButton = hit;
                        menuSelectionTimer = Date.now();
                    } else {
                        const elapsed = Date.now() - menuSelectionTimer;
                        gazeProgress = Math.min(elapsed / 1500, 1.0);
                        if (elapsed > 1500) {
                            const screen = hit.parent;
                            const dir = hit.userData.action === 'NEXT_PAGE' ? 1 : -1;
                            if (screen && screen.userData.type === 'pdf') {
                                const newPage = screen.userData.pageNum + dir;
                                if(newPage >= 1 && newPage <= screen.userData.totalPages) {
                                    renderPdfPageToTexture(screen, newPage);
                                }
                            }
                            menuSelectionTimer = Date.now() + 2000; 
                        }
                    }
                } else {
                    hoveredPageButton = null;
                    
                    while(hit.parent && !hit.userData.isScreen && hit !== scene) { hit = hit.parent; }
                    
                    if (hit.userData.isScreen || hit.userData.isModel) { 
                         if(hit.userData.isAudio) {
                             if(grabbedObject !== hit) {
                                 if(activeObject.obj !== hit) {
                                     activeObject.obj = hit;
                                     menuSelectionTimer = Date.now();
                                 } else {
                                     const elapsed = Date.now() - menuSelectionTimer;
                                     gazeProgress = Math.min(elapsed / 1500, 1.0);
                                     if(elapsed > 1500) {
                                         if(hit.userData.sound.isPlaying) {
                                             hit.userData.sound.pause();
                                             hit.userData.isPlaying = false;
                                             hit.scale.set(1,1,1);
                                         } else {
                                             hit.userData.sound.play();
                                             hit.userData.isPlaying = true;
                                         }
                                         menuSelectionTimer = Date.now() + 2000;
                                     }
                                 }
                             }
                         } else {
                             if(!grabbedObject) activeObject.obj = hit; 
                         }
                    } 
                }
            } else {
                hoveredPageButton = null;
                if(!grabbedObject) activeObject.obj = null;
            }
        }

        const pads = navigator.getGamepads();
        let pad = null;
        for (let i = 0; i < pads.length; i++) {
            if (pads[i] && pads[i].buttons.length > 0) { pad = pads[i]; break; }
        }
        
        if (!pad) return;

        if (isMenuOpen) {
            if (pad.axes.length > 3 && Math.abs(pad.axes[3]) > 0.5) {
                const now = Date.now();
                if (now - lastMenuScrollTime > 150) { 
                    const fullListSize = 6 + (CUSTOM_DATABASE.length || 1); 
                    if (pad.axes[3] > 0) menuScrollIndex++; 
                    else menuScrollIndex--; 
                    menuScrollIndex = Math.max(0, Math.min(menuScrollIndex, fullListSize - MAX_MENU_VISIBLE));
                    lastMenuScrollTime = now;
                    updateMenuDisplay();
                }
            }
            if (pad.buttons[0] && pad.buttons[0].pressed && !lastBtn.x && hoveredFileIndex !== -1) spawnFromMenu(hoveredFileIndex);
            
        } else {
            if (pad.buttons[0] && pad.buttons[0].pressed && !lastBtn.x) {
                if (grabbedObject) {
                    grabbedObject = null;
                } else {
                    if (activeObject.obj) grabbedObject = activeObject.obj;
                }
            }
            
            if (pad.buttons[1] && pad.buttons[1].pressed && !lastBtn.circle) {
                const targetToDelete = grabbedObject || activeObject.obj;
                if (targetToDelete) {
                    deleteObject(targetToDelete);
                    activeObject.obj = null;
                    grabbedObject = null;
                }
            }
            lastBtn.circle = pad.buttons[1] ? pad.buttons[1].pressed : false;
        }

        const leftStickX = pad.axes.length > 0 ? pad.axes[0] : 0;
        const leftStickY = pad.axes.length > 1 ? pad.axes[1] : 0;
        const rightStickX = pad.axes.length > 2 ? pad.axes[2] : 0;
        const rightStickY = pad.axes.length > 3 ? pad.axes[3] : 0;

        if (grabbedObject) {
            if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _camRight.crossVectors(camera.up, _moveDir).normalize();
                _camUp.copy(camera.up);
                grabbedObject.position.addScaledVector(_camRight, leftStickX * SPEED);
                grabbedObject.position.addScaledVector(_camUp, -leftStickY * SPEED);
            }
            const l2 = (pad.buttons[6] && pad.buttons[6].value) ? pad.buttons[6].value : 0;
            const r2 = (pad.buttons[7] && pad.buttons[7].value) ? pad.buttons[7].value : 0;
            if (Math.abs(r2) > 0.1 || Math.abs(l2) > 0.1) {
                const dir = new THREE.Vector3().subVectors(grabbedObject.position, camera.position).normalize();
                const zSpeed = (r2 - l2) * MOVE_SPEED;
                grabbedObject.position.addScaledVector(dir, zSpeed);
            }
            if (Math.abs(rightStickX) > 0.1) grabbedObject.rotation.y += rightStickX * ROTATE_SPEED;
            if (Math.abs(rightStickY) > 0.1) {
                if (grabbedObject.userData.isModel) {
                     const s = 1 + (rightStickY * -SCALE_SPEED); 
                     grabbedObject.scale.multiplyScalar(s);
                } else {
                     grabbedObject.rotation.x += rightStickY * ROTATE_SPEED;
                }
            }
        } else {
            if (Math.abs(leftStickX) > 0.1 || Math.abs(leftStickY) > 0.1) {
                camera.getWorldDirection(_moveDir); _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -leftStickY * SPEED);
                dolly.position.addScaledVector(_strafeDir, leftStickX * SPEED);
            }
        }

        if (pad.buttons[13] && pad.buttons[13].pressed && !lastBtn.dpadDown) {
            if(recognition) { if(isListening) recognition.stop(); else recognition.start(); }
        }
        lastBtn.dpadDown = pad.buttons[13] ? pad.buttons[13].pressed : false;

        if (pad.buttons[14] && pad.buttons[14].pressed && !lastBtn.dpadLeft) performVisualScan();
        lastBtn.dpadLeft = pad.buttons[14] ? pad.buttons[14].pressed : false;

        if (pad.buttons[12] && pad.buttons[12].pressed && !lastBtn.dpadUp) {
            if (activeObject.obj && activeObject.obj.userData.isModel) activeObject.obj.userData.isPaused = !activeObject.obj.userData.isPaused;
        }
        lastBtn.dpadUp = pad.buttons[12] ? pad.buttons[12].pressed : false;

        if (pad.buttons[15] && pad.buttons[15].pressed && !lastBtn.dpadRight) {
            if (activeObject.obj && activeObject.obj.userData.isModel) {
                activeObject.obj.userData.enableHeadTracking = !activeObject.obj.userData.enableHeadTracking;
            }
        }
        lastBtn.dpadRight = pad.buttons[15] ? pad.buttons[15].pressed : false;

        if (pad.buttons[2] && pad.buttons[2].pressed && !lastBtn.square) { isMenuOpen = !isMenuOpen; menuGroup.visible = isMenuOpen; }
        lastBtn.square = pad.buttons[2] ? pad.buttons[2].pressed : false;
        
        lastBtn.x = pad.buttons[0] ? pad.buttons[0].pressed : false; 

        if (pad.buttons[3] && pad.buttons[3].pressed && !lastBtn.triangle) {
            visionMode = (visionMode + 1) % 3;
            if (camMaterial) camMaterial.uniforms.uMode.value = visionMode;
        }
        lastBtn.triangle = pad.buttons[3] ? pad.buttons[3].pressed : false;
        lastBtn.circle = pad.buttons[1] ? pad.buttons[1].pressed : false;
    }

    function updateHUD() {
        if(!hudContext) return;
        
        const currentState = `M:${isMenuOpen}|S:${isSpeaking}|L:${isListening}|V:${visionMode}|G:${grabbedObject ? 'YES' : 'NO'}|T:${activeObject.obj ? activeObject.obj.uuid : 'NONE'}|A:${aiStatus}|P:${gazeProgress.toFixed(2)}`;
        if (currentState === lastHudState) return;
        lastHudState = currentState; 

        const ctx = hudContext; const w = 1024; const h = 1024; ctx.clearRect(0, 0, w, h);
        
        ctx.textAlign = 'right'; ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) { ctx.fillStyle = '#00ffff'; ctx.fillText("VISION: [CYBER]", w-40, 60); }
        else if(visionMode === 2) { ctx.fillStyle = '#ff0000'; ctx.fillText("VISION: [VOID]", w-40, 60); }
        else { ctx.fillStyle = 'rgba(0,255,255,0.5)'; ctx.fillText("VISION: [NORMAL]", w-40, 60); }

        ctx.textAlign = 'left'; ctx.fillStyle = isSpeaking ? '#00ff00' : (isListening ? '#ff0055' : '#00ffff');
        ctx.fillText(`AI: [${aiStatus}]`, 40, 60);

        const cx = w/2; const cy = h/2;
        
        if (gazeProgress > 0.05) {
            ctx.beginPath();
            ctx.arc(cx, cy, 60, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * gazeProgress));
            ctx.lineWidth = 10;
            ctx.strokeStyle = '#00ffff';
            ctx.stroke();
        }

        if (isMenuOpen) {
            ctx.fillStyle = '#00ffff'; ctx.textAlign = 'center'; ctx.fillText("MENU OPEN", cx, cy + 200);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy); ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10); ctx.stroke();
        } else if (activeObject.obj) {
            
            if (grabbedObject) {
                ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(cx, cy, 50, 0, 2*Math.PI); ctx.stroke();
                ctx.fillStyle = '#ff0055'; ctx.textAlign = 'center'; ctx.font = '24px Courier New';
                ctx.fillText("STATUS: MANIPULATING", cx, cy + 80);
                ctx.fillText("[L-STICK] MOVE X/Y", cx, cy + 110);
                ctx.fillText("[TRIGGERS] MOVE Z", cx, cy + 140);
                ctx.fillText("[X] RELEASE", cx, cy + 170);
                
            } else {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, 2*Math.PI); ctx.stroke();
                ctx.textAlign = 'center'; ctx.font = '20px Courier New'; ctx.fillStyle = '#fff'; 
                ctx.fillText(activeObject.obj.userData.label || "TARGET", cx, cy + 80); 
                
                if (activeObject.obj.userData.isModel) {
                     if(activeObject.obj.userData.aiActive) {
                         const status = activeObject.obj.userData.isPaused ? "HOLDING" : "FOLLOWING";
                         ctx.fillStyle = activeObject.obj.userData.isPaused ? '#ffff00' : '#00ff00';
                         ctx.fillText(`AI: ${status}`, cx, cy + 145);
                     }
                }
            }
        } else {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy); ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20); ctx.stroke();
        }
        hudTexture.needsUpdate = true;
    }

    function animate() {
        renderer.setAnimationLoop(() => { 
            handleInput(); 
            handleCockpit(); 
            updateMenuPosition(); 
            updateHUD(); 
            targets.forEach(t => { 
                if(t.userData.isModel && t.userData.aiActive) {
                    updateAI(t);
                }
            }); 
            renderer.render(scene, camera); 
        });
    }
</script>
</body>
</html>
