<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HELEN: ACTIVE FLASH</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: #00ffff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .status { margin-top: 10px; font-size: 14px; color: #aaa; text-align: center; line-height: 1.5; }
        .warning { color: #ff0055; font-size: 12px; margin-top: 10px; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
            }
        }
    </script>
</head>
<body>

<video id="camera-feed" autoplay muted playsinline style="display:none;"></video>

<div id="overlay">
    <h1>HELEN: FLASHLIGHT</h1>
    <p>ACTIVE ILLUMINATION READY</p>
    <div class="status" id="pad-status">
        [ SYSTEM BOOT ]<br>
        1. Allow Camera Access<br>
        2. Connect Controller<br>
        3. Enter VR<br>
        <span style="color:#fff">PRESS (△) FOR VISION + LIGHT</span>
    </div>
    <div class="warning">NOTE: FLASHLIGHT WORKS ON ANDROID ONLY</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import WebXRPolyfill from 'webxr-polyfill';

    const polyfill = new WebXRPolyfill();

    let scene, camera, renderer, dolly;
    let hudTexture, hudContext, hudMesh;
    let camMaterial, videoTrack; // Store track to control torch
    let targets = []; 
    
    let visionMode = 0; // 0 = Normal, 1 = Cyber-Edge
    let lastBtnState = false; 

    const SPEED = 0.1; 
    const _moveDir = new THREE.Vector3();
    const _strafeDir = new THREE.Vector3();

    // --- SHADERS ---
    const vertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    `;

    const fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform float uMode; 
        uniform vec2 uResolution;
        varying vec2 vUv;

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            if (uMode > 0.5) {
                float x = 1.0 / uResolution.x;
                float y = 1.0 / uResolution.y;
                
                vec4 horizEdge = 
                    -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) +
                    -2.0 * texture2D(tDiffuse, vUv + vec2(-x,  0.0)) +
                    -1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) +
                     1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) +
                     2.0 * texture2D(tDiffuse, vUv + vec2( x,  0.0)) +
                     1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));

                vec4 vertEdge = 
                    -1.0 * texture2D(tDiffuse, vUv + vec2(-x, -y)) +
                    -2.0 * texture2D(tDiffuse, vUv + vec2( 0.0, -y)) +
                    -1.0 * texture2D(tDiffuse, vUv + vec2( x, -y)) +
                     1.0 * texture2D(tDiffuse, vUv + vec2(-x,  y)) +
                     2.0 * texture2D(tDiffuse, vUv + vec2( 0.0,  y)) +
                     1.0 * texture2D(tDiffuse, vUv + vec2( x,  y));

                vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));
                float val = length(edge);
                
                if(val > 0.15) {
                    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0) * val * 2.0; 
                } else {
                    gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0); 
                }
            } else {
                gl_FragColor = color; 
            }
        }
    `;

    initCamera().then(init3D);

    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, 
                audio: false
            });
            const video = document.getElementById('camera-feed');
            video.srcObject = stream;
            
            // SAVE TRACK FOR FLASHLIGHT CONTROL
            videoTrack = stream.getVideoTracks()[0];

            await video.play();
            return true;
        } catch (err) {
            document.getElementById('pad-status').innerText = "CAMERA ERROR:\n" + err;
            return false;
        }
    }

    // --- FLASHLIGHT CONTROL ---
    async function toggleFlashlight(active) {
        if (!videoTrack) return;
        
        // This is the standard API for Android Chrome
        const constraints = {
            advanced: [{ torch: active }]
        };

        try {
            await videoTrack.applyConstraints(constraints);
        } catch (err) {
            console.log("Flashlight not supported on this device/browser");
        }
    }

    function init3D() {
        scene = new THREE.Scene();
        
        dolly = new THREE.Group();
        dolly.position.set(0, 0, 5); 
        scene.add(dolly);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        dolly.add(camera);

        const video = document.getElementById('camera-feed');
        const vidTex = new THREE.VideoTexture(video);
        vidTex.colorSpace = THREE.SRGBColorSpace;
        vidTex.generateMipmaps = false; 
        
        camMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse: { value: vidTex },
                uMode: { value: 0.0 }, 
                uResolution: { value: new THREE.Vector2(1280, 720) }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            depthTest: false,
            depthWrite: false
        });

        const camPlane = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), camMaterial);
        camPlane.position.z = -20; 
        camera.add(camPlane); 

        // HUD Setup
        const hudCanvas = document.createElement('canvas');
        hudCanvas.width = 1024; hudCanvas.height = 1024;
        hudContext = hudCanvas.getContext('2d');
        hudTexture = new THREE.CanvasTexture(hudCanvas);
        hudTexture.minFilter = THREE.LinearFilter;
        
        const hudMat = new THREE.MeshBasicMaterial({ 
            map: hudTexture, transparent: true, opacity: 0.9, depthTest: false 
        });
        hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), hudMat);
        hudMesh.position.set(0, 0, -1.5);
        camera.add(hudMesh);

        // Scene
        const grid = new THREE.GridHelper(40, 40, 0x00ffff, 0x111111);
        grid.material.opacity = 0.2; grid.material.transparent = true;
        scene.add(grid);

        createTerminals();

        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 1));

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const btn = VRButton.createButton(renderer);
        document.getElementById('overlay').appendChild(btn);
        
        window.addEventListener("gamepadconnected", (e) => {
            document.getElementById('pad-status').innerText = "SYSTEM READY\nID: " + e.gamepad.id;
        });

        window.addEventListener('resize', onResize);
        animate();
    }

    function createTerminals() {
        const geo = new THREE.IcosahedronGeometry(0.5, 0);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        for(let i=0; i<8; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set((Math.random()-0.5)*20, 1+Math.random()*2, (Math.random()-0.5)*20);
            scene.add(mesh);
            targets.push(mesh);
        }
    }

    function handleInput() {
        const gamepads = navigator.getGamepads();
        const pad = gamepads[0]; 
        
        if (pad) {
            const x = Math.abs(pad.axes[0]) > 0.1 ? pad.axes[0] : 0;
            const z = Math.abs(pad.axes[1]) > 0.1 ? pad.axes[1] : 0;

            if (x !== 0 || z !== 0) {
                camera.getWorldDirection(_moveDir);
                _moveDir.y = 0; _moveDir.normalize();
                _strafeDir.crossVectors(camera.up, _moveDir).normalize();
                dolly.position.addScaledVector(_moveDir, -z * SPEED);
                dolly.position.addScaledVector(_strafeDir, x * SPEED);
            }

            // BUTTON 3: TRIANGLE (Toggle Mode + Light)
            const btnState = pad.buttons[3].pressed;
            if (btnState && !lastBtnState) {
                // Flip Mode
                visionMode = visionMode === 0 ? 1 : 0;
                
                // 1. Update Shader
                camMaterial.uniforms.uMode.value = visionMode;
                
                // 2. Toggle Physical Flashlight
                toggleFlashlight(visionMode === 1);
            }
            lastBtnState = btnState;
        }
    }

    function updateHUD() {
        const ctx = hudContext;
        const w = 1024; const h = 1024;
        ctx.clearRect(0, 0, w, h);

        ctx.textAlign = 'right';
        ctx.font = 'bold 30px Courier New';
        if(visionMode === 1) {
            // Flash Warning
            if (Date.now() % 500 < 250) { // Blink effect
                ctx.fillStyle = '#00ffff'; 
                ctx.fillText("⚠️ ILLUMINATION ACTIVE", w-40, 100);
            }
            ctx.fillStyle = '#00ffff'; 
            ctx.fillText("VISION: [CYBER-EDGE]", w-40, 60);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4;
            ctx.strokeRect(w-380, 20, 360, 50);
        } else {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; 
            ctx.fillText("VISION: [NORMAL]", w-40, 60);
        }

        // COMPASS
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        let angle = Math.atan2(dir.x, dir.z) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        ctx.textAlign = 'center'; ctx.fillStyle = '#00ff00';
        ctx.fillText(`${Math.round(angle)}°`, w/2, 60);

        // CROSSHAIR
        ctx.strokeStyle = visionMode === 1 ? '#00ffff' : 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2 - 20, h/2); ctx.lineTo(w/2 + 20, h/2);
        ctx.moveTo(w/2, h/2 - 20); ctx.lineTo(w/2, h/2 + 20);
        ctx.stroke();
        
        hudTexture.needsUpdate = true;
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        renderer.setAnimationLoop(() => {
            handleInput();
            updateHUD(); 
            targets.forEach(t => t.rotation.y += 0.01);
            renderer.render(scene, camera);
        });
    }
</script>
</body>
</html>